<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2020%2F06%2F01%2FSpring%E7%BC%93%E5%AD%98%E6%B3%A8%E8%A7%A3%40Cacheable%20%40CacheEvict%20%40CachePut%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Spring缓存注解@Cacheable @CacheEvict @CachePut的区别和使用启动类注解： @EnableCaching 方法上的注解： @CacheEvict--------------------- @Caching( evict = { @CacheEvict(cacheNames = &quot;listUmsOrgByUserNo&quot;, allEntries = true), @CacheEvict(cacheNames = &quot;all-resource-byuser&quot;, allEntries = true), @CacheEvict(cacheNames = &quot;all-role-byuser&quot;, allEntries = true), @CacheEvict(cacheNames = &quot;all-user-byrole&quot;, allEntries = true) } ) @Override public int deleteUmsUserOrgRelate(String id) { return mapper.deleteUmsUserOrgRelate(id); } Cacheable--------------------- @Override @Cacheable(cacheNames = &quot;user-tree&quot;, key = &quot;#systemNo+#orgNo+#range&quot;) public List&lt;HashMap&gt; listUserTree(String systemNo, String orgNo, String range, String isPrimary) { return mapper.getUserTrees(systemNo, orgNo, range, isPrimary); } Cacheable--------------------- @Cacheable(cacheNames = &quot;user&quot;, key = &quot;#userNo&quot;) @Override public UmsUser getUmsUserByNo(String userNo) { return mapper.getUmsUserByNo(userNo); } @CacheEvict(key = “123”)该注解表示要清除123这个key，作用域可以在类上面@CacheConfig(cacheNames = “product”)声明也可以在方法上面这样声明@CacheEvict(cacheNames = “product”,key = “123”) @CachePut(cacheNames = “product”,key = “123”)表示对123这个key进行更新。 ———————————————— 版权声明：本文为CSDN博主「buchicaodetuzi」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/weixin_42404323/article/details/94722161 SpringBus @Bean(name = Bus.DEFAULT_BUS_ID) public SpringBus springBus() { return new SpringBus(); }]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F10%2F05%2Fbash_profile%2F</url>
    <content type="text"><![CDATA[PATH=$PATH:/usr/local/mysql/bin # 设置 JDK 6 #export JAVA_6_HOME=`/usr/libexec/java_home -v 1.6` # 设置 JDK 7 export JAVA_7_HOME=`/usr/libexec/java_home -v 1.7.0_80` # 设置 JDK 8 export JAVA_8_HOME=`/usr/libexec/java_home -v 1.8.0_172` # 可添加其他版本 #默认JDK 7 export JAVA_HOME=$JAVA_8_HOME #alias命令动态切换JDK版本 #alias jdk6=&quot;export JAVA_HOME=$JAVA_6_HOME&quot; alias jdk7=&quot;export JAVA_HOME=$JAVA_7_HOME&quot; alias jdk8=&quot;export JAVA_HOME=$JAVA_8_HOME&quot; export M2_HOME=/Users/ux/Applications/apache-maven-3.5.4 export PATH=$PATH:$M2_HOME/bin ##GO环境配置 export GOPATH=/Users/ux/code/go export GOBIN=$GOPATH/bin export PATH=$PATH:$GOBIN # Setting PATH for Python 3.7 # The original version is saved in .bash_profile.pysave PATH=&quot;/Library/Frameworks/Python.framework/Versions/3.7/bin:${PATH}&quot; export PATH ##添加别名 执行python命令时默认python3 alias python=&quot;/Library/Frameworks/Python.framework/Versions/3.7/bin/python3&quot;]]></content>
  </entry>
  <entry>
    <title><![CDATA[java内存分析]]></title>
    <url>%2F2019%2F08%2F22%2Fjava%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[UXdeMacBookPro:cgov-doc-common ux$ jps 9395 DocCommonWebConfiguration 9411 Jps 9396 Launcher 683 717 RemoteMavenServer UXdeMacBookPro:cgov-doc-common ux$ jmap -dump:format=b,file=heap.bin 9395 Dumping heap to /Users/ux/code/compy/rj/ideaSpringCloud/cgov/cgov-doc-common/heap.bin ... Heap dump file created UXdeMacBookPro:cgov-doc-common ux$ jhat -J-Xmx512m heap.bin Reading from heap.bin... Dump file created Thu Aug 22 16:19:29 CST 2019 Snapshot read, resolving... Resolving 2316249 objects...]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[alfred]]></title>
    <url>%2F2019%2F04%2F22%2Falfred%2F</url>
    <content type="text"><![CDATA[alfred使用中出现的问题Alfred3的搜索书签功能无法使用Mac 的版本是 macOS Mojave 10.14.4，使用 Alfred3的搜索书签功能，发现不能搜索 Safari 和chrome 的书签。 解决办法：在安全隐私设置里面， 完全磁盘访问权限（Full Disk Access） 里面添加Alfred应用。因为 Alfred 是从缓存文件里面读取书签的，所以它需要有这个权限。]]></content>
      <tags>
        <tag>alfred</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[teamviewer]]></title>
    <url>%2F2019%2F03%2F14%2Fmac%E4%B8%8Bteamviewer5%E5%88%86%E9%92%9F%E9%99%90%E5%88%B6%E8%A7%A3%E9%99%A4%2F</url>
    <content type="text"><![CDATA[mac版teamviewer商业限制解除 mac版teamviewer商业限制解除 下载Python脚本，在python2.x(2.7)环境下执行: sudo python2.7 TeamViewer-id-changer.py https://github.com/uxawseny/teamviewers.git]]></content>
      <tags>
        <tag>teamviewer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue]]></title>
    <url>%2F2019%2F03%2F13%2Fvue%2F</url>
    <content type="text"><![CDATA[vue基础知识 vue脚手架基础知识]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wx小商城]]></title>
    <url>%2F2019%2F03%2F11%2Fwx%E5%B0%8F%E5%95%86%E5%9F%8E%2F</url>
    <content type="text"><![CDATA[部署简记关于本机开发调试1.jar的打包 使用maven的package即可，在litemall-master/litemall-all/target下生成一个litemall-all-0.1.0-exec.jar文件，使用下面命令即可将litemall-all-*-exec.jar拷贝到deploy文件夹下，并重命名为litemall.jar cp -f ./litemall-all/target/litemall-all-*-exec.jar ./deploy/litemall/litemall.jar 2.前端代码的打包 安装node依赖 cnpm install 启动前端本地开发环境 cnpm run dev 打包前端代码【生产环境prod】 cnpm run build:prod 【打包后会生成一个dist的文件夹，将dist文件夹部署到tomcat即可】 关于linux上部署远程服务器java8和tomcat安装位置1.java8安装位置 usr/lib/java8 2.tomcat9位置 (端口8081) /root/mysoft/apache-tomcat-9.0.17 启动后端jar命令1.只在当前登录用户下有效，用户退出，jar进程终止 java -jar litemall.jar 2.后台运行jar nohup java -jar litemall.jar 启动tomcat命令进入到tomcat下的bin执行命令 1.启动：sh start.sh 2，停止：sh shutdown.sh 注意litemall-admin/config/下的 dep.env.js dep.env.js dep.env.js 中的BASE_API: &apos;&quot;http://94.191.47.85:8080/admin&quot;&apos; 最好写成域名或ip形式，生产环境不建议写成localhost，因为前后端是分离部署的 linux上配置开发环境后台启动jar/node命令nohup java -jar shareniu.jar &amp; nohup npm run dev &gt; /dev/null &amp; 查看后代进程ps -aux 结束进程kill -9 进程PID 安装nvm，通过nvm安装npmcurl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh | bash nvm --version nvm ls-remote nvm install v6.10.2 https://www.cnblogs.com/tgxh/p/6796062.html node报错：npm rebuild node-sass https://blog.csdn.net/weixin_37404604/article/details/80202979]]></content>
      <tags>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于生活]]></title>
    <url>%2F2018%2F12%2F12%2F%E5%85%B3%E4%BA%8E%E7%94%9F%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[关于杭州杭州，两年前对于我来说，一个完全陌生的城市，两年后的今天，有期待也有失落。 毕业时的迷茫，是我踏进了杭州这座完全陌生的城市，感受着杭州这座城市的酷热与火辣，同时也怀揣着期待，期待更好的明天。 两年弹指一挥间，生活也渐渐轻松了许多，没有刚毕业时的恐惧与彷徨，但是期待少了许多。 2016年刚踏入这座城市，每天上下班30公路的路程，登着一辆二手山地车坚持了半年，半年后换了一辆二手电动单车，并不觉得多么心酸，因为觉得一切都值得。那大概就是青春的朝气吧。 转眼2018年底了，买了张健身卡，觉得应该为自己的健康负责了，应该提升一下自己了。朝气蓬勃的样子，才有味道。（2018年12月12日.记）]]></content>
      <tags>
        <tag>关于生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot下的邮件系统]]></title>
    <url>%2F2018%2F12%2F02%2Fspringboot%E4%B8%8B%E7%9A%84%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[邮件系统的实现条件待续…邮件系统的实现过程待续…]]></content>
      <tags>
        <tag>邮件系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac下远程软件]]></title>
    <url>%2F2018%2F09%2F27%2Fmac%E4%B8%8B%E8%BF%9C%E7%A8%8B%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[jump desktop jump desktop连接windows 直接连接即可，端口会默认3389 remote desktop manager 创建连接 1.添加会话，选择Microsoft Remote Desktop(RDP) 2.(Computer name)填写IP、(用户名)用户名、(密码)密码 3.本地资源中&gt;&gt;本地设备和资源&gt;&gt;勾选硬盘和Redirect specific folders,并点击Configure选择要共享的文件夹 4.保存即可]]></content>
      <tags>
        <tag>jumpDesktop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http常见status]]></title>
    <url>%2F2018%2F08%2F30%2Fhttp%E5%B8%B8%E8%A7%81status%2F</url>
    <content type="text"><![CDATA[HTTP Status http常见status 200,OK: 用户请求成功，如查询数据成功返回。 400,错误的请求： URL匹配上Controller，但方法参数匹配错误，旧货跑出错误 404,NOT Found: 用户发出的请求针对的资源不存在。 405,用户来访问本页面的HTTP Method不被允许： 比如以GET请求方式请求了以@PostMapping限定请求方式的的Controller方法。 406,表示无法使用请求的内容特性来响应请求的资源： 比如，请求后缀以html结尾，但同时请求的HTTP头中又包含了Accept:application/json。 500,服务器内部错误，无法完成请求： 通常是Controller抛出的异常。]]></content>
      <tags>
        <tag>http常见status</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jrebel]]></title>
    <url>%2F2018%2F07%2F01%2Fjrebel%2F</url>
    <content type="text"><![CDATA[用途 用途 IDEA安装jrebel插件，即可实现热部署，更改静态文件以及java文件，都不需要再耗费大量的时间重启了。 安装 安装JRebel插件 1.IDEA&gt;pluggings&gt;搜索jrebel插件直接安装，安装完重启IDEA即可 2.下载反向代理，激活jrebel: https://github.com/ilanyu/ReverseProxy/releases/latest 3.运行反向代理软件，打开IDEA中JRebel的激活界面，在License Server处填写云翔反向代 理的机器ip，格式为：http://10.200.55.11:8888/GUID。 其中端口为8888，GUID为随机码，网上生成的： https://www.guidgenerator.com/online-guid-generator.aspx 4.激活完成后改为offline模式 地址示例：http://10.200.55.11:8888/7c06a95e-64fb-462f-9b69-edf4ad5a7ca2 其他问题 其他问题 1.tomcat的On update action 改为update classes and resources 2.如果出现内存溢出，VM options添加参数： -server -XX:PermSize=256M -XX:MaxPermSize=512m -Dfile.encoding=UTF-8 -Djava.awt.headless=true -Djava.awt.headless=true是系统缺少了显示设备、键盘或鼠标的设置参数，不是内存参数配置。在此配置只是不让代码在运行时在dock栏显示一个小窗口而已。 参考链接 参考链接 https://www.cnblogs.com/wang1024/p/7211194.html]]></content>
      <tags>
        <tag>jrebel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud-Zuul]]></title>
    <url>%2F2018%2F06%2F24%2FSpringCloud-Zuul%2F</url>
    <content type="text"><![CDATA[Zuul简介 zuul简介 Zuul的主要功能是路由转发和过滤器。路由功能是微服务的一部分，比如／api/user转发到到user服务，/api/shop转发到到shop服务。zuul默认和Ribbon结合实现了负载均衡的功能。 Zuul使用zuul转发功能 创建一个工程并添加依赖： &lt;!--web--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--zuul--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt; &lt;/dependency&gt; 启动类添加注解 @SpringBootApplication @EnableEurekaClient @EnableZuulProxy public class ZuulApplication { public static void main(String[] args) { SpringApplication.run(ZuulApplication.class, args); } } application.yml配置文件 spring: application: name: service-zuul eureka: client: service-url: defaultZone: http://172.96.251.101:8761/eureka server: port: 8085 zuul: routes: api-a: path: /api-a/** serviceId: service-ribbon api-b: path: /api-b/** serviceId: service-feign #请求示例 #http://localhost:8085/api-a/product/list?productId=11 #filter过滤后的请求示例 ##http://localhost:8085/api-b/product/list?productId=11&amp;token=1111 zuul过滤器功能 过滤功能 1.创建MyZuulFilter继承ZuulFilter package com.ux.zuul.filter; import com.netflix.zuul.ZuulFilter; import com.netflix.zuul.context.RequestContext; import com.netflix.zuul.exception.ZuulException; import lombok.extern.slf4j.Slf4j; import org.springframework.stereotype.Component; import javax.servlet.http.HttpServletRequest; @Slf4j @Component public class MyZuulFilter extends ZuulFilter { @Override public String filterType() { return &quot;pre&quot;; } @Override public int filterOrder() { return 0; } @Override public boolean shouldFilter() { return true; } @Override public Object run() throws ZuulException { RequestContext ctx = RequestContext.getCurrentContext(); HttpServletRequest request = ctx.getRequest(); log.info(String.format(&quot;%s &gt;&gt;&gt; %s&quot;, request.getMethod(), request.getRequestURL().toString())); Object accessToken = request.getParameter(&quot;token&quot;); if (accessToken == null) { log.warn(&quot;token参数为空~~&quot;); ctx.setSendZuulResponse(false); ctx.setResponseStatusCode(401); try { ctx.getResponse().getWriter().write(&quot;token is required~~~~~&quot;); } catch (Exception e) { } return null; } log.info(&quot;成功~~&quot;); return null; } } 2.此时访问#filter过滤后的请求示例 ##http://localhost:8085/api-b/product/list?productId=11&amp;token=1111 如果token为空（http://localhost:8085/api-b/product/list?productId=11）,会提示“token参数为空~~“ 3.filterType：返回一个字符串代表过滤器的类型，在zuul中定义了四种不同生命周期的过滤器类型，具体如下： pre：路由之前 routing：路由之时 post： 路由之后 error：发送错误调用 filterOrder：过滤的顺序 shouldFilter：这里可以写逻辑判断，是否要过滤，本文true,永远过滤。 run：过滤器的具体逻辑。可用很复杂，包括查sql，nosql去判断该请求到底有没有权限访问。 小结 小结 1.配置文件中配置转发规则&gt;&gt;&gt;用户请求后根据转发规则访问不同服务 2.zuul不仅只是路由，并且还能过滤，做一些安全验证，通过创建MyZuulFilter继承ZuulFilter并重写其中的方法，实现过滤规则，增加安全系数。]]></content>
      <tags>
        <tag>SpringCloud-Zuul</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud-Hystrix]]></title>
    <url>%2F2018%2F06%2F07%2FSpringCloud-Hystrix%2F</url>
    <content type="text"><![CDATA[Hystrix简介 Hystrix简介 在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用（RPC），在Spring Cloud可以用RestTemplate+Ribbon和Feign来调用。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。 为了解决这个问题，业界提出了断路器模型。 Hystrix使用在Feign中使用Hystrix1：Feign工程中pom.xml中加入Hystrix依赖（feign工程参见《SpringCloud-feign》文章）： &lt;!--hystrix断路器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--hystrix dashboard--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt; &lt;/dependency&gt; 2.Feign是自带断路器的，它没有默认打开。需要在配置文件中配置打开它 spring: application: name: service-feign eureka: client: service-url: defaultZone: http://172.96.251.101:8761/eureka server: port: 8083 feign: hystrix: enabled: true management: server: servlet: context-path: / 3：启动类上添加@EnableHystrix注解 @SpringBootApplication @EnableEurekaClient @EnableFeignClients @EnableHystrixDashboard @EnableHystrix public class FeignApplication { public static void main(String[] args) { SpringApplication.run(FeignApplication.class, args); } 4：创建productServiceClientHystric.java实现ProductServiceClient接口（我的feign工程中有这个接口） package com.ux.feign.serviceClient; import com.ux.feign.pojo.Product; import lombok.extern.slf4j.Slf4j; import org.springframework.stereotype.Component; @Component @Slf4j public class productServiceClientHystric implements ProductServiceClient { @Override public Product plist(String productId) { Product product = new Product(); product.setProductName(&quot;访问出错了~~&quot;); log.info(&quot;~~~~~访问出错了，断路器起作用了~~~~~~~~&quot;); return product; } } 5：ProductServiceClient接口添加fallback属性 package com.ux.feign.serviceClient; import com.ux.feign.pojo.Product; import org.springframework.cloud.openfeign.FeignClient; import org.springframework.stereotype.Service; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestParam; @FeignClient(name = &quot;WXPROJECT&quot;,fallback = productServiceClientHystric.class) @Service public interface ProductServiceClient { @GetMapping(&quot;/product/productInfo&quot;) Product plist(@RequestParam(&quot;productId&quot;) String productId); } 6.启动改造后的feign工程，不启动WXPROJECT服务，此时访问，会提示在productServiceClientHystric中返回的信息： product.setProductName(&quot;访问出错了~~&quot;);即：访问出错了~~ 7：Hystrix Dashboard (断路器：Hystrix 仪表盘) 1.pom.xml中已经添加 &lt;!--hystrix dashboard--&gt;依赖 2.启动类添加注解@EnableHystrixDashboard 两步即可 8：访问http://localhost:8083/hystrix 1.http://localhost:8083/hystrix.stream 2.title填写:feignClient 3.点击monitor stream 4.进入下一个界面访问http://localhost:8083/product/list?productId=11 5.正常情况下应该出现分析数据，但是springboot2.0下可能不出现，解决办法如下： 启动类下添加getServlet()方法并以bean方式注入即可： @SpringBootApplication @EnableEurekaClient @EnableFeignClients @EnableHystrixDashboard @EnableHystrix public class FeignApplication { public static void main(String[] args) { SpringApplication.run(FeignApplication.class, args); } /** * hystrix-dashboard不显示解决方法 * * @return */ @Bean public ServletRegistrationBean getServlet() { HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet(); ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet); registrationBean.setLoadOnStartup(1); registrationBean.addUrlMappings(&quot;/hystrix.stream&quot;); registrationBean.setName(&quot;HystrixMetricsStreamServlet&quot;); return registrationBean; } /*** * http://localhost:8083/hystrix * * http://localhost:8083/hystrix.stream * feignClient * 1000 * */ } 小结 小结 访问feign工程，feign抵用远程服务，但是远程服务挂了怎么办？此时可以通过断路器Hystrix返回一个信息，说明这个服务挂掉了。]]></content>
      <tags>
        <tag>SpringCloud-Hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud-feign]]></title>
    <url>%2F2018%2F06%2F07%2FSpringCloud-feign%2F</url>
    <content type="text"><![CDATA[Feign概述 feign简述 Feign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单; Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果。 Feign使用 创建工程 1.IDEA下通过Spring Initializr&gt;&gt;Cloud Discovery&gt;&gt;Eureka Discovery创建一个工程 2.创建好的工程pom.xml中默认是没有web依赖和feign依赖的，添加依赖即可： &lt;!--web--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--feign--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; 3.后续可能用到SLF4J以及lombok,所以顺便添加lombok依赖： &lt;!--Slf4j/不写getter/setter的插件--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; 4.配置文件application.yml(向http://172.96.251.101:8761/eureka注册服务) spring: application: name: service-feign eureka: client: service-url: defaultZone: http://172.96.251.101:8761/eureka server: port: 8083 management: server: servlet: context-path: / 5.SpringBoot启动类上添加Feign注解，因为是一个Eureka客户端，所以也会添加EurekaClient注解： @SpringBootApplication @EnableEurekaClient @EnableFeignClients public class FeignApplication { public static void main(String[] args) { SpringApplication.run(FeignApplication.class, args); } 6.创建包erviceClient，包中创建接口ProductServiceClient.java，作为调用远程服务的service接口： package com.ux.feign.serviceClient; import com.ux.feign.pojo.Product; import org.springframework.cloud.openfeign.FeignClient; import org.springframework.stereotype.Service; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestParam; @FeignClient(name = &quot;WXPROJECT&quot;) @Service public interface ProductServiceClient { @GetMapping(&quot;/product/productInfo&quot;) Product plist(@RequestParam(&quot;productId&quot;) String productId); } **注意：** ProductServiceClient接口中是访问另一个服务名为WXPROJECT的应用获取productInfo的信息的方法（plist），传递参数为productId，数据返回结果类型为Product，属性如下： @Data//lombok public class Product { private String productId; private String productName; private BigDecimal productPrice; private Integer productStock; private String productDescription; private String productIcon; private String productStatus; private String categoryType; private Date createTime; private Date updateTime; } 7.创建实体类Product，属性同上。 8.创建Service类：ProduceService.java，起作用是调用ProductServiceClient接口中的方法。 package com.ux.feign.service; import com.ux.feign.pojo.Product; import com.ux.feign.serviceClient.ProductServiceClient; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestParam; @Service public class ProduceService { @Autowired ProductServiceClient productServiceClient; @GetMapping(&quot;/plist&quot;) public Product plist(@RequestParam(&quot;productId&quot;) String productId) { return productServiceClient.plist(productId); } } 9.创建Controller： package com.ux.feign.controller; import com.ux.feign.pojo.Product; import com.ux.feign.service.ProduceService; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; @RestController @Slf4j public class ProductController { @Autowired ProduceService produceService; //http://localhost:8083/product/list?productId=11 @RequestMapping(&quot;/product/list&quot;) public Product list(@RequestParam(&quot;productId&quot;) String productId) { Product result = produceService.plist(productId); log.info(&quot;~~~feign实现服务间的调用result={}&quot;, result); return result; } } 小结 小结 上面的工程总结下来就是： 通过使用Feign，来调用远程服务中的product/productInfo方法（这一步通过ProductServiceClient接口来做），而后在工程中想要获取远程productInfo，只需要调用ProductServiceClient中对应的方法即可。 1.ProductServiceClient接口&gt;&gt;&gt;调用远程服务 2.ProduceService调用ProductServiceClient接口 3.ProductController调用ProduceService 说明 1.工程使用Intellij IDEA 2017.02创建 2.SpringBoot版本为2.0]]></content>
      <tags>
        <tag>SpringCloud-feign</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud-rest+ribbon]]></title>
    <url>%2F2018%2F06%2F07%2FSpringCloud-rest-ribbon%2F</url>
    <content type="text"><![CDATA[Ribbon简介 ribbon 在微服务架构中，业务都会被拆分成一个独立的服务，服务与服务的通讯是基于http restful的。Spring cloud有两种服务调用方式，一种是ribbon+restTemplate，另一种是feign。在这一篇文章首先讲解下基于ribbon+rest; ribbon是一个负载均衡客户端，可以很好的控制htt和tcp的一些行为。Feign默认集成了ribbon. Ribbon使用 创建工程 1.Cloud Discovery&gt;&gt;Eureka Discovery工程 2.pom.xml中添加web依赖： &lt;!--web--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--不写getter/setter的插件--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; 3.启动类添加@EnableEurekaClient注解： @SpringBootApplication @EnableEurekaClient public class ResttemplateribbonApplication { public static void main(String[] args) { SpringApplication.run(ResttemplateribbonApplication.class, args); } } 4.application.yml配置文件配置服务注册地址： eureka: client: service-url: defaultZone: http://172.96.251.101:8761/eureka spring: application: name: service-Ribbon #service-restTemplate-Ribbon ##更改ribbon默认的负载均衡方式（默认是轮循，改为随机） ##WXPROJECT：目标应用的名称 #WXPROJECT: # ribbon: # NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule server: port: 8084 5.依然调用WXPROJECT这个服务的productInfo方法，所以创建实体类Product.java @Data public class Product { private String productId; private String productName; private BigDecimal productPrice; private Integer productStock; private String productDescription; private String productIcon; private String productStatus; private String categoryType; private Date createTime; private Date updateTime; } 6.创建RestTemplateConfig.java package com.ux.resttemplateribbon.restTemplateConfig; import org.springframework.cloud.client.loadbalancer.LoadBalanced; import org.springframework.context.annotation.Bean; import org.springframework.stereotype.Component; import org.springframework.web.client.RestTemplate; @Component public class RestTemplateConfig { @Bean @LoadBalanced public RestTemplate restTemplate() { return new RestTemplate(); } } 7.利用RestTeamlate+LoadBalanced注解实现对远程服务的调用： package com.ux.resttemplateribbon.controller; import com.ux.resttemplateribbon.pojo.Product; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.client.RestTemplate; /** * 利用RestTeamlate+LoadBalanced注解实现对远程服务的调用： * **************@Bean * **************@LoadBalanced public RestTemplate restTemplate() { * **************return new RestTemplate(); * **************} * &lt;p&gt; * &lt;p&gt; * 本质依然是RestTeamlate+loadBalancerClient */ @Slf4j @RestController @RequestMapping(&quot;/client/product&quot;) public class ProductController { @Autowired RestTemplate restTemplate; @GetMapping(&quot;/info&quot;) public Product info(@RequestParam(&quot;productId&quot;) String productId) { Product result = restTemplate.getForObject(&quot;http://WXPROJECT/product/productInfo?productId=&quot; + productId, Product.class); log.info(&quot;~~~~~Product={}&quot;, result); return result; } } 小结 小结 利用RestTeamlate+LoadBalanced注解实现对远程服务的调用本质依然是RestTeamlate+loadBalancerClient，RestTeamlate+loadBalancerClient调用方式如下，不需要单独写RestTemplateConfig.java了： package com.ux.resttemplateribbon.controller; import com.ux.resttemplateribbon.pojo.Product; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.cloud.client.ServiceInstance; import org.springframework.cloud.client.loadbalancer.LoadBalancerClient; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.client.RestTemplate; /** * restTeamlate+loadBalancerClient(根据服务名称获取host和端口构造成url)实现服务之间的请求调用 */ @Slf4j @RestController @RequestMapping(&quot;/client/product&quot;) public class ProductController2 { @Autowired LoadBalancerClient loadBalancerClient; @GetMapping(&quot;/info2&quot;) public Product info(@RequestParam(&quot;productId&quot;) String productId) { RestTemplate restTemplate = new RestTemplate(); //根据服务名称获取服务信息 ServiceInstance instance = loadBalancerClient.choose(&quot;WXPROJECT&quot;); //获取服务端口 Integer port = instance.getPort(); //获取服务host String host = instance.getHost(); //构造（拼接）url 形式为：http://192.168.1.102:8081/product/productInfo?productId=11 String url = String.format(&quot;http://%s:%s&quot;, host, port + &quot;/product/productInfo?productId=&quot; + productId); Product result = restTemplate.getForObject(url, Product.class); //Product result = restTemplate.getForObject(&quot;http://WXPROJECT/product/productInfo?productId=&quot;+productId, Product.class); log.info(&quot;~~~~~Product={}&quot;, url); return result; } }]]></content>
      <tags>
        <tag>SpringCloud-ribbon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud-Eureka]]></title>
    <url>%2F2018%2F05%2F29%2FSpringCloud-Eureka%2F</url>
    <content type="text"><![CDATA[Eureka概述 eureka是干什么的 作用：微服务中，负责服务（组件）的注册与发现，是一个“大管家” 由来：由SpringCloud基于Netflix Eureka做了二次封装 Eureka组成： 由Eureka Server 注册中心和 Eureka Client 服务注册 这两个主键组成 Eureka server端 参考链接 https://blog.csdn.net/forezp/article/details/69696915 如何创建eureka server端 1. IDEA下，new project&gt;&gt;Spring Intializr&gt;&gt;Cloud Discovery&gt;&gt;勾选Eureka Server 2. 启动类使用@EnableEurekaServer注解： @SpringBootApplication @EnableEurekaServer public class EurekaserverApplication { public static void main(String[] args) { SpringApplication.run(EurekaserverApplication.class, args); } } 3.application.yml配置文件配置相关信息： #server: # port: 8761 eureka: client: service-url: defaultZone: http://localhost:8761/eureka register-with-eureka: false #instance: #hostname: 192.168.1.102 #server: #enable-self-preservation: false spring: application: name: eurekaserver1 management: server: servlet: context-path: / Eureka client端 如何创建eureka client端 1. IDEA下，new project&gt;&gt;Spring Intializr&gt;&gt;Cloud Discovery&gt;&gt;勾选Eureka Discovery(略微不同) 2. 方式创建的client端可能没有引入web组件，需要手动添加，否则启动失败 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; 3. 启动类使用@EnableEurekaClient注解： @SpringBootApplication @EnableEurekaClient public class EurekaclientApplication { public static void main(String[] args) { SpringApplication.run(EurekaclientApplication.class, args); } } 4. application.yml配置文件配置相关信息： eureka: client: service-url: defaultZone: http://localhost:8761/eureka/ #instance: #hostname: www.baidu.com spring: application: name: eurekaclient01 server: port: 8763 启动失败,解决参考链接 https://blog.csdn.net/ngl272/article/details/71087734 server和client端都配置正确后，访问8761端口会看到client的Instances已经被注册到server端Eureka实现高可用集群 什么是高可用 高可用：即“高可用性”（High Availability），通常来描述一个系统经过专门的设计，从而减少停工时间，而保持其服务的高度可用性。 如何实现高可用集群 1. 先进行多个服务端相互注册，如eurekaserver1和eurekaserver2相互注册 2. 再进行client对多个服务端同时注册 这样可以有效防止服务端的不稳定因素导致整个应用挂掉。 1. 先进行多个服务端相互注册（代码演示）模拟两个server端： IDEA中启动两个server端的服务（实例）即可（再复制一份服务启动配置即可，并设置不同端口） eurekaserver1在eurekaserver2进行注册： eurekaserver1的yml文件配置信息 eureka: client: service-url: defaultZone: http://eureka2:8762/eureka register-with-eureka: false #instance: #hostname: 192.168.1.102 #server: #enable-self-preservation: false spring: application: name: eurekaserver1 management: server: servlet: context-path: / eurekaserver2在eurekaserver1进行注册： eurekaserver2的yml文件配置信息 eureka: client: service-url: defaultZone: http://eureka1:8761/eureka register-with-eureka: false #instance: #hostname: 192.168.1.102 #server: #enable-self-preservation: false spring: application: name: eurekaserver2 management: server: servlet: context-path: / client端对多个server端进行同时注册（这里演示的是两个） 配置两个server的service-url，并用逗号分隔即可 service-url: defaultZone: http://eureka1:8761/eureka/,http://eureka2:8762/eureka/ 效果 效果 注释： 说明 eurekaserver1的端口为：8761 ip为：eureka1 application name为：eurekaserver1 ----------------------------------- eurekaserver2的端口为：8762 ip为：eureka2 application name为：eurekaserver2 其中，ip为：eureka1和eureka2是在电脑的host文件中做的伪域名： 127.0.0.1 eureka1 127.0.0.1 eureka2 提别提醒： 很重要的信息 如果defaultZone: http://eureka1:8761/eureka中都填127.0.0.1或者localhost，则server端相互注册会失败！！ 版本： &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Finchley.BUILD-SNAPSHOT&lt;/spring-cloud.version&gt; &lt;/properties&gt; 多个server端互相注册失败，参考链接 https://blog.csdn.net/a60782885/article/details/70146615 代码 代码链接 https://git.coding.net/uxaw/springCloud.git]]></content>
      <tags>
        <tag>SpringCloud-Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud]]></title>
    <url>%2F2018%2F05%2F29%2FSpringCloud%2F</url>
    <content type="text"><![CDATA[springCloud中的几个主要组件 业务场景以及底层原理 https://blog.csdn.net/forezp/article/details/83999882]]></content>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信点餐系统总结]]></title>
    <url>%2F2018%2F05%2F27%2F%E5%BE%AE%E4%BF%A1%E7%82%B9%E9%A4%90%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[springboot部署 jar方式部署 直接安装运行jar即可 war方式部署到tomcat war部署到tomcat的坑: 1.修改启动类，继承SpringBootServletInitializer并重写configure方法： package com.imux.wxsell; import org.mybatis.spring.annotation.MapperScan; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.builder.SpringApplicationBuilder; import org.springframework.boot.web.servlet.support.SpringBootServletInitializer; //没有数据源时添加 exclude = {DataSourceAutoConfiguration.class} @SpringBootApplication //@MapperScan(basePackages = &quot;com.imux.xwsell.dao&quot;)//mybatis接口包 public class WxsellApplication extends SpringBootServletInitializer { /**重写configure方法--外部tomcat部署*/ @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) { return application.sources(WxsellApplication.class); } public static void main(String[] args) { SpringApplication.run(WxsellApplication.class, args); } } -------------------------------------------------------------------------------------------------- 2.修改pom.xml文件 &lt;packaging&gt;jar&lt;/packaging&gt; 改为： &lt;packaging&gt;war&lt;/packaging&gt; -------------------------------------------------------------------------------------------------- 3.屏蔽内嵌tomcat &lt;!--去除内嵌tomcat--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; -------------------------------------------------------------------------------------------------- 4.由于本项目中使用了websocket,并且在WebSocketConfig中将ServerEndpointExporter指定给Spring管理，当使用外部tomcat容器时，部署后ServerEndpoint是需要Tomcat直接管理才能生效的，所以会报错误信息：&lt;&lt;&lt;Failed to register @ServerEndpoint class&gt;&gt;&gt;,解决方法： 将：WebSocketConfig.java类中的内容全部注释掉即可： /* @Component public class WebSocketConfig { @Bean public ServerEndpointExporter serverEndpointExporter() { return new ServerEndpointExporter(); } } */ 参考文档 springboot官方文档： https://docs.spring.io/spring-boot/docs/2.0.1.RELEASE/reference/html/howto-traditional-deployment.html#howto-create-a-deployable-war-file https://blog.csdn.net/qq_21144985/article/details/72921104]]></content>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[restful]]></title>
    <url>%2F2018%2F05%2F26%2Frestful%2F</url>
    <content type="text"><![CDATA[restful规范 规范简述 GET -&gt; 查询操作 POST -&gt; 添加/修改操作 PUT -&gt; 修改操作 DELETE -&gt;删除操作 REST https://blog.csdn.net/qq_29115715/article/details/80090403]]></content>
      <tags>
        <tag>restful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis]]></title>
    <url>%2F2018%2F05%2F24%2Fredis%2F</url>
    <content type="text"><![CDATA[redis可以承载每秒10W+的并发数。 官网 https://redis.io/ 中文网 http://www.redis.cn/ 两个需要用到的命令 1.SETNX(一定要去看看链接介绍) http://www.redis.cn/commands/setnx.html 2.GETSET(一定要去看看链接介绍) http://www.redis.cn/commands/getset.html reids分布式session的应用redis分布式锁的应用 https://blog.csdn.net/forezp/article/details/68957681 redis缓存的应用]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring]]></title>
    <url>%2F2018%2F05%2F23%2Fspring%2F</url>
    <content type="text"><![CDATA[spring注解 Spring的20+种常用注解 https://mp.weixin.qq.com/s/b8bKuoaJAgGdFx9nTaFpgg spring4 RestController @Controller @ResponseBody 两个注解可以替换成 @RestController RequestMapping可以同时配置两个请求路径： @RequestMapping(value = {&quot;/hello&quot;,&quot;hi&quot;}) 指定请求类型以及获取请求参数的另一种写法 @RestController public class Test1 { /* * http://localhost:8080/boot/hello/?id=3 * required = false 参数时候为必须；defaultValue = &quot;0&quot; */ @RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.POST) public String hello(@RequestParam(value = &quot;id&quot;, required = false, defaultValue = &quot;0&quot;) Integer myid) { return &quot;id= &quot; + myid; } //http://localhost:8080/boot/hello2/9 @RequestMapping(value = &quot;/hello2/{id}&quot;, method = RequestMethod.POST) public String hello2(@PathVariable(value = &quot;id&quot;, required = false) Integer myid) { return &quot;id= &quot; + myid; } } RequestParam与PathVariable RequestParam：获取请求参数 PathVariable：获取路径变量 请求注解 @RequestMapping *******分割线******** @GetMapping @PostMapping @PutMapping @DeleteMapping RequestMapping注解与下面几种的不同就是：下面几种注解直接指定了请求类型，是组合注解， 如@GetMapping相当于@RequestMapping(method = RequestMethod.POST) IOC 为什么用IOC 1.对象创建统一托管 2.规范的声明周期管理 3.灵活的依赖注入 4.一直的获取对象 Spring IOC注入方式和场景 声明式事务 声明式事务-配置 声明式事务-使用方式 声明式事务-事务回滚 不当的try-catch可能使事务不能生效，如发生了异常但是做了try-catch,可能使一部分执行成功，一部分执行失败，违背事务初衷。]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lombok参考手册]]></title>
    <url>%2F2018%2F05%2F23%2FLombok%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[Lombok参考手册Lombok是一个可以通过简单的注解形式来帮助我们简化消除一些必须有但显得臃肿的Java代码的工具，通过使用对应的注解，可以在编译源码的时候生成对应的方法。官方地址：https://projectlombok.org/，github项目地址：https://github.com/rzwitserloot/lombok。 lombok常用注解使用lombok注解需要在项目中引用lombok jar包。 @Data：注解在类上；提供类所有属性的getting和setting方法，此外还提供了equals、canEqual、hashCode 、toString 方法 @Setter：注解在属性上；为属性提供setting方法 @Getter：注解在属性上；为属性提供getting方法 @Slf4j：注解在类上；为类提供一个属性名为log 的slf4j日志对象 @NoArgsConstructor：注解在类上：为类提供一个无参的构造方法 @AllArgsConstructor ：注解在类上；为类提供一个全参的构造方法 @NonNull：注解在参数上；如果该参数为null 会throw new NullPointerException(参数名); @Cleanup：注释在引用变量前，自动回收资源 默认调用close方法 @SneakyThrows ：注解在方法上，为方法抛出指定异常 样例如下： 使用lombok注解的java代码： 1234567891011121314151617181920212223242526272829303132333435import lombok.*;import lombok.extern.slf4j.Slf4j;import java.io.ByteArrayInputStream;import java.io.*;import java.util.ArrayList;@Data@Slf4j@NoArgsConstructor@AllArgsConstructorpublic class Something &#123; private String name; private final String country; private final Object lockObj = new Object(); public void sayHello(@NonNull String target) &#123; String content = String.format("hello,%s", target); System.out.println(content); log.info(content); &#125; public void addBalabala() &#123; val list = new ArrayList&lt;String&gt;(); list.add("haha"); System.out.println(list.size()); &#125; @SneakyThrows(IOException.class) public void closeBalabala() &#123; @Cleanup InputStream is = new ByteArrayInputStream("hello world".getBytes()); System.out.println(is.available()); &#125;&#125; 等效于下面的这段java代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import java.beans.ConstructorProperties;import java.io.ByteArrayInputStream;import java.io.IOException;import java.util.ArrayList;import java.util.Collections;import lombok.NonNull;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class Something &#123; private static final Logger log = LoggerFactory.getLogger(Something.class); private String name; private final String country; private final Object lockObj = new Object(); public void sayHello(@NonNull String target) &#123; if(target == null) &#123; throw new NullPointerException("target"); &#125; else &#123; String content = String.format("hello,%s", new Object[]&#123;target&#125;); System.out.println(content); log.info(content); &#125; &#125; public void addBalabala() &#123; ArrayList list = new ArrayList(); list.add("haha"); System.out.println(list.size()); &#125; public void closeBalabala() &#123; try &#123; ByteArrayInputStream bis = new ByteArrayInputStream("hello world".getBytes()); try &#123; System.out.println(bis.available()); &#125; finally &#123; if(Collections.singletonList(bis).get(0) != null) &#123; bis.close(); &#125; &#125; &#125; catch (IOException e) &#123; throw e; &#125; &#125; public String getName() &#123; return this.name; &#125; public String getCountry() &#123; return this.country; &#125; public Object getLockObj() &#123; return this.lockObj; &#125; public void setName(String name) &#123; this.name = name; &#125; public boolean equals(Object o) &#123; //... &#125; protected boolean canEqual(Object other) &#123; return other instanceof Something; &#125; public int hashCode() &#123; //... &#125; public String toString() &#123; //... &#125; @ConstructorProperties(&#123;"name", "country"&#125;) public Something(String name, String country) &#123; this.name = name; this.country = country; &#125;&#125; 与IDE集成与Eclipse集成第一步：下载lombok.jar 安装包 下载地址：http://projectlombok.org/ 第二步： 与Eclipse集成 1、 将 lombok.jar 复制到eclipse.ini所在的文件夹目录下2、 打开 eclipse.ini ，在最后面插入以下两行并保存： -Xbootclasspath/a:lombok.jar -javaagent:lombok.jar3、 重启eclipse 。 与IntelliJ IDEA集成第一步：安装lombok插件 方式一，通过Plugins安装 打开IDEA，Settings -&gt; Plugin，在搜索框中输入lombok plugin ，根据提示安装，安装后重启即可。 方式二，下载安装包安装 下载lombok插件，下载地址为：https://github.com/mplushnikov/lombok-intellij-plugin/releases ; Plugin -&gt; Install plugin from disk... ，选择下载的zip包安装，安装后重启即可; 第二步：Enable annotation processing Settings -&gt; Build,Exectution,Deployment -&gt; Compiler -&gt; Annotation Processors ，勾选Enable annotation processing ，点击apply 保存，重启后即可使用lombok 注解编码了。]]></content>
      <tags>
        <tag>lombok</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ab压测模拟高并发]]></title>
    <url>%2F2018%2F05%2F22%2Fab%E5%8E%8B%E6%B5%8B%E6%A8%A1%E6%8B%9F%E9%AB%98%E5%B9%B6%E5%8F%91%2F</url>
    <content type="text"><![CDATA[用apache ab压测模拟高并发 工具下载安装 windows下安装apache,执行压测命令需进入bin目录下再执行压测命令： cd C:\mysoft\Apache2.2\bin macOS下直接执行压测命令即可（macOS自带apache） 命令 1.ab -n 100 -c 100 http://www.baidu.com -n 100 :发出100个请求 -c 100 :模拟100个并发 相当于100个人同时访问http://www.baidu.com 2.ab -t 60 -c 100 http://www.baidu.com -t 60 :60秒 -c 100 :100个并发 在60秒内不停发请求，一次100个请求 https://www.jianshu.com/p/166a4ea8aade]]></content>
      <tags>
        <tag>ab压测模拟高并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot与mybatis整合]]></title>
    <url>%2F2018%2F05%2F22%2Fspringboot%E4%B8%8Emybatis%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[SpringBoot与mybatis整合 maven引入mybatis包（第1步-总） &lt;!--mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; springboot启动类中设置扫描包位置（第2步-总） //没有数据源时添加 exclude = {DataSourceAutoConfiguration.class} @SpringBootApplication @MapperScan(basePackages = &quot;com.imux.xwsell.dao&quot;) public class WxsellApplication { public static void main(String[] args) { SpringApplication.run(WxsellApplication.class, args); } } xml方式 xml方式 dao中写接口,与传统ssm无异（第3步-xml） resources/mapper下对应的xml文件中，指明namespace(即对应的dao接口)（第4步-xml） application.yml文件中配置mapper.xml文件夹位置（即resource/mapper文件夹的位置），如下：（第5步-xml） ##mybatis xml方式mapper.xml文件夹位置配置 #mybatis: # mapper-locations: classpath:mapper/*.xml 纯注解方式 纯注解方式 dao中写接口，每一个接口方法上写sql语句，并用对应的注解修饰如：（第3步-纯注解） @Insert(insert into user_info(user_name) vlues (#userName)) int insertByMap(Map map); @Select @Result @Update 等… 由上面两种方式可以看出，xml方式一共需要5步，纯注解方式需要3步。]]></content>
      <tags>
        <tag>springboot与mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[websocket]]></title>
    <url>%2F2018%2F05%2F22%2Fwebsocket%2F</url>
    <content type="text"><![CDATA[待续]]></content>
      <tags>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式与集群]]></title>
    <url>%2F2018%2F05%2F21%2F%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E9%9B%86%E7%BE%A4%2F</url>
    <content type="text"><![CDATA[分布式概念描述 概念 旨在支持应用程序和服务的开发，可以利用物理架构由多个自治的处理元素，不共享主内存，但通过网络发送消息合作。——Leslie Lamport 分布式的三个特点与 多节点 消息通信 不共享内存 三个容易混淆的概念 分布式系统（distributed ststem） 集群（cluster） 分布式计算（distributed computing） 分布式系统是多节点的，集群也是多节点的，但是区别在于节点的功能 如：卖家端和卖家端是分布式的； 如果卖家端部署在对台服务器上，那么卖家端是集群； 简单说就是 功能不同是分布式，功能相同是集群。 分布式系统与集群的区别 区别 分布式系统强调的是不同的功能模块的节点； 集群是相同业务功能模块的节点； 分布式系统中的每个节点都可以做集群。 集群并不一定是分布式的。 水平扩展 集群 垂直扩展 分布式 session理论 广义session 会话控制： http协议是无状态的，对于同一个url请求并没有上下文关系，当用户完成登录后，就要有一个机制保存用户的登录状态和信息，在后续的请求中，能够验证用户的身份和检查用户信息。 可以理解为一种保存key-value的机制： session机制中的关键点: 1.如何设置和获取key 2.如何保存和正确获取多赢的value 从key的方面看： 会话会有两种比较常规的方式，sessionId和token; sessionId: 客户端请求服务端时，服务端通过setCookie就可以在http头里面设置sessionId这个key和对应的value的值，而客户端的cookie会将它保存住，在后续的请求中，会自动带上。 token: 使用token时，需要手动在http head头里或者url里面设置token这个字段，服务器收到请求后，再从head头里或者url取出token进行验证（对安全要求严格是，会配合签名和token一起使用）。 无论是session还是token,它们都是全局唯一的，一个用户一个标识。它的本质就是一个key,key对应的value就是用户的信息。无论key还是value,一方没有保持住，我们就无法分别用户身份、获取用户信息。 处理分布式session问题 处理分布式session问题 session保持不住： 如浏览器禁用cookie，分布式系统中session问题–多个应用服务器时，持有的用户session没有同步多个服务器。 此时可以用一个专门的服务去保存用户的session信息，其它服务需要用户的session信息时，都通过这个专门的服务去获取。这个服务通常是用redis集群或者主从复制去做的。当然，微小型项目或者开发测试时，单机版也可以。 登录时设置好key保存用户信息，登出时让value失效即可。 chrome浏览器下查看cookie： command+option+i： 上方Application&gt;左侧Cookies 狭义session httpsession]]></content>
      <tags>
        <tag>分布式与集群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[freemarker]]></title>
    <url>%2F2018%2F05%2F17%2Ffreemarker%2F</url>
    <content type="text"><![CDATA[待续]]></content>
      <tags>
        <tag>freemarker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http请求]]></title>
    <url>%2F2018%2F05%2F17%2Fhttp%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[post/get请求工具类 HttpRequest工具类 package com.code.util; import java.io.*; import java.net.URL; import java.net.URLConnection; import java.util.List; import java.util.Map; public class HttpRequest { /** * 向指定URL发送GET方法的 请求 * * @param url 发送请求的URL * @param param 请求参数，请求参数应该是name1=value1&amp;name2=value2的形式。 * @return URL所代表远程资源的响应 */ public static String sendGet(String url, String param) { String result = &quot;&quot;; BufferedReader in = null; try { String urlName = url + &quot;?&quot; + param; URL realUrl = new URL(urlName); // 打开和URL之间的连接 URLConnection conn = realUrl.openConnection(); // 设置通用的请求属性 conn.setRequestProperty(&quot;accept&quot;, &quot;*/*&quot;); conn.setRequestProperty(&quot;connection&quot;, &quot;Keep-Alive&quot;); conn.setRequestProperty(&quot;user-agent&quot;, &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&quot;); // 建立实际的连接 conn.connect(); // 获取所有响应头字段 Map&lt;String, List&lt;String&gt;&gt; map = conn.getHeaderFields(); // 遍历所有的响应头字段 for (String key : map.keySet()) { System.out.println(key + &quot;---&gt;&quot; + map.get(key)); } // 定义BufferedReader输入流来读取URL的响应 in = new BufferedReader( new InputStreamReader(conn.getInputStream(),&quot;UTF-8&quot;)); String line; while ((line = in.readLine()) != null) { result += line; } } catch (Exception e) { System.out.println(&quot;发送GET请求出现异常！&quot; + e); e.printStackTrace(); } // 使用finally块来关闭输入流 finally { try { if (in != null) { in.close(); } } catch (IOException ex) { ex.printStackTrace(); } } return result; } /** * 向指定URL发送POST方法的请求 * * @param url 发送请求的URL * @param param 请求参数，请求参数应该是name1=value1&amp;name2=value2的形式。 * @return URL所代表远程资源的响应 */ public static String sendPost(String url, String param) { PrintWriter out = null; BufferedReader in = null; String result = &quot;&quot;; try { URL realUrl = new URL(url); // 打开和URL之间的连接 URLConnection conn = realUrl.openConnection(); // 设置通用的请求属性 conn.setRequestProperty(&quot;accept&quot;, &quot;*/*&quot;); conn.setRequestProperty(&quot;connection&quot;, &quot;Keep-Alive&quot;); conn.setRequestProperty(&quot;user-agent&quot;, &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&quot;); // 发送POST请求必须设置如下两行 conn.setDoOutput(true); conn.setDoInput(true); // 获取URLConnection对象对应的输出流 out = new PrintWriter(conn.getOutputStream()); // 发送请求参数 out.print(param); // flush输出流的缓冲 out.flush(); // 定义BufferedReader输入流来读取URL的响应 in = new BufferedReader( new InputStreamReader(conn.getInputStream(),&quot;UTF-8&quot;)); String line; while ((line = in.readLine()) != null) { result += line; } } catch (Exception e) { System.out.println(&quot;发送POST请求出现异常！&quot; + e); e.printStackTrace(); } // 使用finally块来关闭输出流、输入流 finally { try { if (out != null) { out.close(); } if (in != null) { in.close(); } } catch (IOException ex) { ex.printStackTrace(); } } return result; } } 调用 调用方式（详情参考lib下http文件夹中的附件） //String loginParam = &quot;accessKey=test&amp;accessSecret=test&amp;clientId=clientId&amp;clientType=PC&quot;; String loginParam = &quot;accessKey=&quot; + accessKey + &quot;&amp;accessSecret=&quot; + accessSecret + &quot;&amp;clientId=&quot; + clientId + &quot;&amp;clientType=&quot; + clientType; //登陆接口： String loginUrl = &quot;https://open.wellsign.cn/dandanqian/api/index.php/Conv/User/login&quot;; //loginParam = &quot;accessKey=test&amp;accessSecret=test&amp;clientId=clientId&amp;clientType=PC&quot;; String loginSuccess = HttpRequest.sendPost(loginUrl, loginParam);]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos6下安装mysql5.7]]></title>
    <url>%2F2018%2F04%2F26%2Fcentos6%E4%B8%8B%E5%AE%89%E8%A3%85mysql5-7%2F</url>
    <content type="text"><![CDATA[下载 卸载系统自带的MySql 查看是否已经安装了mysql rpm -qa | grep mysql 普通删除模式 rpm -e mysql-libs-5.1.66-2.el6_3.x86_64 强力删除模式，如果使用上面命令删除时，提示有依赖的其它文件，则用该命令可以对其进行强力删除 rpm -e --nodeps mysql-libs-5.1.66-2.el6_3.x86_64 https://www.cnblogs.com/MIC2016/p/7117854.html 下载rpm安装包 https://dev.mysql.com/downloads/mysql/ 操作系统选red hat,否则没有rpm版本。 安装准备 将下载的tar安装包传输到centos中，命令格式如下： scp -P 22 source user@ip:/desition 解压tar文件 tar -xf mysql5.7.tar 得到下面几个rpm包： mysql-community-client-5.7.22-1.el6.x86_64.rpm mysql-community-common-5.7.22-1.el6.x86_64.rpm mysql-community-devel-5.7.22-1.el6.x86_64.rpm mysql-community-embedded-5.7.22-1.el6.x86_64.rpm mysql-community-embedded-devel-5.7.22-1.el6.x86_64.rpm mysql-community-libs-5.7.22-1.el6.x86_64.rpm mysql-community-libs-compat-5.7.22-1.el6.x86_64.rpm mysql-community-server-5.7.22-1.el6.x86_64.rpm mysql-community-test-5.7.22-1.el6.x86_64.rpm 安装 如果直接执行mysql-server： rpm -ivh mysql-community-server-5.7.22-1.el6.x86_64.rpm 会无法安装，并提示安装前需要先安装libs、common、以及namactl相关 需要先安装依赖： yum install numactl rpm -ivh mysql-community-common-5.7.22-1.el6.x86_64.rpm rpm -ivh mysql-community-libs-5.7.22-1.el6.x86_64.rpm rpm -ivh mysql-community-client-5.7.22-1.el6.x86_64.rpm 安装外依赖后再安装mysql-server: rpm -ivh mysql-community-server-5.7.22-1.el6.x86_64.rpm 初始化 mysqld --initialize --user=mysql 初始化后到/var/log/查看mysqld.log，找到默认密码： cat /var/log/mysqld.log 注册服务，开机自启数据库 安装完初始化后并不能直接使用service mysqld start命令启动数据库，可以使用完整路径启动数据库： /etc/rc.d/init.d/mysqld start 设置mysql开机启动 chkconfig mysqld on 修改mysqld执行权限 chmod 755 /etc/rc.d/init.d/mysqld 启动： service mysqld start http://www.ctohome.com/FuWuQi/aa/511.html ###如果初始密码无法使用，重置密码 重置方式 /etc/my.cnf下添加（有的Linux版本是/etc/mysql/mysql.conf.d/mysqld.cnf）： skip-grant-tables 保存后刷新配置： flush privileges; 此时mysql -u root -p直接回车就能登录数据库了 登录过后从新设置密码 update mysql.user set authentication_string=password(&apos;新密码&apos;) where user=&apos;root&apos;; 复原/etc/my.cnf 将/etc/my.cnf下的skip-grant-tables注释掉 表名不区分大小写配置 安装后如果在查询时表名区分大小写了，配置一下 /etc/my.cnf下的[mysqld]下加： #（设置查询表名不区分大小写） lower_case_table_names=1 https://www.cnblogs.com/MIC2016/p/7117854.html 远程连接设置 修改配置使数据库可以被远程连接 update user set host = &apos;%&apos; where user = &apos;root&apos; and host = &apos;localhost&apos;; flush privileges; 刷新配置命令 命令 flush privileges;]]></content>
      <tags>
        <tag>centos安装mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot]]></title>
    <url>%2F2018%2F04%2F24%2Fspringboot%2F</url>
    <content type="text"><![CDATA[命令小记 另一种部署jar方式： java -jar -Dserver.port=8090 wxsell.jar maven打包 mvn clean package -Dmaven.test.skip=true springboot多数据源 第二数据源 yml配置文件中： custom: datasource: names: ds1 ds1: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://121.196.221.4:3306:test username: 123 password: 123 service impl中相应的要使用第二数据源的方法中： @TargetDataSource(&quot;ds1&quot;) public void insert() { }]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM思维导图]]></title>
    <url>%2F2018%2F04%2F13%2FSSM%2F</url>
    <content type="text"><![CDATA[SSM思维导图 SSM思维导图 指示器 SpringMVC工作原理图 SpringMVC工作原理流程图]]></content>
      <tags>
        <tag>SSM思维导图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM思维导图]]></title>
    <url>%2F2018%2F04%2F12%2FJVM%2F</url>
    <content type="text"><![CDATA[图解 启动流程图]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试总结20180410]]></title>
    <url>%2F2018%2F04%2F10%2F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%9320180410%2F</url>
    <content type="text"><![CDATA[2018项目情况 项目介绍 JavaSE集合 集合概述 list与set的异同 hashtable与hashmap异同 以上三点可以从下图简要分析(集合总结2.png): map底层实现原理 JVM JVM JVM是Java Virtual Machine（Java虚拟机）的缩写， JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。 Java虚拟机包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆和一个存储方法域。 JVM屏蔽了与具体操作系统平台相关的信息，使Java程序只需生成在Java虚拟机上运行的目标代码（字节码）,就可以在多种平台上不加修改地运行。 JVM在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。 http://www.cnblogs.com/sunada2005/p/3577799.html JVM调优 JVM三大性能调优参数：-Xms –Xmx –Xss -Xms –Xmx是对堆的性能调优参数，一般两个设置是一样的， 如果不一样，当Heap不够用，会发生内存抖动。一般都调大这两个参数，并且两个大小一样。 -Xss是对每一个线程栈的性能调优参数,影响堆栈调用的深度 借助于示例理解： 对于JVM内存配置参数： -Xmx10240m -Xms10240m -Xmn5120m -XXSurvivorRatio=3 其最小内存值和Survivor区总大小分别是（） 10240m，2048m --------------------------------------解析---------------------------------------------------- -Xmx10240m：代表最大堆 -Xms10240m：代表最小堆(初始堆大小) -Xmn5120m： 代表新生代(Young Gen) -XXSurvivorRatio=3：代表Eden:Survivor = 3 根据Generation-Collection算法(目前大部分JVM采用的算法)，一般根据对象的生存周期将堆内存分为若干不同的区域， 一般情况将新生代分为Eden+两块Survivor； 计算Survivor大小， Eden:Survivor = 3，总大小为5120,3x+x+x=5120 x=1024 所以,2x=1024*2=2048,即Survivor区总大小是2048， -Xms初始堆大小,即最小内存值为10240m (ps:新生代大部分要回收，采用Copying算法，快！ 老年代 大部分不需要回收，采用Mark-Compact算法) JVM调优相关1.png https://www.nowcoder.com/questionTerminal/970cdaaa4a114cbf9fef82213a7dabca 垃圾回收 https://blog.csdn.net/aijiudu/article/details/72991993 多线程 线程和进程 1.进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同 2.进程中包含线程 3.举例： 开个QQ，开了一个进程；开了迅雷，开了一个进程。 在QQ的这个进程里，传输文字开一个线程、传输语音开了一个线程、弹出对话框又开了一个线程。 线程创建方式 1.继承Thread类 class MyThread extends Thread{ ...... @Override public void run(){ ...... } } MyThread mt = new MyThread();//创建线程 mt.start();//启动线程 2.实现Runnable接口 class MyThread implements Runnable{ ...... @Override public void run(){ ...... } } MyThread mt = new MyThread(); Thread td = new Thread(mt);//创建线程 td.start();//启动线程 对比总结 无论用哪种方法，都要new一个Thread类对象，用Thread类的start方法来启动线程。 线程生命周期(线程生命周期2.png) 线程各个状态 就绪状态 创建线程对象后，调用了线程的start()方法（此时线程只是进入了线程队列，等待获取CPU服务（cpu可能正在执行其他程序），具备运行条件，但是并不一定已经开始运行了） 运行状态 处于就绪状态的线程，一旦线程获取到CPU的服务之后，就进入到了运行状态，开始执行run()方法里面的逻辑。 终止 线程的run()方法执行完毕，或者人为线程调用了stop()方法（该做法已经被淘汰），线程便进入终止状态。 阻塞 一个正在执行的线程在某些情况下，由于某种原因而暂时让出了CPU资源，暂停了自己的执行，便进入了阻塞状态，如调用 sleep()方法。 JDK JDK7和JDK8的异同（JDK8的新特性） 框架部分 springmvc的单例模式 https://blog.csdn.net/qianyiyiding/article/details/77104736 https://zhuanlan.zhihu.com/p/21733226 即：spring MVC中的controller是单例模式，但是是多线程，各个线程之间不影响！ 设置为多例模式：@Scope(“prototype”) @RestController @RequestMapping(value = &quot;hello&quot;) @Scope(&quot;prototype&quot;) public class HelloController { https://blog.csdn.net/qianyiyiding/article/details/77104736 mybatis与hibernate异同 Spring的AOP与IOC spring是J2EE应用程序的开源框架，是轻量级的IoC和AOP的容器框架，可以单独使用，也可以和其他框架组合使用 AOP： java面向对象思想的拓展，将系统中非核心的业务提取出来，进行单独处理。比如事务、日志和安全等体现java的灵活。 spring中面向切面的实现有两种方式，一种是动态代理，一种是CGLIB，动态代理必须要提供接口，而CGLIB实现是继承。 **关于IoC和DI** &gt; https://www.iteye.com/blog/jinnianshilongnian-1413846 IOC与DI： 1）（IOC）控制反转：组件**依赖关系**的创建和管理置于spring容器，由容器控制，而不是由代码直接控制，将控制权转向了容器。 2）（DI）依赖注入:组件之间的依赖关系由容器在运行期决定 ，由容器动态的将某种依赖关系注入到组件之中，实现的程序的解耦。 spring中有三种注入方式，一种是set注入，一种是接口注入，另一种是构造方法注入。 https://zhuanlan.zhihu.com/p/90939765 spring websocket api Spring 4.0的websocket的支持 http://wiselyman.iteye.com/blog/2003336 SSM概述(SSM概述.png)： 数据库部分索引 数据库索引(创建索引.jpg) JDBC 自己添加： jdbc 多看 SQL进阶 java基础 servlet与CGI servlet与CGI Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。 (1)加载：容器通过类加载器使用servlet类对应的文件加载servlet (2)创建：通过调用servlet构造函数创建一个servlet对象 (3)初始化：调用init方法初始化 (4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求 (5)卸载：调用destroy方法让servlet自己释放其占用的资源 JSP九大内置对象 JSP九大内置对象 内置对象特点: 1.由JSP规范提供,不用编写者实例化 2.通过Web容器实现和管理 3.所有JSP页面均可使用 4.只有在脚本元素的表达式或代码段中才可使用(&lt;%=使用内置对象%&gt;或&lt;%使用内置对象%&gt;) 常用内置对象: 1.输出输入对象:request对象、response对象、out对象 2.通信控制对象:pageContext对象、session对象、application对象 3.Servlet对象:page对象、config对象 4.错误处理对象:exception对象 String、StringBuffer、StringBuilder 区别 String：适用于少量的字符串操作的情况 StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况 StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况 从JVM角度分析String慢的原因 那么JVM就会像上面说的那样，不断的创建、回收对象来进行这个操作了。速度就会很慢。 StringBuffer与StringBuilder StringBuilder是线程不安全的，而StringBuffer是线程安全的 StringBuffer JDK1.0出现 StringBuilder JDK1.5出现 mybatis缓存 一级缓存和二级缓存 mybatis的一级缓存: MyBatis会在表示会话的SqlSession对象中建立一个简单的缓存，将每次查询到的结果结果缓存起来， 当下次查询的时候，如果判断先前有个完全一样的查询，会直接从缓存中直接将结果取出，返回给用户， 不需要再进行一次数据库查询了。 MyBatis会在一次会话的SqlSession对象中创建一个本地缓存(local cache)， 对于每一次查询，都会尝试根据查询的条件去本地缓存中查找是否在缓存中，如果在缓存中， 就直接从缓存中取出，然后返回给用户；否则，从数据库读取数据，将查询结果存入缓存并返回给用户。 一级缓存是SqlSession级别的缓存。在操作数据库时需要构造 sqlSession对象， 在对象中有一个(内存区域)数据结构（HashMap）用于存储缓存数据。 不同的sqlSession之间的缓存数据区域（HashMap）是互相不影响的。 一级缓存的作用域是同一个SqlSession，在同一个sqlSession中两次执行相同的sql语句， 第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。 当一个sqlSession结束后该sqlSession中的一级缓存也就不存在了。Mybatis默认开启一级缓存。 二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句， 多个SqlSession去操作数据库得到数据会存在二级缓存区域，多个SqlSession可以共用二级缓存， 二级缓存是跨SqlSession的。 二级缓存是多个SqlSession共享的，其作用域是mapper的同一个namespace， 不同的sqlSession两次执行相同namespace下的sql语句且向sql中传递参数也相同即最终执行相同的sql语句， 第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。 Mybatis默认没有开启二级缓存需要在setting全局参数中配置开启二级缓存。 参考 https://www.cnblogs.com/little-fly/p/6251451.htmlhttp://www.jb51.net/article/116961.htm 2019spring中使用了哪些设计模式？ https://juejin.im/entry/5c6611a2f265da2de1658a13 JDK动态代理和CGLIB动态代理https://juejin.im/post/5c3e9c37f265da61263862f1https://juejin.im/post/5bbff7daf265da0aef4e330c 20201.Java 的类加载器相关 1.Java 的类加载器的种类都有哪些? 1、根类加载器(Bootstrap) --C++写的 ，看不到源码 2、扩展类加载器（Extension） --加载位置 ：jre\lib\ext 中 3、系统(应用)类加载器(System\App) --加载位置 ：classpath 中 4、自定义加载器(必须继承 ClassLoader) 2.类什么时候被初始化? 1）创建类的实例，也就是 new 一个对象 2）访问某个类或接口的静态变量，或者对该静态变量赋值 3）调用类的静态方法 4）反射（Class.forName(&quot;com.lyj.load&quot;)） 5）初始化一个类的子类（会首先初始化子类的父类） 6）JVM 启动时标明的启动类，即文件名和类名相同的那个类 只有这 6 中情况才会导致类的类的初始化。 类的初始化步骤： 1）如果这个类还没有被加载和链接，那先进行加载和链接 2）假如这个类存在直接父类，并且这个类还没有被初始化 （注意：在一个类加载器中，类只能初始化一次），那就初始化直接的父类（不适用于接口） 3)加入类中存在初始化语句（如 static 变量和static 块），那就依次执行这些初始化语句。 3.Java 类加载体系之ClassLoader和双亲委托机制 java 是一种类型安全的语言，它有四类称为安全沙箱机制的安全机制来保证语言的安全性， 这四类安全沙箱分别是： 1）类加载体系 2）.class 文件检验器 3）内置于 Java 虚拟机（及语言）的安全特性 4）安全管理器及Java API 这里主要讲解类的加载体系： java 程序中的 .java 文件编译完会生成 .class 文件，而 .class 文件 就是通过被称为类加载器的ClassLoader加载的，而 ClassLoder 在加载过程中会 使用“双亲委派机制”来加载 .class 文件，先上图： 1.BootStrapClassLoader:启动类加载器,该ClassLoader是jvm在启动时创建的, 用于加载 $JAVA_HOME$/jre/lib 下面的类库（或者通过参数-Xbootclasspath指定）。 由于启动类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用， 所以不能直接通过引用进行操作。 2.ExtClassLoader:扩展类加载器,该ClassLoader是在sun.misc.Launcher里 作为一个内部类ExtClassLoader定义的（即 sun.misc.Launcher$ExtClassLoader）, ExtClassLoader 会加载 $JAVA_HOME/jre/lib/ext 下的类库 （或者通过参数-Djava.ext.dirs 指定）。 3.AppClassLoader:应用程序类加载器，该ClassLoader同样是在sun.misc.Launcher里 作为一个内部类AppClassLoader 定义的（即 sun.misc.Launcher$AppClassLoader）, AppClassLoader 会加载java环境变量CLASSPATH所指定的路径下的类库,而CLASSPATH所指定的路径 可以通过System.getProperty(&quot;java.class.path&quot;)获取；当然，该变量也可以覆盖， 可以使用参数-cp，例如：java -cp 路径 （可以指定要执行的 class 目录）。 4.CustomClassLoader:自定义类加载器，该ClassLoader 是指我们自定义的ClassLoader， 比如tomcat的StandardClassLoader 属于这一类；当然，大部分情况下使用AppClassLoader 就足够了。 前面谈到了ClassLoader 的几类加载器，而ClassLoader使用双亲委派机制来加载class文件的。 ClassLoader 的双亲委派机制是这样的（这里先忽略掉自定义类加载器 CustomClassLoader）： 1）当AppClassLoader加载一个class时,它首先不会自己去尝试加载这个类,而是把类加载请求委派给父类加载器ExtClassLoader去完成。 2）当ExtClassLoader加载一个class时,它首先也不会自己去尝试加载这个类,而是把类加载请求委派给 BootStrapClassLoader去完成。 3）如果BootStrapClassLoader加载失败（例如在$JAVA_HOME$/jre/lib 里未查找到该class）, 会使用ExtClassLoader来尝试加载； 4）若 ExtClassLoader也加载失败,则会使用AppClassLoader来加载,如果AppClassLoader 也加载失败,则会报出异常ClassNotFoundException。 下面贴下ClassLoader 的loadClass(String name, boolean resolve)的源码： protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException { // 首先找缓存是否有 class Class c = findLoadedClass(name); if (c == null) { //没有判断有没有父类 try { if (parent != null) { //有的话，用父类递归获取 class c = parent.loadClass(name, false); } else { //没有父类。通过这个方法来加载 c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found // from the non-null parent class loader } if (c == null) { // 如果还是没有找到，调用 findClass(name)去找这个类 c = findClass(name); } } if (resolve) { resolveClass(c); } return c; } 代码很明朗：首先找缓存（findLoadedClass），没有的话就判断有没有 parent， 有的话就用 parent 来递归的 loadClass，然而 ExtClassLoader 并没有设置 parent， 则会通过 findBootstrapClassOrNull 来加载 class，而findBootstrapClassOrNull 则会通过 JNI 方法”private native Class findBootstrapClass(String name)“来 使用 BootStrapClassLoader 来加载 class。 然后如果parent未找到class,则会调用findClass来加载class,findClass是一个 protected 的空方法,可以覆盖它以便自定义class加载过程。 另外,虽然ClassLoader加载类是使用loadClass方法,但是鼓励用ClassLoader的子类重写 findClass(String)，而不是重写 loadClass，这样就不会覆盖了类加载默认的双亲委派机制。 4.双亲委派托机制为什么安全 举个例子,ClassLoader加载的class文件来源很多,比如编译器编译生成的class、或者网络下载的字节码。 而一些来源的class 文件是不可靠的,比如我可以自定义一个java.lang.Integer类来覆盖jdk中默认的 Integer类,例如下面这样： package java.lang; public class Integer { public Integer(int value) { System.exit(0); } } 初始化这个Integer 的构造器是会退出JVM，破坏应用程序的正常进行，如果使用双亲委派机制的话 该Integer类永远不会被调用，以为委托BootStrapClassLoader加载后会加载JDK中的Integer类 而不会加载自定义的这个，可以看下下面这测试个用例： public static void main(String... args) { Integer i = new Integer(1); System.err.println(i); } 执行时 JVM 并未在 new Integer(1)时退出，说明未使用自定义的 Integer，于是就保证了安全性。 4.mybatis（mapper）调用过程 Mapper方法的执行过程：先获取Mapper对象，该对象是JdbcProxy代理对象。 代理对象回调接口里，会根据Method，执行org.apache.ibatis.session.SqlSession对应的方法， 同时需要完成参数的转化. https://blog.csdn.net/bingospunky/article/details/79220894https://www.jianshu.com/p/3c56bf3313ce 5.hashMap https://blog.csdn.net/woshimaxiao1/article/details/83661464 6.redis存储方式 Redis是一个由ANSI C语言编写，性能优秀、支持网络、可持久化的K-K内存数据库， 并提供多种语言的API。它常用的类型主要是 String、List、Hash、Set、ZSet 这5种。 Redis在互联网公司一般有以下应用: String：缓存、限流、计数器、分布式锁、分布式Session Hash：存储用户信息、用户主页访问量、组合查询 List：微博关注人时间轴列表、简单队列 Set：赞、踩、标签、好友关系 Zset：排行榜 https://www.cnblogs.com/weknow619/p/10464139.html 7.MySQL数据库索引的4大类型及相关的索引创建 1.普通索引 这是最基本的MySQL数据库索引，它没有任何限制。它有以下几种创建方式： a:创建索引: CREATE INDEX indexName ON mytable(username(length)); b:修改表结构: ALTER mytable ADD INDEX [indexName] ON (username(length)) 创建表的时候直接指定 CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, INDEX [indexName] (username(length)) ); c:删除索引的语法: DROP INDEX [indexName] ON mytable; 2.唯一索引 它与前面的普通索引类似，不同的就是：MySQL数据库索引列的值必须唯一，但允许有空值。 如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式： a:创建索引: CREATE UNIQUE INDEX indexName ON mytable(username(length)) b:修改表结构 ALTER mytable ADD UNIQUE [indexName] ON (username(length)) c:创建表的时候直接指定 CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, UNIQUE [indexName] (username(length)) ); 3.主键索引 它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引： CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, PRIMARY KEY(ID) ); 当然也可以用 ALTER 命令。记住：一个表只能有一个主键。 4.组合索引 https://www.cnblogs.com/xingzc/p/5757697.html 7.ArrayList和LinkedList ArrayList和LinkedList都是实现了List接口的容器类，用于存储一系列的对象引用。 他们都可以对元素的增删改查进行操作。 ArrayList和LinkedList的大致区别如下: 1.ArrayList是实现了基于 动态数组 的数据结构，LinkedList是基于 链表结构 。 2.对于随机访问的get和set方法，ArrayList要优于LinkedList，因为LinkedList要移动指针。 3.对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。 8.查询前10条数据和后10条数据： select top 10 * from tablename 或者按时间正序or倒序，limit10 select * from aaa where create_time&lt;=&quot;2017-03-29 19:30:36&quot; order by create_time desc/asc limit 10 如果按照某个字段排序后，再limit10查询，速度有区别？貌似没区别]]></content>
      <tags>
        <tag>面试总结20180410</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery]]></title>
    <url>%2F2018%2F03%2F02%2FJQuery%2F</url>
    <content type="text"><![CDATA[JQuery基础jquery优点 强大的选择器 解决浏览器的兼容 完善的时间机制 出色的ajax封装 丰富的UI 特性与工具方法 链式操作 回调函数 迭代器 延迟对象 队列 JQuery基础归类 样式 DOM 事件 动画 JQuery高级AJAX data包含中文时乱码 提交方式由GET改为POST]]></content>
      <tags>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NoSQL相关]]></title>
    <url>%2F2018%2F02%2F13%2FNoSQL%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[NoSQL概念 概念 NoSQL即 Not Only SQL,泛指 非关系型数据库。 NoSQL存在的条件 为什么需要NoSQL High Performance 高并发读写 Huge Storage 海量数据的高效存储和访问 High Scalability &amp;&amp; High Availability 高可扩展性和高可用性 这些对于关系型数据库都是比较有很大的局限性的，但是对于非关系型数据库而言却是其优点。 NoSQL的特点总结 主要特点 易扩展（数据之间没有关系，容易扩展） 灵活的数据模型（不需要像关系型数据库那样事先建立要存储的字段） 大数据量，高性能（读写性能很高） 高可用（在不影响性能的情况下实现高可用的框架） NoSQL主流产品 主流产品 Redis mongoDB membase CouchDB Cassandra 其中Redis和mongoDB比较常见 NoSQL分类 分类 键值(Key-Value)存储(如：Redis，优势是快速查询；劣势是存储的数据缺少结构化) 列存储（优势是快速查询、扩展性也比较强；劣势是功能相对局限） 文档数据库（如：mongoDB，优势是数据结构要求不是很严格；劣势是查询性能不是很好，而且缺少统一的查询语法） 图形数据库（典型的应用是社交网络，优势是利用图结构相关算法；劣势是需要对整个图做计算才能得出结果，不容易做分布式的集群方案） Redis相关Redis概述 Redis概述 Redis是开源的，知乎、新浪微博、Github都在使用Redis C语言开发的 高性能的键值对数据库 官方测试读写性能：读,11w次/s ; 写,8w次/s Redis支持的键值数据类型 字符串类型 列表类型 有序集合类型 散列类型 集合类型 Redis应用场景 缓存（最主要的应用场景，比如数据的查询：新闻，商品的内容放入到缓存当中） 任务队列（秒杀，抢购） 网站访问统计 数据过期处理（可以精确到毫秒） 分布式集群架构中的session分离 查看redis服务是否已经启动命令 ps -ef | grep -i redis ps 将某个进程显示出来 -A 显示所有程序。 -e 此参数的效果和指定&quot;A&quot;参数相同。 -f 显示UID,PPIP,C与STIME栏位。 grep命令是查找 中间的|是管道命令 是指ps命令与grep同时执行 这条命令的意思是显示有关redis有关的进程 UID PID PPID C STIME TTY TIME CMD 各相关信息的意义 daemonize：守护进程 redis服务启动/关闭命令 进入redis安装目录： cd redisLocation 启动服务： ./bin/redis-server ./redis.config 关闭服务： ./bin/redis-cli shutdowm jedis jedis概念 jedis是redis官方首选的java客户端开发包 https://github.com/xetorthio/jedis linux下设置redis防火墙端口 vim /etc/sysconfig/iptables加6389端口 简单罗列NoSQL(非关系型数据库): redis：key/value键值对存储数据库 mongodb:文档型数据库 hbase：列式数据库 neo4j：图式数据库，存储的是图关系而非行或列。主要用于社交网络的存储。 redis数据结构: String Hash Set SortedSet List redis事务:multi exec discard redis 持久化: rdb内存快照 aof命令日志]]></content>
      <tags>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[private]]></title>
    <url>%2F2018%2F01%2F29%2Fprivate%2F</url>
    <content type="text"><![CDATA[按钮可执行性document.all.share.disabled=true; document.all.share.disabled=false; 获取gird的值：var projectsid = gridgetselectvalue(&quot;projectsid&quot;); 如果gird的名字是mygrid,则: var projectsid = mygridgetselectvalue(&quot;projectsid&quot;); 获取普通属性值：如获取property=&quot;result&quot;的值： var result = document.all.result.value; 获取后端Attribute传值： &lt;% String openjspflag = (request.getAttribute(&quot;openjspflag&quot;) == null) ? &quot;0&quot; : request.getAttribute(&quot;openjspflag&quot;).toString(); %&gt; TD占位分割&lt;table border=&quot;0&quot; width=&quot;100%&quot; class=&quot;searchzone&quot; &gt; &lt;TR class=&quot;txttr&quot;&gt; &lt;td colspan=&quot;2&quot;&gt; &lt;table border=&quot;0&quot; width=&quot;100%&quot; align=&quot;center&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt; &lt;tr&gt; &lt;td class=&quot;sr&quot; align=&quot;left&quot; style=&quot;width:1%&quot; nowrap&gt;部门：&lt;/td&gt; &lt;td class=&quot;sr&quot; align=&quot;left&quot; style=&quot;width:15%&quot; nowrap&gt; &lt;select:select property=&quot;departname&quot; addspacerow=&quot;true&quot; style=&quot;width:90%&quot; styleClass=&quot;txt&quot; onchange=&quot;fillperson()&quot;&gt; &lt;select:options collection=&quot;gird.factoryname&quot; property=&quot;departsid&quot; labelProperty=&quot;departname&quot; /&gt; &lt;/select:select&gt; &lt;/td&gt; &lt;td class=&quot;sr&quot; align=&quot;left&quot; style=&quot;width:1%&quot; nowrap&gt;责任人：&lt;/td&gt; &lt;td class=&quot;sr&quot; align=&quot;left&quot; style=&quot;width:15%;padding:0&quot; nowrap&gt; &lt;select:select property=&quot;personname&quot; addspacerow=&quot;true&quot; style=&quot;width:90%&quot; styleClass=&quot;txt&quot;&gt; &lt;select:options collection=&quot;gird.factoryname&quot; property=&quot;personsid&quot; labelProperty=&quot;personname&quot; /&gt; &lt;/select:select&gt; &lt;/td&gt; &lt;td width=&quot;30%&quot;&gt;&lt;/td&gt; &lt;td width=&quot;30%&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/td&gt; &lt;/TR&gt; &lt;/table&gt; TD占位分割标准版：&lt;style type=&quot;text/css&quot;&gt; table{ text-align:center; border-collapse:collapse; } tr{ height:50px; } .mytd{ border-right:1px solid red; } &lt;/style&gt; &lt;table width=&quot;100%&quot; border=&quot;1&quot; bordercolor=&quot;red&quot; align=&quot;center&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt; &lt;table border=&quot;0&quot; width=&quot;100%&quot; align=&quot;center&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt; &lt;tr&gt; &lt;td class=&quot;mytd&quot; width=&quot;70%&quot;&gt;70%&lt;/td&gt; &lt;td width=&quot;30%&quot;&gt;30%&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;50%&lt;/td&gt; &lt;td&gt;50%&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; textarea以及其readonly：&lt;TR class=&quot;txttr&quot;&gt; &lt;td class=&quot;sr&quot; align=&quot;left&quot; nowrap width=&quot;95%&quot;&gt; &lt;span style=&quot;height:300px;display:block;vetical-align:top;float:left;&quot;&gt;任务内容&amp;nbsp&lt;/span&gt; &lt;!-- &lt;textarea id=&quot;taskcontent&quot; style=&quot;width:100%;height:300px;&quot;&gt;&lt;/textarea&gt; --&gt; &lt;html:textarea property=&quot;taskcontent&quot; rows=&quot;10&quot; style=&quot;width:100%&quot;/&gt; &lt;/td&gt; &lt;/TR&gt; &lt;td class=&quot;sr&quot; align=&quot;left&quot; nowrap width=&quot;95%&quot;&gt; &lt;span style=&quot;height:30px;display:block;vetical-align:top;float:left;&quot;&gt;任务主题&amp;nbsp&lt;/span&gt; &lt;!-- &lt;input type=&quot;text&quot; id=&quot;taskname&quot; style=&quot;height:30px;width:100%&quot;&gt; --&gt; &lt;html:text property=&quot;taskname&quot; maxlength=&quot;20&quot; readonly=&quot;false&quot; styleClass=&quot;txt&quot; style=&quot;width:100%&quot;/&gt; &lt;/td&gt; &lt;TR class=&quot;txttr&quot;&gt; &lt;td class=&quot;zw&quot; align=&quot;left&quot; style=&quot;width:20%&quot; nowrap&gt;备注:&lt;/td&gt; &lt;td class=&quot;sr&quot; align=&quot;right&quot; style=&quot;width:80%&quot; nowrap&gt; &lt;html:textarea property=&quot;remark&quot; rows=&quot;10&quot; readonly=&quot;false&quot; style=&quot;width:100%;height:90px&quot;/&gt; &lt;/td&gt; &lt;/TR&gt; if("123000"==prompt("Please input password")) { alert("Right"); }else{ alert("Wrong"); location="https://www.imux.space"; }]]></content>
      <tags>
        <tag>private</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis]]></title>
    <url>%2F2018%2F01%2F08%2FMyBatis%2F</url>
    <content type="text"><![CDATA[mybatis使用过程中问题集多个参数时需要参数绑定 Dao接口进行参数绑定 异常信息： HTTP Status 500 - Request processing failed; nested exception is org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.binding.BindingException: Parameter &apos;acceptPersonId&apos; not found. Available parameters are [1, 0, param1, param2] 解决方案： DAO层中传递参数时加@Param(&quot;acceptPersonId&quot;)，如下： List&lt;Message&gt; selectByUser(@Param(&quot;acceptPersonId&quot;) String acceptPersonId, @Param(&quot;status&quot;) String status); 多个参数时加@Param(&quot;acceptPersonId&quot;)，单个参数可以直接selectByUser(String acceptPersonId); mybatis与in查询 mybatis中如何使用in查询 &lt;!--String[] getddUserIds(Integer[] userId); --&gt; &lt;select id=&quot;getddUserIds&quot; parameterType=&quot;integer&quot; resultType=&quot;string&quot;&gt; select ddUserId from user where userId in &lt;foreach collection=&quot;array&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot; item=&quot;userId&quot; index=&quot;index&quot;&gt; #{userId} &lt;/foreach&gt; &lt;/select&gt; mybatis查询结果与SQL查询字段不一致 SQL中查询的字段在经过mybatis处理后的查询结果中没有 例如属性名为pId，但是编辑器生成getter/setter方法时生成的是setpId和setpId 这就导致在某些版本（比如3.1.0版本）的mybatis中无法将pId的值与SQL中的值匹配，将getter/setter改为setPId和setPId即可： private String pId; public String getPId() { return pId; } public void setPId(String pId) { this.pId = pId; } &lt;!--查询组织机构数据--&gt; &lt;select id=&quot;selectOrg&quot; resultType=&quot;com.union.Management.bean.Org&quot;&gt; select a.DepartID as id,IFNULL(a.ParentID,0) as pid,a.DepartName as name from sys_domain as a order by a.ruleid &lt;/select&gt; 字段为空时不更新该字段 使用条件判断 &lt;!--基本信息-更新--&gt; &lt;update id=&quot;updateBasicInfoById&quot; parameterType=&quot;com.union.Management.bean.PersonInfoDetailBasic&quot;&gt; UPDATE user_info AS a SET a.PersonName = #{personName}, a.Gender = #{gender},a.DepartID=#{departID} ,a.Weight=#{weight},a.IdentityCard=#{identityCard},a.Nation=#{nation},a.MobileNo=#{mobileNo} ,a.LastModifyUserID=#{lastModifyUserID} &lt;if test=&quot;height != null and height != &apos;&apos;&quot; &gt; &lt;!--SAMPLE_BATCH_NO = #{sampleBatchNo,jdbcType=VARCHAR},--&gt; ,a.Height=#{height} &lt;/if&gt; WHERE a.PersonSID =#{personSID} &lt;/update&gt; 用c标签遍历实现select下拉框 jsp jsp需要引入jstl： &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; 和开启EL表达式： &lt;%@ page isELIgnored=&quot;false&quot; %&gt;&lt;%--开启EL表达式--%&gt; &lt;select class=&quot;form-control&quot; id = &quot;nationType&quot; &gt; &lt;c:forEach items=&quot;${nations}&quot; var=&quot;data&quot;&gt; &lt;option value=&quot;${data.nationName}&quot;&gt;${data.nationName}&lt;/option&gt; &lt;/c:forEach&gt; &lt;/select&gt; 下拉框数据反写 //民族下拉框值反写 var selectCode2 = document.getElementById(&quot;nationType&quot;); for (var i = 0; i &lt; selectCode2.options.length; i++) { if (selectCode2.options[i].value == &quot;${BasicInfo.nation}&quot;) { selectCode2.options[i].selected = true; break; } } 参考链接： https://zhidao.baidu.com/question/713376095728011125.html nations在Java代码中设置 List&lt;Nation&gt; nations = this.personInfoDetailBasicService.queryNations(); req.setAttribute(&quot;nations&quot;, nations); 数据库中日期 0000-00-00 异常处理方式 在jdbc连接中添加参数解决 jdbc.url=jdbc:mysql://192.168.1.1:3306/mydb222?useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&amp;transformedBitIsBoolean=true zeroDateTimeBehavior=round是为了指定MySql中的DateTime字段默认值查询时的处理方式；默认是抛出异常， 对于值为0000-00-00 00:00:00（默认值）的纪录，如下两种配置，会返回不同的结果： zeroDateTimeBehavior=round 0001-01-01 00:00:00.0 zeroDateTimeBehavior=convertToNull null SSMcontroller中接收参数的另一种形式 接收参数的另一种方式 @RequestMapping(&quot;/readMessage/{id}&quot;) public String ReadMessage(@PathVariable Integer id, Message message, HttpServletRequest request) { mybatis 分页 mybatis-config.xml文件中配置插件： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; //配置PageInterceptor位置 以及数据库类型 &lt;plugins&gt; &lt;plugin interceptor=&quot;com.xjd.mybatis.page.PageInterceptor&quot;&gt; &lt;property name=&quot;databaseType&quot; value=&quot;mysql&quot;/&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/configuration&gt; Dao中的修改 由原来的单参数变为多参数，要用@Param绑定 原： List selectAll(Integer loginId); 修改后： List selectAll(@Param(“loginId”) Integer loginId, @Param(“page”) Pagination page); controller中对应的修改 //分页 Page&lt;Message&gt; page = new Page&lt;Message&gt;(pageIndex, 6); // 第1页取20条 List&lt;Message&gt; message = null; try { //传入page对象 message = this.messageService.queryAll(loginId, page); page.setResultList(message); // 将结果集传入 //总记录条数 Integer totalCount = page.getTotalCount(); //总页数-totalPage需要在Page实体中加入getter/setter方法 Integer totalPage = page.getTotalPage(); } catch (Exception e) { e.printStackTrace(); } 原理； MyBatis3.2 使用Interceptor进行分页原理： 当Mybatis查询数据的时候，利用Mybatis提供的Interceptor对查询方法进行拦截，动态修改SQL，把不带分页的SQL改造成带分页的SQL 比如在MySql数据库下面 正常查询的SQL 为 selelct id, name from user where name = ? 那么改造后的SQL 为 selelct id, name from user where name = ? limit 5 , 10 参考示例代码以及插件包 百度云 链接:https://pan.baidu.com/s/1IK_gf85Sz_x851n2hNJewA 密码:v78x 参考源： https://www.cnblogs.com/daxin/p/3236861.html https://github.com/bleast/mybatis-page-plugin]]></content>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[discuz论坛用户账号批量导入]]></title>
    <url>%2F2018%2F01%2F02%2Fdiscuz%E8%AE%BA%E5%9D%9B%E7%94%A8%E6%88%B7%E8%B4%A6%E5%8F%B7%E6%89%B9%E9%87%8F%E5%AF%BC%E5%85%A5%2F</url>
    <content type="text"><![CDATA[脚本文件 Python脚本 http://ogy57hyu6.bkt.clouddn.com/discuz.py.txt 用户信息源用户信息文件按顺序存储用户信息（用户名，密码，邮箱，用户组，是否通知，addsubmit）。可以按如下两种方式组织(以以下格式复制到txt文本中即可)： 包含全部信息 usr1,123456,usr1@usr.com,10,0,addsubmit usr2,123456,usr2@usr.com,10,0,addsubmit usr3,123456,usr3@usr.com,10,0,addsubmit usr4,123456,usr4@usr.com,10,0,addsubmit 也可以只需要部分信息 usr1,123456,usr1@usr.com usr2,123456,usr2@usr.com usr3,123456,usr3@usr.com usr4,123456,usr4@usr.com txt文本 http://ogy57hyu6.bkt.clouddn.com/user.txt 说明 访问此链接即可查看添加新用户所需要填写的选项： http://192.168.1.111/bbs/admin.php?frames=yes&amp;action=members&amp;operation=add 192.168.1.111 是discuz所在服务器ip bbs 是discuz部署在服务器上的名称 脚本执行说明 执行环境：Python2.7 执行命令：./discuz.py 脚本相应调整 根据具体环境需要作出的调整 1.main函数中（在130行）: file = &apos;/Users/ux/py/dis/user.txt&apos; home_url = &apos;http://192.168.1.147/bbs/admin.php&apos; admin = &apos;ux&apos; pwd = &apos;ux123456&apos; file：需要被导入的用户信息的txt文本路径 home_url：管理后台的访问路径 admin：管理员的登录名 pwd：管理员的登录密码 2.对应的host修改（29行）: &quot;Host&quot;:&quot;192.168.1.111&quot;, 将host修改为与home_url中一致的IP即可 个别用户添加失败解决方法 找到Discuz的数据表pre_common_member， 查找与添加失败的用户email一致的记录，删除或修改即可。 查询并导出符合discuz.py要求的用户数据 mysql: SELECT CONCAT(username,&apos;,&apos;),CONCAT(password,&apos;,&apos;),CONCAT(username,&quot;@email.com&quot;) AS email FROM pre_ucenter_members; db2: SELECT CONCAT(name,&apos;,&apos;),CONCAT(pwd,&apos;,&apos;),CONCAT(name,&apos;@user.com&apos;) AS email FROM PersonInfo WHERE Active=&apos;1&apos;; 参考文章 http://blog.csdn.net/zhongping136/article/details/46730191http://blog.csdn.net/change518/article/details/50555301]]></content>
      <tags>
        <tag>discuz用户批量导入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java项目集成Discuz的单点登录]]></title>
    <url>%2F2017%2F12%2F29%2Fjava%E9%A1%B9%E7%9B%AE%E9%9B%86%E6%88%90Discuz%E7%9A%84%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[条件准备 部署Discuz 参见文章：windows下discuz论坛 Linux下原理相同 Java项目 普通Javaweb项目即可 Discuz用户中心访问程序包 云盘地址 链接:https://pan.baidu.com/s/1dFtW97z 密码:mkay 下载解压，将里面的 com.fivestars.interfaces.bbs包 和 config.properties 和 Jsp_demo.jsp 和 web.xml 拷贝出来 备用。 Java项目与Discuz整合单点登录将配置和工具类放到Java项目 清单 1.discuz工具包 2.web.xml添加discuz工具包路径 3.discuz配置文件 4.修改Java项目登录代码 5.discuz jsp 将工具包放到Java项目中： com.fivestars.interfaces.bbs包（src根目录） 和 config.properties（src根目录） 分别放到对应目录（参考下载的Demo目录结构） 将web.xml中的复制到Java项目的web.xml中，内容如下： &lt;servlet&gt; &lt;servlet-name&gt;api&lt;/servlet-name&gt; &lt;servlet-class&gt;com.fivestars.interfaces.bbs.api.UC&lt;/servlet-class&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;api&lt;/servlet-name&gt; &lt;url-pattern&gt;/api/uc.php&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; Discuz的UCenter中配置参数，使其与Java项目通信 访问Discuz的用户管理中心（我的discuz在apache下部署的名称为bbs,部署机器ip为192.148.1.147），如： http://192.168.1.147/bbs/uc_server 以创始人或管理员身份登录 点击应用管理，添加新应用 1.应用类型 选择：其他 2.应用名称 随便写，最好和Java项目名保持一致 3.应用的主URL Java项目的访问地址，如： http://localhost:8080/discuzTest 4.通信密钥 随便写，如123456，后面在Java项目中要用到 5.是否开启同步登陆 勾选：是 6.是够接受通知 勾选：是 最后提交,提交后在应用管理用看到，此时应用通信还处于失败状态，接下来配置Java项目 修改Java项目中的config.properties 修改前面复制到Java src跟目录下的config.properties内容，内容如下（根据实际情况配置）： #UCenter访问地址 UC_API = http://192.168.1.147/bbs/uc_server #uc ip address，UCenter ip地址 UC_IP = 192.168.1.147 #key，通信密钥 UC_KEY = 123456 #appid,应用ID（在应用管理&gt;应用列表中可以看到） UC_APPID = 4 #connect mode: default value is &quot;&quot;，可以不填 UC_CONNECT = 启动Java项目，进入UCenter&gt;应用管理，可以看到此时的通信情况会变为：通信成功。 单点登录开发 Java项目中访问Discuz, 假定点击一个按钮跳转到一个loginDiscuz.jsp页面，提供Discuz论坛地址，点击地址后跳转到论坛首页： 将上面Jsp_demo.jsp中的代码拷贝到loginDiscuz.jsp中，稍加修改： http://ogy57hyu6.bkt.clouddn.com/2-logindiscuz.jsp.txt 注：其中下面的代码比较重要 out.println($ucsynlogin + &quot;&lt;a href=&apos;http://localhost/bbs&apos; target=&apos;_blank&apos;&gt;&lt;span style=&apos;font-size:18px&apos;&gt;点此访问论坛！&lt;/span&gt;&lt;/a&gt;&quot;); 将返回的$ucsynlogin输出到页面，才能是单点登录成功。 如何用postman访问整合好的Java项目，如： http://192.168.1.147:8080/discuzTest/Jsp_demo.jsp 会看到返回一段js: &lt;script type=&quot;text/javascript&quot; src=&quot;http://localhost/bbs/api/uc.php?time=1514532782&amp;code=2f15Z57hlywzRB9IwfMmFH%2BVicj4NZLJyxbcdwiTFsOfI1mv2SPKISVXNEkTEmtP9AdwcNfJJPB9z9F36U4T%2FGvSm%2BHvR4%2BefOyk6x4k1zS0KmP%2BZKXM9i6Pj%2BizV06jNyT7kLnYVyPChoOwEMeoqomqIKYbnBaI5pN3&quot; reload=&quot;1&quot;&gt;&lt;/script&gt; 将js中的src中的内容复制粘贴到浏览器地址栏访问，如果不报错， 再访问Discuz地址，可以看到不用输入登录信息，用户已经处于登录状态。 关于上面返回值中的URL中的localhost 上面返回的链接中是src=”http://localhost/bbs。。。 如果想要返回discuz所在服务器ip，如src=”http://local192.168.1.147/host/bbs。。。。 需要在UCenter的应用管理中将Discuz的 应用的主URL 由http://localhost/bbs替换为所对应的ip，如： http://192.168.1.147/bbs 如图： bug修改 UCenter可能无法登陆bug修正 在discuz\uc_server\model\admin.php 找到adminbase函数，将 $this-&gt;cookie_status = 0; 修改为： $this-&gt;cookie_status = isset($_COOKIE[&apos;sid&apos;]) ? 1 : 0; 单点登录后关闭浏览器用户没有注销bug修正（十分不安全） 在discuz\source\function\function_core.php 找到dsetcookie函数，将 $path = $httponly &amp;&amp; PHP_VERSION &lt; &apos;5.2.0&apos; ? $config[&apos;cookiepath&apos;].&apos;; HttpOnly&apos; : $config[&apos;cookiepath&apos;]; 修改为： //将cookie的生命周期改为浏览器会话结束时结束 $cookie_life = -1; $life = $life &gt; 0 ? $cookie_life : ($life &lt; 0 ? getglobal(&apos;timestamp&apos;) - 31536000 : 0); 参考文章 bug修改 http://blog.sina.com.cn/s/blog_a77576280102vgga.html 单点登录 http://blog.51cto.com/linhongyu/1614618 discuz全部文件 云盘地址 链接:https://pan.baidu.com/s/1pLSilC3 密码:tned 包含文件列表 1-discuzTest.rar 2-修改后的logindiscuz.jsp 3-修改后的config.properties 4-修改后的Discuz部署的文件 5-官网下载的Discuz原包 6-Windows下的xamp（PHP集成环境）]]></content>
      <tags>
        <tag>discuz单点登录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows下discuz论坛]]></title>
    <url>%2F2017%2F12%2F26%2Fwindows%E4%B8%8Bdiscuz%E8%AE%BA%E5%9D%9B%2F</url>
    <content type="text"><![CDATA[工具准备 discuz产品包 下载地址(utf-8版) http://www.comsenz.com/downloads/install/discuzx Windows下PHP集成环境XAMPP http://rj.baidu.com/soft/detail/25759.html?ald MySQL 链接:https://pan.baidu.com/s/1kVcjybd 密码:eura 163邮箱 注册163邮箱，开启SMTP服务。 安装部署 部署 安装完mysql和XAMPP后，将下载好的Discuz_X3.2_SC_UTF8.zip解压，将解压后的upload文件夹改名为bbs或其它想要的命名，并拷贝到xampp安装目录下的htdocs文件夹下，如 C:\xampp\htdocs 运行xampp-control.exe，启动mysql和apache服务， 浏览器访问localhost/bbs,进行论坛的初始化工作（设置数据库连接，数据表的命名规则，以及论坛管理员的账号信息） 邮件服务(用于用户邮箱验证以及找回密码) 以管理员账号登录论坛，点击管理中心，选择站长&gt;邮件设置 1.邮件发送方式选择SOCKET连接SMTP服务器 2.添加SMTP服务器: SMTP服务器：smtp.163.com 端口：25 验证：勾选 发信人邮件地址：m173371@163.com SMTP身份验证用户名：m173371@163.com SMTP身份验证密码：m173371@163.com邮箱的密码 3.邮件头的分隔符 选择：使用LF作为分隔符（通常为Unix/Linux主机） 4.收件人地址…和屏蔽邮件…选是或否（这里选是） 5.提交 6.选择检测按钮，进行邮件发送检测： 测试发件人：m173371@163.com 测试收件人：9036。。。@qq.com 点击建设邮件发送设置按钮，如果邮件正常接收，这表示设置OK. discuz首页logo去除 后台管理中去除图片引用（可以不进行这一步操作，直接进行下一步修改源码操作也能达到目的） 后台管理中心&gt;界面&gt;风格管理&gt;编辑&gt;站点logo&gt;logo.png 代码中去除图片显示 bbs\template\default\common\header.htm 找到125行，即h2标签中的内容： &lt;div class=&quot;hdc cl&quot;&gt; &lt;!--{eval $mnid = getcurrentnav();}--&gt; &lt;h2&gt;&lt;!--{if !isset($_G[&apos;setting&apos;][&apos;navlogos&apos;][$mnid])}--&gt;&lt;a href=&quot;{if $_G[&apos;setting&apos;][&apos;domain&apos;][&apos;app&apos;][&apos;default&apos;]}http://{$_G[&apos;setting&apos;][&apos;domain&apos;][&apos;app&apos;][&apos;default&apos;]}/{else}./{/if}&quot; title=&quot;$_G[&apos;setting&apos;][&apos;bbname&apos;]&quot;&gt;{$_G[&apos;style&apos;][&apos;boardlogo&apos;]}&lt;/a&gt;&lt;!--{else}--&gt;$_G[&apos;setting&apos;][&apos;navlogos&apos;][$mnid]&lt;!--{/if}--&gt;&lt;/h2&gt; &lt;!--{template common/header_userstatus}--&gt; &lt;/div&gt; 注释掉这一句： {$_G[&apos;style&apos;][&apos;boardlogo&apos;]} 底部信息去掉 去掉页面底部全部信息 找到bbs\template\default\common\footer.htm 找到&lt;div id=&quot;ft&quot; class=&quot;wp cl&quot;&gt;（第87行） 删除&lt;div id=&quot;ft&quot; class=&quot;wp cl&quot;&gt;中的如下两个标签中的内容： &lt;div id=&quot;frt&quot;&gt;&lt;/div&gt; &lt;p&gt;&lt;/p&gt; 页签title去除 去除页签title bbs\template\default\common\header_common.htm 搜索Powered by Discuz（或者直接在第6行找） 右下角其它信息去除 去除右下角其它信息 搜索&lt;div id=&quot;ft&quot; class=&quot;wp cl&quot;&gt;(57行) 找到&lt;div id=&quot;ft&quot; class=&quot;wp cl&quot;&gt;中的下面这个span标签： &lt;span id=&quot;debuginfo&quot;&gt; 删除&lt;span id=&quot;debuginfo&quot;&gt;标签中的下面这段代码： , Processed in $_G[debuginfo][time] second(s), $_G[debuginfo][queries] queries 用户头像调用方式 头像加载方式 后台&gt;站长&gt;UCenter设置&gt;头像调用方式 使用动态地址调用头像 使用静态地址调用头像 用户密码长度设置 后台&gt;全局&gt;注册与访问控制 找到： 密码最小长度 修改为自定义长度即可。 或者在代码中修改(太麻烦，不好找) 1.打开static/js/register.js 搜索(297行)： function checkpassword(id1, id2) { 中的 if($(id1).value.length &lt; pwlength) pwlength就是密码长度 2….找不到… 通过数据库表改密码长度 表：pre_common_setting 字段值：pwlength select * from pre_common_setting where skey = &apos;pwlength&apos;; discuz更新缓存 更新缓存（解决配置信息更新等） 后台&gt;工具&gt;更新缓存 修改用户名长度 修改注册类和用户名检查提示 打开 /source/class/class_member.php 文件 $usernamelen = dstrlen($username); if($usernamelen &lt; 3) { showmessage(&apos;profile_username_tooshort&apos;); } elseif($usernamelen &gt; 15) { showmessage(&apos;profile_username_toolong&apos;); } 打开 /source/module/forum/forum_ajax.php 文件 if($usernamelen &lt; 3) { showmessage(&apos;profile_username_tooshort&apos;, &apos;&apos;, array(), array(&apos;handle&apos; =&gt; false)); } elseif($usernamelen &gt; 15) { showmessage(&apos;profile_username_toolong&apos;, &apos;&apos;, array(), array(&apos;handle&apos; =&gt; false)); } 打开文件 uc_client/model/user.php function check_username($username) { $guestexp = &apos;\xA1\xA1|\xAC\xA3|^Guest|^\xD3\xCE\xBF\xCD|\xB9\x43\xAB\xC8&apos;; $len = $this-&gt;dstrlen($username); if($len &gt; 15 || $len &lt; 3 || preg_match(&quot;/\s+|^c:\\con\\con|[%,\*\&quot;\s\&lt;\&gt;\&amp;]|$guestexp/is&quot;, $username)) { return FALSE; } else { return TRUE; } } 打开文件 static/js/register.js if(unlen &lt; 3 || unlen &gt; 15) { errormessage(id, unlen &lt; 3 ? &apos;用户名不得小于 3 个字符&apos; : &apos;用户名不得超过 15 个字符&apos;); return; } 修改语言包提示语句 打开 /source/language/lang_message.php 文件 &apos;profile_username_toolong&apos; =&gt; &apos;抱歉，您的用户名超过 15 个字符，请输入一个较短的用户名&apos;, 打开 /source/language/mobile/lang_template.php 文件 &apos;reg_username&apos; =&gt; &apos;用户名必须为大于3位小于15位&apos;, &apos;registerinputtip&apos; =&gt; &apos;用户名：3-15位&apos;, 参考链接 http://blog.csdn.net/lih062624/article/details/68940617]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下Nginx的负载均衡与HTTPS]]></title>
    <url>%2F2017%2F12%2F19%2Flinux%E4%B8%8BNginx%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%B8%8EHTTPS%2F</url>
    <content type="text"><![CDATA[负载均衡在http代码块中添加 upstream upstream_weblogic { server 192.168.1.191:7001; server 192.168.1.192:7001; } location / { root html; index index.html index.htm; proxy_pass http://upstream_weblogic; proxy_set_header Host $host; proxy_set_header Connection close; proxy_connect_timeout 100ms; # 代理机器连接超时时长(默认的60s太长了) expires 30d; } http跳转HTTPS##server配置begin server { listen 80; listen 443 ssl; server_name www.aaa.com; if ($scheme != https) { #rewrite ^(.*)$ https://$host$1 permanent; return 301 https://$host$request_uri; } ##server配置end # HTTPS 专用配置 begin # http://nginx.org/en/docs/http/configuring_https_servers.html ssl_certificate /usr/local/nginx/nginx.crt; ssl_certificate_key /usr/local/nginx/nginx.key; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # SSL(包括 v3)都有漏洞，应该用 TLS(TLS1.0 = SSL 3.1) ssl_ciphers HIGH:!aNULL:!MD5; # HTTPS 专用配置 end } 添加头信息让浏览器加载http资源（该方法只适用于静态资源）server中添加： add_header &apos;Content-Security-Policy&apos; &apos;upgrade-insecure-requests&apos;; 这一句可以让浏览器加载http的资源。但是有的浏览器不支持，比如IE 或者在页面的head中加入： &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;upgrade-insecure-requests&quot;&gt; 意思是自动将http的不安全请求升级为https 完整配置#user nobody; worker_processes 1; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #pid logs/nginx.pid; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; #log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; # &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; # &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; upstream upstream_weblogic { server 192.168.1.190:7001; server 192.168.1.190:7001; } ignore_invalid_headers on; underscores_in_headers on; merge_slashes on; #include /etc/nginx/conf.d/*.conf; ## 各个 server{} 块 server { listen 80; listen 443 ssl; server_name www.aaa.com; if ($scheme != https) { #rewrite ^(.*)$ https://$host$1 permanent; return 301 https://$host$request_uri; } #charset koi8-r; # 让浏览器自动升级请求为https add_header &apos;Content-Security-Policy&apos; &apos;upgrade-insecure-requests&apos;; #access_log logs/host.access.log main; location / { root html; index index.html index.htm; proxy_pass http://upstream_weblogic; proxy_set_header Host $host; proxy_set_header Connection close; proxy_connect_timeout 100ms; # 代理机器连接超时时长(默认的60s太长了) expires 30d; } # HTTPS 专用配置 # http://nginx.org/en/docs/http/configuring_https_servers.html ssl_certificate /usr/local/nginx/nginx.crt; ssl_certificate_key /usr/local/nginx/nginx.key; # SSL(包括 v3)都有漏洞，应该用 TLS(TLS1.0 = SSL 3.1) ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers HIGH:!aNULL:!MD5; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \.php$ { # proxy_pass http://127.0.0.1; #} # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} # deny access to .htaccess files, if Apache&apos;s document root # concurs with nginx&apos;s one # #location ~ /\.ht { # deny all; #} } # another virtual host using mix of IP-, name-, and port-based configuration # #server { # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / { # root html; # index index.html index.htm; # } #} # HTTPS server # # server { # listen 443 ssl; # server_name 10.201.50.2; # # ssl_certificate /usr/local/nginx/nginx.crt; # ssl_certificate_key /usr/local/nginx/nginx.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / { # root html; # index index.html index.htm; # } # } } 使用OpenSSL生成证书sudo openssl req -x509 -nodes -days 36500 -newkey rsa:2048 -keyout /usr/local/nginx/nginx.key -out /usr/local/nginx/nginx.crt 这样自制证书，会被提示不安全。 Nginx文件链接:https://pan.baidu.com/s/1qXJHXA8 密码:gd0w 参考文章 http://www.xitongzhijia.net/xtjc/20150910/57367.html?1441869885 https://www.cnblogs.com/hustskyking/p/upgrade-insecure-requests.htmlhttps://googlechrome.github.io/samples/csp-upgrade-insecure-requests/index.html http://nginx.org/en/docs/http/ngx_http_headers_module.html 阿里： https://ninghao.net/blog/4449]]></content>
      <tags>
        <tag>nginx-https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下安装Nginx]]></title>
    <url>%2F2017%2F12%2F19%2Flinux%E4%B8%8B%E5%AE%89%E8%A3%85Nginx%2F</url>
    <content type="text"><![CDATA[centos7 64位下安装nginx 软件准备 安装Nginx需要先安装下列软件包： GCC PCRE zlib openssl GCC和PCRE之前在centos7中使用源码安装apache2.4的时候已经安装过，这里用再安装； 这里需要下载安装zlib后再安装nginx zlib官网下载地址： http://www.zlib.net/ openssl官网下载地址 https://www.openssl.org/source/ nginx官网下载地址： http://nginx.org/en/download.html 安装 将zlib、OpenSSL、nginx源码包上传到centos7 打开terminal执行： scp /Users/ux/Downloads/zlib-1.2.11.tar.gz ux@10.211.55.5:/home/ux/mysoft/ scp /Users/ux/Downloads/nginx-1.12.2.tar.gz ux@10.211.55.5:/home/ux/mysoft/ 该命令将macOS系统中位于下载文件夹下的zlib-1.2.11.tar.gz和nginx-1.12.2.tar.gz 源码包上传到centos7的/home/ux/mysoft文件夹下。 解压，编译，安装 解压zlib： gzip -d zlib-1.2.11.tar.gz tar -xf zlib-1.2.11.tar 编译安装zlib： cd zlib-1.2.11 ./configure sudo make sudo make install 解压OpenSSL gzip -d openssl-1.0.2n.tar.gz tar -xf openssl-1.0.2n.tar 安装OpenSSL ./config --prefix=/usr/local/ssl --openssldir=/usr/local/ssl sudo make sudo make install 如果zlib正常安装，则继续安装nginx: 解压nginx gzip -d nginx-1.12.2.tar.gz tar -xf nginx-1.12.2.tar 编译安装nginx： cd nginx-1.12.2 ./configure --prefix=/usr/local/nginx --with-openssl=/home/ux/mysoft/openssl-1.0.2n --with-http_ssl_module 注意：这一步要指定OpenSSL源码包的位置（是OpenSSL源码包位置，不是OpenSSL的安装位置！！），否则后续无法使用ssl模块。 sudo make sudo make install 启动测试 在安装nginx时执行./configure可以看到。nginx默认安装到 /usr/local/nginx/下 启动nginx： cd /usr/local/nginx/sbin ./nginx 快速停止nginx: ./nginx -s stop 正常停止nginx: ./nginx -s quit 置文件修改重装载命令： ./nginx -s reload 关闭防火墙或者把80端口放行： systemctl stop firewalld.service #停止firewall systemctl disable firewalld.service #禁止firewall开机启动 firewall-cmd --zone=public --add-port=80/tcp --permanent #开启80端口，这样外部就能访问nginx的80端口了 --zone #作用域 --add-port=80/tcp #添加端口，格式为：端口/通讯协议 --permanent #永久生效，没有此参数重启后失效 软件包百度云连接 链接 链接:https://pan.baidu.com/s/1qYyZvhM 密码:1xti 参考文章 openssl http://blog.csdn.net/u012889638/article/details/49310123 NGINX的参数 NGINX的参数 nginx指定文件路径有两种方式root和alias，指令的使用方法和作用域： [root] 语法：root path 默认值：root html 配置段：http、server、location、if [alias] 语法：alias path 配置段：location root与alias主要区别在于nginx如何解释location后面的uri，这会使两者分别以不同的方式将请求映射到服务器文件上。 root的处理结果是：root路径＋location路径 alias的处理结果是：使用alias路径替换location路径 alias是一个目录别名的定义，root则是最上层目录的定义。 ###这句话有待考证： 还有一个重要的区别是alias后面必须要用“/”结束，否则会找不到文件的。。。 而root则可有可无~~ root实例 location ^~ /t/ { root /www/root/html/; location ^~ /t/ { root /www/root/html/; } 如果一个请求的URI是/t/a.html时，web服务器将会返回服务器上的/www/root/html/t/a.html的文件。 alias实例： location ^~ /t/ { alias /www/root/html/new_t/; location ^~ /t/ { alias /www/root/html/new_t/; } 如果一个请求的URI是/t/a.html时，web服务器将会返回服务器上的/www/root/html/new_t/a.html的文件。 注意这里是new_t，因为alias会把location后面配置的路径丢弃掉，把当前匹配到的目录指向到指定的目录。 注意： 1. 使用alias时，目录名后面一定要加&quot;/&quot;。 3. alias在使用正则匹配时，必须捕捉要匹配的内容并在指定的内容处使用。 4. alias只能位于location块中。（root可以不放在location中） &gt; http://www.nginx.cn/4658.html]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac相关]]></title>
    <url>%2F2017%2F12%2F18%2Fmac%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[launchpad显示数量修改调整Launchpad每列显示的数量： defaults write com.apple.dock springboard-rows -int 8 调整Launchpad每行显示的数量： defaults write com.apple.dock springboard-columns -int 7 重置Dock和Launchpad： defaults write com.apple.dock ResetLaunchPad -bool TRUE;killall Dock 恢复默认： defaults write com.apple.dock springboard-rows Default defaults write com.apple.dock springboard-columns Default killall Dock alfred访问通讯录提醒关闭 手动签名即可 sudo codesign -f -d -s - /Applications/Alfred\ 3.app/Contents/Frameworks/Alfred\ Framework.framework/Versions/A/Alfred\ Framework http://blog.csdn.net/leiflyy/article/details/78489638 macOS安装未知来源 命令 macOS sierra在安全与隐私中默认并没有 任何来源 选项安装软件，所以对于破解软件来说，可能会报软件包损坏，导致无法安装破解软件。 执行命令开启即可： sudo spctl --master-disable mac下intellij IDEA运行某些项目dock栏出现java小窗口 gui隐藏方法 在IDEA的tomcat配置页面的VM options选项中填写下列参数： -Djava.awt.headless=true 这破玩意为什么会弹出来 http://blog.csdn.net/chs007chs/article/details/52291003 macos下apache apche so模块位置 /usr/libexec/apache2/ apache conf位置 /etc/apache2/httpd.conf macOS启动apache sudo apachectl start mac自带高清壁纸 位置 /Library/Screen Savers/Default Collections/ 免费svnx下载地址 地址 https://code.google.com/archive/p/svnx/downloads mac high sierra下字体模糊defaults -currentHost write -globalDomain AppleFontSmoothing -int 1 mac下出现xcrun: error导致svn无法使用的解决办法xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun 执行命令: xcode-select --install mac磁盘索引sudo mdutil -a -i on 软件提示”文件损坏，无法打开“打开终端； 输入以下命令，回车； sudo xattr -d com.apple.quarantine /Applications/xxxx.app 注意：/Applications/xxxx.app 换成你的App路径（推荐直接将.app文件拖入终端中自动生成路径，以防空格等转义字符手动复制或输入出现错误） 重启App即可。]]></content>
      <tags>
        <tag>mac相关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础]]></title>
    <url>%2F2017%2F12%2F14%2FPython%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Python基础 脚本第一行 #!/usr/bin/env python与#!/usr/bin/python的区别 脚本语言的第一行，目的就是指出，你想要你的这个文件中的代码用什么可执行程序去运行它。 #!/usr/bin/python是告诉操作系统执行这个脚本的时候，调用/usr/bin下的python解释器； #!/usr/bin/env python这种用法是为了防止操作系统用户没有将python装在默认的/usr/bin路径里。 当系统看到这一行的时候，首先会到env设置里查找python的安装路径，再调用对应路径下的解释器程序完成操作。 #!/usr/bin/python相当于写死了python路径; #!/usr/bin/env python会去环境设置寻找python目录,推荐这种写法 http://blog.csdn.net/wh_19910525/article/details/8040494]]></content>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html转Docset]]></title>
    <url>%2F2017%2F12%2F13%2Fmac%E4%B8%8Bhtml%E8%BD%ACDocset%2F</url>
    <content type="text"><![CDATA[软件使用 安装Python macOS自带python,这里就不需要再安装了。 安装beautifulsoup4.3.2 下载地址 https://pypi.python.org/pypi/beautifulsoup4/4.3.2 解压下载好的beautifulsoup4-4.3.2.tar.gz 然后终端进入beautifulsoup4-4.3.2文件夹 执行安装命令： sudo python setup.py install 下载html2Dash 下载地址 https://github.com/xuelangZF/html2Dash#fork-destination-box html转Docset 材料清单 准备好的需要转为docset的网页（需要有一个名为index.html的网页） html2Dash工具 转换命令 ./html2dash.py /Users/ux/0_API/linux 注： /Users/ux/0_API/linux 是需要转换为docset的网页的文件夹路径 作者原文档 The full usage is: $ doc2dash [OPTIONS] SOURCE The `SOURCE` is a directory containing the HTML documents you would like to convert. Valid `OPTIONS` are the following: * -n, --name Name the docset explicitly instead of letting doc2dash guess the correct name from the directory name of the source. * -d PATH, --destination PATH Put the resulting docset into PATH. Default is the directory `~/Library/Application Support/html2dash/DocSets` * -i FILENAME, --icon FILENAME Add PNG icon FILENAME to docset that is used within Dash.app to represent the docset. * -p INDEX_PAGE, --index-page INDEX_PAGE Set the file that is shown when the docset is clicked within Dash.app. * -h, --help Show a brief usage summary and exit. DEPENDENCIES: * BeautifulSoup HTML parsing library 参考链接 链接 https://segmentfault.com/a/1190000000721142http://selfboot.cn/2014/10/13/html2dash/https://github.com/xuelangZF/html2Dash#fork-destination-box]]></content>
      <tags>
        <tag>Docset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows下安装apache2.4]]></title>
    <url>%2F2017%2F12%2F12%2Fwindows%E4%B8%8B%E5%AE%89%E8%A3%85apache2-4%2F</url>
    <content type="text"><![CDATA[Windows下安装apache2.4软件准备 apache2.4下载 http://httpd.apache.org/download.cgi 找到Files for Microsoft Windows找到Apache Lounge， 先下载安装vc_redist_x64 or vc_redist_x86 再下载httpd-2.4.28-Win64-VC15.zip 或httpd-2.4.28-Win32-VC15.zip 创建工作目录 创建目录结构 D盘建立文件夹Apache24 安装apache2.4 解压httpd-2.4.28-Win64-VC15.zip放置到Apache24下 打开Apache24\conf\httpd.conf 搜索并替换全部c:/Apache24为d:/Apache24 安装apache2.4 cmd管理员下执行 cd D:\Apache24\bin httpd.exe -k install -n apache2.4 卸载命令是sc delete apache2.4 安装完成，执行Apache24\bin\ApacheMonitor.exe，右键&gt;start，启动apache2.4,浏览器输入localhost出现 it works! 则表明apache正常运行。]]></content>
      <tags>
        <tag>apache2.4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac下远程Linux]]></title>
    <url>%2F2017%2F12%2F06%2Fmac%E4%B8%8B%E8%BF%9C%E7%A8%8BLinux%2F</url>
    <content type="text"><![CDATA[MAC本地SSH macos开启ssh 在MacOS输入命令ssh localhost得到 ssh: connect to host localhost port 22: Connection refused 解决方法是选择系统偏好设置-&gt;选择共享-&gt;点击远程登录 查看SSH状态 查看ssh是否正常运行 ps -e | grep ssh 或者 ssh localhost 如果没有运行则运行(linux) service sshd start 端口号 SSH默认端口号：22 修改Linux默认SSH端口号 修改Linux的SSH端口 Linux中，SSH配置文件一般在 /etc/ssh/ ssh_config 文件就是其配置文件，找到port，去掉注释，修改22为其他端口 重启SSH： /etc/rc.d/init.d/sshd restart 或者 service sshd restart SSH远程登录命令 远程登录命令格式 ssh root@10.210.100.100 or: ssh -p 端口号 root@10.210.100.100 登出 exit 通过SCP传文件到远程服务器 传文件格式： scp ~/local/file user@remote:~/file 示例： scp ~/测试文件.zip root@10.210.100.100:/home/ux/Desktop/ scp -P 26716 /Users/ux/Downloads/test.zip root@173.91.221.111:/mysoft/ 左边是本机要上传文件地址：~/测试文件.zip 右边是远程机器用户名ip和要上传到的路径：root@10.210.100.100:/home/ux/Desktop/ 带端口 scp -P 22 /Users/ux/Downloads/MySQL.tar root@121。233.122.111 通过SCP从远程服务器复制文件到本地 复制文件到本地 scp ux@10.223.50.1:/usr/local/nginx/conf/nginx.conf /Users/ux/Downloads 从远程服务器10.223.50.1的/usr/local/nginx/conf/目录下复制nginx.conf到本机的Users/ux/Downloads 文件夹下]]></content>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shiro]]></title>
    <url>%2F2017%2F12%2F05%2Fshiro%2F</url>
    <content type="text"><![CDATA[shiro认证的主要过程 通过apache shiro处理用户认证和权限问题 首先需要自己编写UserRealm类并继承Realm，用以实现认证和授权操作 身份认证 /** * 验证当前登录的用户 * * @param authenticationToken * @return * @throws AuthenticationException */ protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException { // 获取需要验证的用户名 String userName = (String) authenticationToken.getPrincipal(); //authenticationToken.getCredentials();//凭证信息，即：密码 // 查询数据库中是否存在该用户名 User user = this.userService.getUserByUserName(userName); if (user != null) { // 存在,则为该用户授予角色和权限 AuthenticationInfo authcInfo = new SimpleAuthenticationInfo(user.getUserName(), user.getPassword(), &quot;xx&quot;); return authcInfo; } // 不存在 return null; } 权限控制 /** * 为当前登录的用户授予角色和权限 * * @param principalCollection * @return */ protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) { // 获取需要授权的用户名 String userName = (String) principalCollection.getPrimaryPrincipal(); // 创建授权对象 SimpleAuthorizationInfo authzInfo = new SimpleAuthorizationInfo(); // 查询当前用户名角色并授权 authzInfo.setRoles(this.userService.getRolesByUserName(userName)); // 查询当前用户名权限并授权 authzInfo.setStringPermissions(this.userService.getPermissionByUserName(userName)); return authzInfo; } controller中对应的代码 @RequestMapping(&quot;/login&quot;) public String login(User user, HttpServletRequest request) { // 获取subject对象 Subject subject = SecurityUtils.getSubject(); // 实例化用户名密码令牌 UsernamePasswordToken token = new UsernamePasswordToken(user.getUserName(), user.getPassword()); //token.setRememberMe(false); try { // 使用subject对象进行登陆 subject.login(token); // 获取session Session session = subject.getSession(); // 输出session //System.out.println(&quot;sessionId:&quot; + session.getId() + &quot;;sessionHost:&quot; + session.getHost() + &quot;;sessionTimeout:%s&quot; + session.getTimeout()); session.setAttribute(&quot;info&quot;, &quot;session的数据&quot;); return &quot;redirect:success&quot;; } catch (Exception e) { // 验证失败 e.printStackTrace(); request.setAttribute(&quot;user&quot;, user); request.setAttribute(&quot;errorMsg&quot;, &quot;用户名或密码错误&quot;); return &quot;login&quot;; } } 参考链接 http://blog.csdn.net/sinat_35767703/article/details/67633186 http://blog.csdn.net/he90227/article/details/38663553 shiro框架下获取当前登录用户名 获取用户名（后端） //当前登录用户ID String loginuser = (String)SecurityUtils.getSubject().getPrincipal(); 获取用户名（前端） 引入标签 &lt;%@ taglib prefix=&quot;shiro&quot; uri=&quot;http://shiro.apache.org/tags&quot; %&gt; &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; &lt;%@ page isELIgnored=&quot;false&quot; %&gt;&lt;%--开启EL表达式--%&gt; 使用shiro标签获取当前登录用户 &lt;shiro:principal/&gt; shiro+ssm中遇到的问题 shiro+ssm在jdk7下正常启动运行，在jdk6下无法启动运行： 控制台错误日志： org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;shiroFilter&apos; defined in class path resource [spring-mybatis.xml]: BeanPostProcessor before instantiation of bean failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor#0&apos; defined in class path resource [spring-mybatis.xml]: Cannot resolve reference to bean &apos;securityManager&apos; while setting bean property &apos;securityManager&apos;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;securityManager&apos; defined in class path resource [spring-mybatis.xml]: ........ 在控制台搜索error还可以找到以下关键信息： Caused by: java.lang.UnsupportedClassVersionError: org/aspectj/weaver/tools/PointcutDesignatorHandler : Unsupported major.minor version 51.0 (unable to load class org.aspectj.weaver.tools.PointcutDesignatorHandler) 由这段错误信息可以知道，aspectj没有被正确加载加载，原因是该版本不被支持，在pom.xml文件中找到aspectj： &lt;!-- aspectjweaver --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.10&lt;/version&gt; &lt;/dependency&gt; Unsupported major.minor version 51.0错误提示的原因： 这段错误提示的根本原因是我们使用低版本的 JRE 去运行高版本 JDK 编译的 class 文件！，51是jdk7]]></content>
      <tags>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EL表达式]]></title>
    <url>%2F2017%2F12%2F05%2FEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[EL表达式概念 EL表达式概念 JSTL一般要配合EL表达式一起使用,来实现在jsp中不出现java代码段。所以我们先来学习EL表达式 EL（Expression Language）表达式语言：用于计算和输出存储在标志位置（page、request、session、application）的java对象的值,然后对它们执行简单操作；EL是JSP2.0规范的一部分，只要容器支持Servlet2.4/JSP2.0，就可以在JSP2.0网页中直接使用EL。通常与 JSTL 标记一起作用，能用简单而又方便的符号来表示复杂的行为。 EL表达式使用 开启和关闭EL表达式 开启 在servlet2.4之后默认方法为false，即可以不写或写成 &lt;%@ page isELIgnored=&quot;false&quot; %&gt; 关闭 &lt;%@ page isELIgnored=&quot;true&quot; %&gt; 还有一种批量禁用EL的方法，可以在WEB-INF/web.xml中使用jsp-property-group标签批量禁用el，web.xml中进行如下配置 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd&quot; version=&quot;2.4&quot;&gt; &lt;jsp-config&gt; &lt;jsp-property-group&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;el-ignored&gt;true&lt;/el-ignored&gt; &lt;/jsp-property-group&gt; &lt;/jsp-config&gt; &lt;/web-app&gt; EL基本格式 EL表达式的格式：用美元符号（$）定界,内容包括在花括号（{}）中; ${} 用法：这是一个EL表达式取值的方法. 例如: 点号记法：${BeanName.beanProperty} 数组记法：${BeanName[“beanProperty”]} 此外，您可以将多个表达式与静态文本组合在一起以通过字符串并置来构造动态属性值; 例如: Hello {loginInfoBean.suser} ${loginInfoBean.spwd} EL作用域的默认顺序 使用EL的时候，默认会以一定顺序（page、request、session、application）搜索四个作用域，将最先找到的变量值显示出来 名称 作用域 page 在当前页面有效 request 在当前请求中有效 session 在当前会话中有效 application 在所有应用程序中有效 http://blog.csdn.net/zycgod/article/details/44408459 EL存取器 存取器用来检索对象的特性或集合的元素。存取器: 通过 “[]” 或 “.” 符号获取相关数据 例: //获取输出bean中的suser属性值; ${userBean.suser} 或 ${userBean[“suser”]} //获取map中key为id对应的值; ${mcType[“id”]} EL运算符 和 EL隐藏对象 参考本文末尾处的链接 参考链接： http://blog.csdn.net/u010168160/article/details/49182867]]></content>
      <tags>
        <tag>EL表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA下mapper.xml颜色]]></title>
    <url>%2F2017%2F12%2F05%2FIDEA%E4%B8%8Bmapper-xml%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[解决在Intellij IDEA下使用ssm框架时，mapper.xml文件显示黄色色块问题 解决方法 将文件头的 &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; 改为： &quot;http://Mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; 或者： &quot;http://mybatis.org/dtd/mybatis-3-Mapper.dtd&quot;&gt; 这样改不会影响项目正常运行，而且会消除mapper.xml文件色块问题。]]></content>
      <tags>
        <tag>IDEA</tag>
        <tag>mapper.xml颜色问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac下配置多jdk]]></title>
    <url>%2F2017%2F11%2F30%2Fmac%E4%B8%8B%E9%85%8D%E7%BD%AE%E5%A4%9Ajdk%2F</url>
    <content type="text"><![CDATA[安装jdk jdk下载 jdk1.7和jdk1.8可以直接在oracle官网下载，jdk1.6有苹果维护，所以需要在苹果官网下载dmg版本的文件。 jdk1.7/jdk1.8下载地址 http://www.oracle.com/technetwork/java/javase/archive-139210.html jdk1.6下载地址(苹果官方)，亲测macOS sierra可用 https://support.apple.com/kb/DL1572?locale=en_US&amp;viewlocale=en_US 安装 下载的dmg文件直接点击安装即可。默认安装位置在: 资源库/Java/JavaVirtualMachines下，多个版本都在这个目录下。 英文路径是: /Library/Java/JavaVirtualMachines/ 在这个目录下，可用看到安装的jdk1.6,jdk1.7,jdk1.8: UXdeMacPro:~ ux$ cd /Library/java/JavaVirtualMachines/ UXdeMacPro:JavaVirtualMachines ux$ ls 1.6.0.jdk jdk1.7.0_80.jdk jdk1.8.0_144.jdk 设置版本切换 terminal&gt; cd ~ ls -a 查看有没有.bash_profile隐藏文件，如果没有，则创建，有则修改即可： vim . bash_profile 按下i键进入编辑模式， 粘贴以下内容： # 设置 JDK 6 export JAVA_6_HOME=`/usr/libexec/java_home -v 1.6` # 设置 JDK 7 export JAVA_7_HOME=`/usr/libexec/java_home -v 1.7.0_80` # 设置 JDK 8 export JAVA_8_HOME=`/usr/libexec/java_home -v 1.8.0_144` # 可添加其他版本。。 #默认JDK 7 export JAVA_HOME=$JAVA_7_HOME #alias命令动态切换JDK版本 alias jdk6=&quot;export JAVA_HOME=$JAVA_6_HOME&quot; alias jdk7=&quot;export JAVA_HOME=$JAVA_7_HOME&quot; alias jdk8=&quot;export JAVA_HOME=$JAVA_8_HOME&quot; 保存 按下esc按键，在输入:wq即可。如果提示权限不够，如果提示权限不够，则放弃保存，以root 权限操作即可 sudo vim .bash_profile,然后进行编辑。 保存完 .bash_profile文件后，在terminal执行命令： source ~/.bash_profile 使配置文件生效。 之后再执行 jdk6或者jdk7或者jdk8进行版本切换： XdeMacBook-Pro:~ ux$ jdk6 UXdeMacPro:~ ux$ java -version java version &quot;1.6.0_65&quot; Java(TM) SE Runtime Environment (build 1.6.0_65-b14-468) Java HotSpot(TM) 64-Bit Server VM (build 20.65-b04-468, mixed mode) UXdeMacPro:~ ux$ javac -version javac 1.6.0_65 UXdeMacPro:~ ux$ jdk7 UXdeMacPro:~ ux$ java -version java version &quot;1.7.0_80&quot; Java(TM) SE Runtime Environment (build 1.7.0_80-b15) Java HotSpot(TM) 64-Bit Server VM (build 24.80-b11, mixed mode) UXdeMacPro:~ ux$ javac -version javac 1.7.0_80 随着这样切换可以在终端有效，但是重新打开终端，显示的还是默认的jdk1.7,所以貌似还要手动修改. bash_profile文件设置默认jdk。。。 如果不想以命令行的方式设置.bash_profile配置文件，则可以进入terminal， cd ~ ls -a 如果没有.bash_profile文件，则创建： touch .bash_profile 然后关闭terminal，打开文件管理器Finder,按下command+shift+.组合键， 显示隐藏文件，进入 用户/ux/ 即可看到.bash_profile文件，以文本方式打开编辑保存即可。(注意：我的电脑用户名是ux,所以是进入 用户/ux/ 文件夹下。) 最后在terminal执行： source ~/.bash_profile]]></content>
      <tags>
        <tag>mac下多版本jdk配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac连接数据库的代替方案]]></title>
    <url>%2F2017%2F11%2F29%2Fmac%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BB%A3%E6%9B%BF%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[代替工具 工具 Intellij IDEA 使用方式 IDEA工具栏&gt; View&gt;Tool windows&gt;Database 调出数据库连接界面。 点击+号，选择数据库类型，如图： 填写数据库用户名，密码，url,点击下载相应的数据库驱动。 点击test connection 测试成功则表明连接成功，保存信息即可，测试结果如果失败，则表明信息不对， 核查用户名，密码，url重新测试连接。如图： 数据库url填写参考 mysql： jdbc:mysql://localhost:3306 驱动类型：MySql DB2(该数据库在Windows服务器上): jdbc:db2://192.168.1.99:50000/tradecc 驱动类型:DB2(LUW) (具体详见本地lib包：IDEA连接数据库)]]></content>
      <tags>
        <tag>mac下连接数据库代替方案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[svn]]></title>
    <url>%2F2017%2F11%2F29%2Fsvn%2F</url>
    <content type="text"><![CDATA[下载链接 macOS下的svn客户端svnx下载链接(免费)： https://code.google.com/archive/p/svnx/downloads 注意：这里说的svn和svn客户端是不同的东西。 macos下的svn 参考文章： http://blog.csdn.net/bruce128/article/details/52652230 macos下的svn貌似是系统自带的如果系统中没有，需要安装XCode,然后安装Command Line Tools svn命令 查看svn版本： terminal运行 svn --version 检出项目： 在terminal命令行工具，进入想要将文件检出到的文件夹，执行： svn co url 该url是svn中项目地址。 然后会提示输入用户名和密码。 提交什么的就交给svnx客户端吧。 windows下svn客户端tortoisesvn无法日志问题 log message offline只显示离线日志 右键&gt; tortoisesvn&gt;settings&gt;saved Data&gt;clear http://blog.csdn.net/baikeliang/article/details/49280753]]></content>
      <tags>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows下安装weblogic]]></title>
    <url>%2F2017%2F11%2F28%2Fwindows%E4%B8%8B%E5%AE%89%E8%A3%85weblogic%2F</url>
    <content type="text"><![CDATA[下载weblogic安装包 下载地址 http://www.oracle.com/technetwork/cn/middleware/ias/downloads/wls-main-091116-zhs.html 本例以下载安装 Oracle WebLogic Server 10.3.6 通用 (997 MB)包为例。 安装jdk 安装jdk 安装weblogic前需要先安装JDK，本次以jdk1.7，64位版本为例子。 安装weblogic 开始安装weblogic 将wls1036_generic.jar复制到jdk安装路径的bin目录下 如：C:\mysoft\Java7x64\jdk1.7.0_80\bin 然后打开cmd(管理员权限)，cd C:\mysoft\Java7x64\jdk1.7.0_80\bin 然后执行命令： Java -jar wls1036_generic.jar 等待weblogic界面的出现，一步步安装即可。 部署程序 部署应用程序 运行weblogic服务，打开console,登录weblogic服务，选择 部署&gt;安装&gt;选择要部署的程序包，完成，即可。weblogic默认端口7001。 （注：该部署方式是路径引用） 参考文章 参考链接 https://jingyan.baidu.com/article/59a015e3568379f795886567.html Apache配置weblogic模块相关 https://docs.oracle.com/cd/E21764_01/web.1111/e16435/apache.htm#PLGWL407 附件 weblogic wls1036_generic.jar包 网盘链接 链接:https://pan.baidu.com/s/1bINsAi 密码:bwfx]]></content>
      <tags>
        <tag>windows下安装weblogic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下配置apache-weblogic负载均衡+https]]></title>
    <url>%2F2017%2F11%2F27%2Flinux%E4%B8%8B%E9%85%8D%E7%BD%AEapache-weblogic%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-https%2F</url>
    <content type="text"><![CDATA[加载所需要的模块（httpd.conf文件中） 所需模块清单 LoadModule lbmethod_bybusyness_module modules/mod_lbmethod_bybusyness.so LoadModule proxy_module modules/mod_proxy.so LoadModule proxy_ajp_module modules/mod_proxy_ajp.so LoadModule proxy_balancer_module modules/mod_proxy_balancer.so LoadModule proxy_http_module modules/mod_proxy_http.so LoadModule rewrite_module modules/mod_rewrite.so LoadModule slotmem_shm_module modules/mod_slotmem_shm.so LoadModule socache_shmcb_module modules/mod_socache_shmcb.so #ssl模块 LoadModule ssl_module modules/mod_ssl.so #weblogic模块 LoadModule weblogic_module modules/mod_wl_24.so apache-weblogic负载均衡（httpd.conf文件中） 在LoadModule weblogic_module modules/mod_wl_24.so下方添加以下配置即可： &lt;IfModule mod_weblogic.c&gt; ###多台weblogic改成相应的ip即可，这里用两个相同的服务器地址暂代。 WeblogicCluster 10.211.55.3:7001,10.211.55.3:7001 MatchExpression * #WLLogFile &quot;/home/ux/Desktop/apache2.log&quot; #Debug On #DebugConfigInfo On KeepAliveEnabled On KeepAliveSecs 15 &lt;/IfModule&gt; 注：注释掉的视情况开启。 引入SSL配置文件（httpd.conf文件中） 引入httpd-ssl.conf 找到： # Secure (SSL/TLS) connections #Include conf/extra/httpd-ssl.conf 改为： # Secure (SSL/TLS) connections Include conf/extra/httpd-ssl.conf 自动跳转https(httpd.conf文件中) http自动跳转https 找到ServerName，将Rewrite规则写在其下面即可： ###### ServerName www.aa.com:80 RewriteEngine on RewriteCond %{SERVER_PORT} !^443$ RewriteRule ^(.*)?$ https://%{SERVER_NAME}$1 [L,R=301] 修改httpd-ssl.conf文件 修改ServerName 找到： &lt;VirtualHost _default_:443&gt; 将ServerName改为自己的域名，例如： ServerName www.aa.com:443 配置证书 打开httpd-ssl.conf看到， SSLCertificateFile “/usr/local/apache2/conf/server.crt” SSLCertificateKeyFile “/usr/local/apache2/conf/server.key” #SSLCACertificateFile “/usr/local/apache2/conf/ssl.crt/ca-bundle.crt” 前两个已经默认被加载，后一个需要我们手动加载，去掉注释即可。 所需模块文件获取方式（注：实验机器为centos7 64位） mod_ssl.so： sudo yum install -y mod_ssl 安装完成后我们可以看到mod_ssl的配置文件/etc/httpd/modules/下找到mod_ssl.so文件 mod_wl_24.so： 百度下载的.... 文件包： 链接:http://pan.baidu.com/s/1gfxo77P 密码:cy47 参考链接 http://blog.csdn.net/qq229596421/article/details/51789872 负载均衡其他配置方式 URL分发 &lt;IfModule mod_weblogic.c&gt; WebLogicCluster johndoe02：8005，johndoe：8006 调试打开 WLLogFile c：/tmp/global_proxy.log WLTempDir“c：/ myTemp” DebugConfigInfo On KeepAliveEnabled打开 KeepAliveSecs 15 &lt;/ IfModule&gt;配置 SetHandler weblogic-handler WebLogicCluster agarwalp01：7001 &lt;/位置&gt; SetHandler weblogic-handler PathTrim /web 调试关闭 WLLogFile c：/tmp/web_log.log &lt;/位置&gt; SetHandler weblogic-handler PathTrim /foo 调试错误 WLLogFile c：/tmp/foo_proxy.log &lt;/位置&gt; 所有匹配/ jurl / 的请求都将调试级别设置为ALL，并且日志消息将被记录到c:/tmp/global_proxy.log文件中。 所有匹配/ web / 的请求都将设置为“关闭”调试级别，并且不会记录日志消息。 所有匹配/ foo / *的请求都将调试级别设置为ERR，并且日志消息将被记录到c:/tmp/foo_proxy.log文件中。 Oracle建议您使用该MatchExpression语句而不是块。 https下让浏览器自动将HTTP资源升级为HTTPS 在apache的httpd.conf中添加如下配置 找到加载模块代码，并去掉注释： LoadModule headers_module modules/mod_headers.so 搜索 &lt;IfModule headers_module&gt; 将 &lt;IfModule headers_module&gt; # # Avoid passing HTTP_PROXY environment to CGI&apos;s on this or any proxied # backend servers which have lingering &quot;httpoxy&quot; defects. # &apos;Proxy&apos; request header is undefined by the IETF, not listed by IANA # RequestHeader unset Proxy early &lt;/IfModule&gt; 改为 &lt;IfModule headers_module&gt; # # Avoid passing HTTP_PROXY environment to CGI&apos;s on this or any proxied # backend servers which have lingering &quot;httpoxy&quot; defects. # &apos;Proxy&apos; request header is undefined by the IETF, not listed by IANA # RequestHeader unset Proxy early Header set Content-Security-Policy &quot;upgrade-insecure-requests&quot; &lt;/IfModule&gt; 参考链接 https://www.cnblogs.com/hustskyking/p/upgrade-insecure-requests.htmlhttp://httpd.apache.org/docs/current/mod/mod_headers.html apache完整包 链接:https://pan.baidu.com/s/1mizN7Uo 密码:c4p2]]></content>
      <tags>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下安装apache]]></title>
    <url>%2F2017%2F11%2F27%2Flinux%E4%B8%8B%E5%AE%89%E8%A3%85apache%2F</url>
    <content type="text"><![CDATA[安装包准备 下载APR源码包 http://apr.apache.org 详细地址： http://apr.apache.org/download.cgi 下载APR-Util源码包 http://apr.apache.org 详细地址： http://apr.apache.org/download.cgi 下载PCRE源码包 http://www.pcre.org 详细地址： https://ftp.pcre.org/pub/pcre/ 下载Apache Server2.4源码包 http://httpd.apache.org/ 详细地址： http://httpd.apache.org/download.cgi#apache24 安装过程 安装unzip yum install -y unzip zip 全部解压 解压命令： gzip -d pcre-8.36.tar.gz tar -xf pcre-8.36.tar 或者 tar xzvf this.tar.gz 安装gcc 无论你是要安装APR、APR-Util、PCRE还是Apache Server或者是其他的一些软件， 总之，只要是源码安装，那么就需要一个ANSI-C编译器。如果你没有，那就用yum装一个吧， 既然推荐使用GCC，那就装个GCC吧。 执行命令：yum install -y gcc 首先安装apr 依次执行命令： cd apr-1.6.3 ./configure sudo make sudo make install 然后安装apr-util 依次执行命令： cd apr-util-1.6.1 ./configure --with-apr=/usr/local/apr sudo make sudo make install 在安装APR-Util时，需要指定APR的安装路径，所以需要带上选项--with-apr=/usr/local/apr，如果你不带上这个选项，在configure的时候会看到下图的错误提示 最后安装pcre 依次执行命令： cd pcre-8.41 在执行./configure时出错，提示configure: error: You need a C++ compiler for C++ support 此时使用yum安装安装gcc-c++： yum install -y gcc gcc-c++ 然后再执行： ./configure sudo make sudo make install 开始安装apache2.4 解压apache源码包 gzip -d httpd-2.4.29.tar.gz tar -xf httpd-2.4.29.tar 依次执行命令： ./configure --enable-mods-shared=all sudo make sudo make install Apache默认安装在/usr/local/apache2目录下。同样，这里你也可以使用 –prefix=目录名 来指定一个安装目录，例如： ./configure --prefix=/usr/mydir --enable-mods-shared=all 启动apache进行测试 启动命令： /usr/local/apache2/bin/apachectl -k start 如果提示以下信息，则是配置文件httpd.conf中的ServerName没有修改： AH00558: httpd: Could not reliably determine the server&apos;s fully qualified domain name, using localhost.localdomain. Set the &apos;ServerName&apos; directive globally to suppress this message 防火墙 开关防火墙 systemctl status firewalld 如果处于running运行状态，就把它关掉： systemctl stop firewalld 然后，查看一下防火墙是否已经关掉： systemctl status firewalld 如果处于dead状态，就说明已经关掉了。 如果你希望每次系统启动的时候都不要启动防火墙，可以执行命令： systemctl disable firewalld 同样，如果你希望每次系统启动的时候都启动防火墙，可以执行命令： systemctl enable firewalld 文件夹权限 刚安装完apache发现普通用户没有apache的写入权限，方便起见，将apache下的所有文件设置为了所有用户可读写： 修改apache2下所有文件权限(777:everyone均可读写)： sudo chmod -R 777 /usr/local/apache2/ 安装过程中可能出现的错误 expat库缺失提示 安装expat库: yum install expat-devel 文件包链接 apache2.4源码包以及依赖源码包 链接:http://pan.baidu.com/s/1jIQUArk 密码:5ccg 参考链接 参考文章（已亲测） https://jingyan.baidu.com/article/7e4409533d7f0f2fc0e2ef91.html]]></content>
      <tags>
        <tag>linux安装apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac下安装mysql]]></title>
    <url>%2F2017%2F11%2F25%2Fmac%E4%B8%8B%E5%AE%89%E8%A3%85mysql%2F</url>
    <content type="text"><![CDATA[下载安装包 下载地址 安装mysql社区版，免费。下载地址： https://dev.mysql.com/downloads/ 下载MySQL Community Server (GPL)版本。 macOS下下载的安装包是dmg格式的。 安装 macOS下安装mysql macOS下的mysql dmg安装包基本就是傻瓜式安装，一路确定即可，但是要注意最后一步的mysql installer弹窗，会提示mysql的root用户的默认密码，抄下即可，方便后续登录root用户以及修改密码。 macOS下启动与关闭mysql服务，可以在 系统偏好设置&gt; 最下边看到mysql图标，点击去即可启动/关闭 mysql服务。 更改字符集 更改默认字符集和密码 mysql默认安装后，会出现中文乱码现象，需要更改字符集设置。 root用户登录mysql，查看字符集信息： show variables like &apos;character%&apos;; 结果类似下面（这是改过字符集设置后的结果） mysql&gt; show variables like &apos;character%&apos;; +--------------------------+-----------------------------------------------------------+ | Variable_name | Value | +--------------------------+-----------------------------------------------------------+ | character_set_client | utf8 | | character_set_connection | utf8 | | character_set_database | utf8 | | character_set_filesystem | binary | | character_set_results | utf8 | | character_set_server | utf8 | | character_set_system | utf8 | | character_sets_dir | /usr/local/mysql-5.7.20-macos10.12-x86_64/share/charsets/ | +--------------------------+-----------------------------------------------------------+ 8 rows in set (0.00 sec) 打开终端，进入/etc，执行ls -a 查看有没有my.cnf文件，没有则创建my.cnf: sudo vim /etc/my.cnf ，输入计算机管理员密码，创建my.cnf文件，并复制 [client] default-character-set=utf8 [mysqld] character-set-server=utf8 按下esc按键，输入:wq保存退出即可。 重启mysql服务，OK。 修改mysql密码 修改root用户密码 mysql –u root 进入mysql update user set password=PASSWORD(‘123456’) where User=&apos;root&apos;; 允许远程访问 允许远程访问mysql mysql -u root –p mysql&gt;use mysql; mysql&gt;update user set host = &apos;%&apos; where user = &apos;root&apos;; 查看结果： mysql&gt;select host, user from user; mac安装完mysql后用随即密码无法登陆，重置密码(20180828) 关闭mysql服务 苹果-&gt;系统偏好设置-&gt;最下边点mysql 在弹出页面中 关闭mysql服务（点击stop mysql server） 关闭密码验证 进入终端输入：cd /usr/local/mysql/bin/ 回车后 登录管理员权限 sudo su 回车后输入以下命令来禁止mysql验证功能 ./mysqld_safe --skip-grant-tables &amp; 回车后mysql会自动重启（偏好设置中mysql的状态会变成running） 设置密码 输入命令 ./mysql 回车后，输入命令 FLUSH PRIVILEGES; 回车后，输入命令 SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos; = PASSWORD(&apos;你的新密码&apos;); 密码修改完成，可以成功登陆。]]></content>
      <tags>
        <tag>macOS下安装mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac下启动tomcat]]></title>
    <url>%2F2017%2F11%2F21%2Fmac%E4%B8%8B%E5%90%AF%E5%8A%A8tomcat%2F</url>
    <content type="text"><![CDATA[下载适用于mac的tomcat mac下的tomcat 百度搜tomcat，到tomcat官网下载zip或者tar.gz tomcat官网： https://tomcat.apache.org/ 安装tomcat 由于下载的是解压版，所有直接解压，放到想要放的目录下即可。 仅仅这样还是不能够启动tomcat的，打开terminal，进入到tomcat/bin 修改.sh文件的执行权限为所有用户读写 sudo chmod 777 *.sh 此时即可启动： sudo sh startup.sh 在IDEA中配置tomcat 这一步骤和Windows下的操作一模一样。]]></content>
      <tags>
        <tag>mac下tomcat启动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac快捷键]]></title>
    <url>%2F2017%2F11%2F20%2Fmac%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[mac快捷键 command相关 Finder： （桌面上）command+N/command+方向键上 新建窗口： （对应的应用中）command+N 保存删除新建拷贝复制文件： 保存：command+S 删除：command+delete 粘贴：command+C 拷贝：command+V 剪切：command+X 复制： （拷贝不包含粘贴，复制是直接粘贴，相当于win下的ctrl+v,ctrl+v连续执行） 新建（文件夹）：command+shift+N 快捷搜索程序： command+空格键 关闭窗口： command+W（关闭窗口） command+Q(彻底关闭程序) 光标位置切换： command+方向键左/右：定位到当前行首/末尾 command+方向键上/下：定位到当前页首/尾 control control+F2：快速定位到左上角菜单栏 control+F3:快速定位到Dock栏 control+F8：快速定位到右上角状态栏 control+F4:快速定位到活跃窗口 control+F5:快速定位到当前窗口的工具框（如输入框等） 以上关于control的组合快捷键在系统偏好&gt;键盘&gt;快捷键&gt;键盘中定义 F1~F12标准功能 mac默认情况F1~F12是多媒体功能，在系统偏好设置&gt;键盘&gt;键盘&gt;勾选&quot;将F1、F2等键用作标准功能&quot;，勾选后，F1~F12就不会影响开发软件下的快捷组合键了。 触摸板 四指向上推：当前运行程序 五指捏/合:所有程序页面打开/关闭 拇指+其余四手指开/合：打开桌面 mac商店 mac商店中的应用有限制，比如网易云音乐，在网易官网下载的和在mac商店下载的对于快捷键的支持是不一样的，网易官网下载的比较好用。 command+option+i chrome浏览器调试界面（win下的f12功能） command+shift+a 打开应用程序文件夹 command+shift+h Chrome浏览器主页 command+L 浏览器地址栏 command+ +/- 放大/缩小 浏览器页面 自带高清壁纸 自带高清壁纸 /Library/Screen Savers/Default Collections/]]></content>
      <tags>
        <tag>mac快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java杂记]]></title>
    <url>%2F2017%2F11%2F03%2Fjava%E6%9D%82%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[字符串截取 字符串路径截取 filename=&quot;2017\11\01\050000001\7b3d73a2e080c2722e1fb6e71be2f0be_aaa2.doc&quot; //截取最后一个反斜杠后面的内容，即：7b3d73a2e080c2722e1fb6e71be2f0be_aaa2.doc String filenameStr = filename.substring(filename.lastIndexOf(&quot;\\&quot;)+1); //截取开头到最后一个反斜杠之间的内容，即：2017\11\01\050000001\ String filePathStr = filename.substring(0,filename.lastIndexOf(&quot;\\&quot;)+1); URL转码解码 //转码 String filenameStr2 = java.net.URLEncoder.encode(filenameStr, &quot;utf-8&quot;); //解码 java.net.URLDecoder.decode(str, ENCODE); 参考网址: http://www.cnblogs.com/haha12/p/4344992.html 重新拼接 //重新拼接 filename = filePathStr+filenameStr2; 反斜杠转正斜杠 //将反斜杠替换为正斜杠 filename.replace(&quot;\\&quot;, &quot;/&quot;)) 字符串年月日时分秒毫秒 //年月日时分秒毫秒 java.text.SimpleDateFormat date = new java.text.SimpleDateFormat(&quot;yyyyMMddHHmmssSS&quot;); String currentTimeMillis = date.format(new Date(System.currentTimeMillis())); 截图文件后缀重新拼接 //fileName=&quot;fjsdfidjfi.swf&quot; String suffix = fileName.substring(fileName.lastIndexOf(&quot;.&quot;)); //拼接得到结果：20171102103140271.swf String newFileName = currentTimeMillis + suffix; Date转时间戳 Date转时间戳 import java.sql.Timestamp; import java.text.SimpleDateFormat; import java.util.Calendar; import java.util.Date; public class Test { public static void main(String[] args) { Timestamp timestamp = new Timestamp((new Date()).getTime()); //System.out.println(&quot;wre:&quot;+timestamp); String s = timestamp.toString(); Timestamp ts = Timestamp.valueOf(s); Calendar c = Calendar.getInstance(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy/MM/dd/HH:mm:ss&quot;);//hh:12小时制，HH小时制度 System.out.println(sdf.format(c.getTime())); } } StringUtils截取字符串 截取 }, 之后的字符串，不包含 }, String str4 = StringUtils.substringAfter(jsonArray.toString(),&quot;},&quot;); 依赖包 import org.apache.commons.lang3.StringUtils; 依赖包maven配置 &lt;!-- commons-lang3 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;/dependency&gt; mybatis参数映射 mybatis参数映射 and h.regist_status = #{hallRegistration.statusLeave,jdbcType=VARCHAR} 字符串替换正则 字符串替换正则 str.replaceAll(“ {2,}”, “ “) yml配置读取 yml配置读取 yml配置读取不到：写在根yml下（application.yml）即可 待续…]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java杂记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SS]]></title>
    <url>%2F2017%2F10%2F17%2FSS%2F</url>
    <content type="text"><![CDATA[SS安装CentOS下shadowsocks-libev一键安装脚本安装步骤关于本脚本： 一键安装 libev 版的 Shadowsocks 一键安装 libev 版的 Shadowsocks 最新版本。该版本的特点是内存占用小（600k左右）， 低 CPU 消耗，甚至可以安装在基于 OpenWRT 的路由器上。 默认配置： 服务器端口： 自己设定（如不设定，默认从 9000-19999 之间随机生成） 密码： 自己设定（如不设定，默认为 teddysun.com） 加密方式： 自己设定（如不设定，默认为 aes-256-gcm） Shadowsocks for Windows 客户端下载： 下载地址 https://github.com/shadowsocks/shadowsocks-windows/releases 安装方法： 使用root用户登录，运行以下命令： wget --no-check-certificate -O shadowsocks-libev.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-libev.sh chmod +x shadowsocks-libev.sh ./shadowsocks-libev.sh 2&gt;&amp;1 | tee shadowsocks-libev.log 安装完成后，脚本提示如下： Congratulations, Shadowsocks-libev server install completed! Your Server IP :your_server_ip Your Server Port :your_server_port Your Password :your_password Your Encryption Method:your_encryption_method Welcome to visit:https://teddysun.com/357.html Enjoy it! 卸载方法： 使用 root 用户登录，运行以下命令： ./shadowsocks-libev.sh uninstall 其他事项： 客户端配置的参考链接： https://teddysun.com/339.html 启动 安装完成后即已后台启动 Shadowsocks-libev ，运行： /etc/init.d/shadowsocks status 可以查看进程是否启动。 本脚本安装完成后，会将 Shadowsocks-libev 加入开机自启动。 使用命令： 命令参考 启动：/etc/init.d/shadowsocks start 停止：/etc/init.d/shadowsocks stop 重启：/etc/init.d/shadowsocks restart 查看状态：/etc/init.d/shadowsocks status 链接 链接 https://teddysun.com/357.html CentOS下 ShadowsocksR 一键安装脚本(vps)安装步骤关于本脚本： 关于脚本 一键安装 ShadowsocksR 服务端。 请下载与之配套的客户端程序来连接。 （以下客户端只有 Windows 客户端和 Python 版客户端可以使用 SSR 新特性，其他原版客户端只能以兼容的方式连接 SSR 服务器） 默认配置： 默认配置 服务器端口：自己设定（如不设定，默认从 9000-19999 之间随机生成） 密码：自己设定（如不设定，默认为 teddysun.com） 加密方式：自己设定（如不设定，默认为 aes-256-cfb） 协议（Protocol）：自己设定（如不设定，默认为 origin） 混淆（obfs）：自己设定（如不设定，默认为 plain） 客户端下载： Windows / OS X https://github.com/shadowsocksrr/shadowsocksr-csharp/releaseshttps://github.com/shadowsocks/shadowsocks-iOS/wiki/Shadowsocks-for-OSX-Help Linux https://github.com/shadowsocks/shadowsocks-qt5 Android / iOS https://github.com/shadowsocks/shadowsocks-androidhttps://github.com/shadowsocks/shadowsocks-iOS/wiki/Help OpenWRT https://github.com/shadowsocks/openwrt-shadowsocks 安装方法： 使用root用户登录，运行以下命令： wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh chmod +x shadowsocksR.sh ./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log 安装完成后，脚本提示如下： 安装完成日志 Congratulations, ShadowsocksR server install completed! Your Server IP :your_server_ip Your Server Port :your_server_port Your Password :your_password Your Protocol :your_protocol Your obfs :your_obfs Your Encryption Method:your_encryption_method Welcome to visit:https://shadowsocks.be/9.html Enjoy it! 卸载方法： 使用 root 用户登录，运行以下命令： ./shadowsocksR.sh uninstall 安装完成后即已后台启动 ShadowsocksR ，运行： 启动程序并开机自启动 /etc/init.d/shadowsocks status 可以查看 ShadowsocksR 进程是否已经启动。 本脚本安装完成后，已将 ShadowsocksR 自动加入开机自启动。 使用命令： 使用命令 启动：/etc/init.d/shadowsocks start 停止：/etc/init.d/shadowsocks stop 重启：/etc/init.d/shadowsocks restart 状态：/etc/init.d/shadowsocks status 配置文件相关 配置文件路径：/etc/shadowsocks.json 日志文件路径：/var/log/shadowsocks.log 代码安装目录：/usr/local/shadowsocks 多用户配置示例： 多用户配置示例 { &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;server_ipv6&quot;: &quot;[::]&quot;, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;port_password&quot;:{ &quot;8989&quot;:&quot;password1&quot;, &quot;8990&quot;:&quot;password2&quot;, &quot;8991&quot;:&quot;password3&quot; }, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;protocol&quot;: &quot;origin&quot;, &quot;protocol_param&quot;: &quot;&quot;, &quot;obfs&quot;: &quot;plain&quot;, &quot;obfs_param&quot;: &quot;&quot;, &quot;redirect&quot;: &quot;&quot;, &quot;dns_ipv6&quot;: false, &quot;fast_open&quot;: false, &quot;workers&quot;: 1 } 如果你想修改配置文件，请参考： 参考 https://github.com/shadowsocksr-backup/shadowsocks-rss/wiki/Server-Setuphttps://github.com/shadowsocksr-backup/shadowsocks-rss/blob/master/ssr.mdhttps://github.com/shadowsocksr-backup/shadowsocks-rss/wiki/config.json 链接 链接 https://shadowsocks.be/9.html]]></content>
      <tags>
        <tag>SS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搬瓦工]]></title>
    <url>%2F2017%2F10%2F17%2F%E6%90%AC%E7%93%A6%E5%B7%A5%2F</url>
    <content type="text"><![CDATA[购买服务器 vps 安装centos6 x64安装shadowsocks 安装shadowsocks https://github.com/teddysun/shadowsocks_install 配置ss多账号 参考文章： http://blog.csdn.net/allfun/article/details/53350214https://github.com/shadowsocks/shadowsocks/wiki/Configure-Multiple-Users 连接centos6服务器 编辑shadowsocks.json文件 vi /etc/shadowsocks.json 注：shadowsocks.json可能不存在，所以搜索不到。 ###配置文件路径（201804新配置） /etc/shadowsocks-python 添加 { &quot;server&quot;: &quot;0.0.0.0&quot;, &quot;port_password&quot;: { &quot;8381&quot;: &quot;foobar1&quot;, &quot;8382&quot;: &quot;foobar2&quot;, &quot;8383&quot;: &quot;foobar3&quot;, &quot;8384&quot;: &quot;foobar4&quot; }, &quot;timeout&quot;: 300, &quot;method&quot;: &quot;aes-256-cfb&quot; } 注： server：服务器IP port_password：自己设定的服务器端口和密码 timeout：超时断开，以秒为单位 method：default: &quot;aes-256-cfb&quot;,加密方式 fast_open：是否使用TCP） 然后按下ESC :(冒号) 输入wq!，回车，就保存了 VI命令 按ESC键 跳到命令模式，然后 :w 保存文件但不退出vi :w file 将修改另外保存到file中，不退出vi :w! 强制保存，不推出vi :wq 保存文件并退出vi :wq! 强制保存文件，并退出vi q: 不保存文件，退出vi :q! 不保存文件，强制退出vi :e! 放弃所有修改，从上次保存文件开始再编辑 启动ss/停止运行ss 开始： ssserver -c /etc/shadowsocks.json -d start 结束： ssserver -c /etc/shadowsocks.json -d stop SSH端口修改 安装完centos后默认SSH端口并不是22，可以进行SSH端口修改 vi /etc/ssh/sshd_config 修改为： Port 300000 修改好后，执行下面命令重启SSH。 /etc/init.d/sshd restart 防火墙 防火墙 service iptables status #查看防火墙状态 service iptables restart #重启防火墙 service iptables save #保存 提示防火墙模块未加载 modprobe ip_tables #加载ip_tables模块 modprobe iptable_filter #加载iptable_filter模块 lsmod | grep iptable #查看模块，有模块即解决了 防火墙规则 命令模式修改防火墙： iptables -F #清理iptables规则 #允许4400端口 iptables -A INPUT -p tcp --dport 4400 -j ACCEPT iptables -A OUTPUT -p tcp --sport 4400 -j ACCEPT # 允许本地回环 127.0.0.1 iptables -A INPUT -i lo -p all -j ACCEPT 或直接修改防火墙规则文件： vi /etc/sysconfig/iptables 保存 service iptables save 关闭防火墙 1） 永久性生效，重启后不会复原 开启： chkconfig iptables on 关闭： chkconfig iptables off 2） 即时生效，重启后复原 开启： service iptables start 关闭： service iptables stop 查看防火墙状态（哪些端口在规则里）： service iptables status iptables文件 nl /etc/sysconfig/iptables]]></content>
      <tags>
        <tag>搬瓦工vps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[apache+tomcat实现负载均衡https]]></title>
    <url>%2F2017%2F10%2F12%2Fwindows%E4%B8%8Bapache%2Btomcat%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1https%2F</url>
    <content type="text"><![CDATA[apache2.4+tomcat6实现负载均衡（windows版本）软件准备 apache2.4下载 http://httpd.apache.org/download.cgi找到Files for Microsoft Windows找到Apache Lounge，先下载安装vc_redist_x64 or vc_redist_x86再下载httpd-2.4.28-Win64-VC15.zip 或httpd-2.4.28-Win32-VC15.zip tomcat6/7下载 tomcat6 http://archive.apache.org/dist/tomcat/tomcat-6/v6.0.29/bin/ 下载apache-tomcat-6.0.29-windows-x64.zip tomcat7 https://tomcat.apache.org/download-70.cgi 下载7.0.82 64-bit Windows zip (pgp, md5, sha1) 创建工作目录 创建目录结构 D盘建立文件夹Apache24和tomcats tomcats下分别建tomcat1和tomcat2文件夹 安装apache2.4 解压httpd-2.4.28-Win64-VC15.zip放置到Apache24下 打开Apache24\conf\httpd.conf 搜索并替换全部c:/Apache24为d:/Apache24 安装apache2.4 cmd管理员下执行 cd D:\Apache24\bin httpd.exe -k install -n apache2.4 卸载命令是sc delete apache2.4 安装完成，执行Apache24\bin\ApacheMonitor.exe，右键&gt;start，启动apache2.4,浏览器输入localhost出现 it works! 则表明apache正常运行。 安装tomcat6 将tomcat6解压并复制到tomcat1和tomcat2两个文件夹中（两个文件夹中的tomcat是一样的） 依次打开tomcat/bin/startup.bat,浏览器地址栏输入localhost:8080,出现tomcat界面，则表明tomcat正常运行。 Apache2.4和tomcat负载均衡配置 配置Apache24\conf\httpd.conf 去掉以下7个模块前的#注释： LoadModule proxy_module modules/mod_proxy.so LoadModule proxy_ajp_module modules/mod_proxy_ajp.so LoadModule proxy_balancer_module modules/mod_proxy_balancer.so LoadModule proxy_http_module modules/mod_proxy_http.so LoadModule slotmem_shm_module modules/mod_slotmem_shm.so LoadModule socache_shmcb_module modules/mod_socache_shmcb.so LoadModule lbmethod_byrequests_module modules/mod_lbmethod_byrequests.so --------------------------------------------------------------------- 找到(279行)： &lt;IfModule dir_module&gt; DirectoryIndex index.html &lt;/IfModule&gt; 修改成 &lt;IfModule dir_module&gt; DirectoryIndex index.html index.jsp &lt;/IfModule&gt; ---------------------------------------------------------------------- 文件最后添加(稍后tomcat里会做相关配置192.168.202在这里是本机ip，所以也可以写成127.0.0.1)： #ProxyRequests Off &lt;proxy balancer://cluster&gt; BalancerMember ajp://192.168.202.1:8011 loadfactor=1 route=tomcat1 BalancerMember ajp://192.168.202.1:8012 loadfactor=1 route=tomcat2 &lt;/proxy&gt; ------------------------------------------------------------------------ # Virtual hosts #Include conf/extra/httpd-vhosts.conf 改为 # Virtual hosts Include conf/extra/httpd-vhosts.conf httpd-vhosts.conf设置 打开Apache24\conf\extra\httpd-vhosts.conf（请提前做好备份，以便配置错误时可以恢复） 注释掉原有的&lt;VirtualHost *:80&gt;&lt;/VirtualHost&gt;两个代码块。 添加 &lt;VirtualHost *:80&gt; ServerAdmin webmaster@aa.com ServerName www.aa.com ServerAlias www.aa.com ProxyPass / balancer://cluster/ stickysession=JSESSIONID|jsessionid nofailover=On ProxyPassReverse / balancer://cluster/ &lt;/VirtualHost&gt; ServerName www.aa.com可以通过修改windows的host文件来伪装。 host文件位置： C:\Windows\System32\drivers\etc\host 最后面添加 127.0.0.1 www.aa.com 配置tomcat1和tomcat2 打开tomcat server.xml tomcats\tomcat1\conf\server.xml 找到&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt; 将tomcat1的port改为8006，tomcat的port改为8007 -------------------------------------------------- 找到： &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 将8080改为8081，tomcat2的改为8082 ------------------------------------------------------- 找到 &lt;Connector port=&quot;8011&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt; 将8009改为8011，tomcat2的改为8012 (和apache中配置的对应： BalancerMember ajp://192.168.202.1:8011 loadfactor=1 route=tomcat1 BalancerMember ajp://192.168.202.1:8012 loadfactor=1 route=tomcat2 ) ----------------------------------------------------------- 找到： &lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt; 改为： &lt;Engine name=&quot;Standalone&quot; defaultHost=&quot;localhost&quot; jvmRoute=&quot;tomcat1&quot;&gt; tomcat2中的改为： &lt;Engine name=&quot;Standalone&quot; defaultHost=&quot;localhost&quot; jvmRoute=&quot;tomcat2&quot;&gt; 这里同样时和 BalancerMember ajp://192.168.202.1:8011 loadfactor=1 route=tomcat1 BalancerMember ajp://192.168.202.1:8012 loadfactor=1 route=tomcat2 对应的。 ----------------------------------------------------------------- 找到 &lt;!-- &lt;Cluster className=&quot;org.apache.catalina.ha.tcp.SimpleTcpCluster&quot;/&gt; --&gt; 在其下方添加 &lt;Cluster className=&quot;org.apache.catalina.ha.tcp.SimpleTcpCluster&quot; channelSendOptions=&quot;6&quot;&gt; &lt;Manager className=&quot;org.apache.catalina.ha.session.BackupManager&quot; expireSessionsOnShutdown=&quot;false&quot; notifyListenersOnReplication=&quot;true&quot; mapSendOptions=&quot;6&quot;/&gt; &lt;Channel className=&quot;org.apache.catalina.tribes.group.GroupChannel&quot;&gt; &lt;Membership className=&quot;org.apache.catalina.tribes.membership.McastService&quot; address=&quot;228.0.0.4&quot; port=&quot;45564&quot; frequency=&quot;500&quot; dropTime=&quot;3000&quot;/&gt; &lt;Receiver className=&quot;org.apache.catalina.tribes.transport.nio.NioReceiver&quot; address=&quot;auto&quot; port=&quot;5001&quot; selectorTimeout=&quot;100&quot; maxThreads=&quot;6&quot;/&gt; &lt;Sender className=&quot;org.apache.catalina.tribes.transport.ReplicationTransmitter&quot;&gt; &lt;Transport className=&quot;org.apache.catalina.tribes.transport.nio.PooledParallelSender&quot;/&gt; &lt;/Sender&gt; &lt;Interceptor className=&quot;org.apache.catalina.tribes.group.interceptors.TcpFailureDetector&quot;/&gt; &lt;Interceptor className=&quot;org.apache.catalina.tribes.group.interceptors.MessageDispatch15Interceptor&quot;/&gt; &lt;Interceptor className=&quot;org.apache.catalina.tribes.group.interceptors.ThroughputInterceptor&quot;/&gt; &lt;/Channel&gt; &lt;Valve className=&quot;org.apache.catalina.ha.tcp.ReplicationValve&quot; filter=&quot;.*/.gif;.*/.js;.*/.jpg;.*/.png;.*/.htm;.*/.html;.*/.css;.*/.txt;&quot;/&gt; &lt;ClusterListener className=&quot;org.apache.catalina.ha.session.ClusterSessionListener&quot;/&gt; &lt;/Cluster&gt; 注意：tomcat2中的port=&quot;5001&quot;应该为5002 测试 至此，apache2.4和tomcat的负载均衡配置完毕。 测试： 将test_war.war放到tomcat1和tomcat2的webapps目录下，启动apache,再启动tomcat1和tomcat2,浏览器输入localhost/test_war/index.jsp,观察两个tomcat命令框的输出文字，会发现，浏览器多次访问，则由两个tomcat接替处理。 HTTPS的配置上面已经配置并测试了apache2.4和tomcat的负载均衡，下面将继续配置https 打开apache2.4的配置文件 找到 #LoadModule ssl_module modules/mod_ssl.so 将其前面的注释#去掉，改为： #LoadModule ssl_module modules/mod_ssl.so ------------------------------------------------ 找到 # Secure (SSL/TLS) connections #Include conf/extra/httpd-ssl.conf 改为 # Secure (SSL/TLS) connections Include conf/extra/httpd-ssl.conf 打开Apache24\conf\extra\httpd-ssl.conf 找到 &lt;VirtualHost _default_:443&gt; 添加 ProxyPass / balancer://cluster/ stickysession=JSESSIONID|jsessionid nofailover=On ProxyPassReverse / balancer://cluster/ 变成 &lt;VirtualHost _default_:443&gt; # General setup for the virtual host DocumentRoot &quot;d:/Apache24/htdocs&quot; ServerName localhost:443 ServerAdmin admin@example.com ErrorLog &quot;d:/Apache24/logs/error.log&quot; TransferLog &quot;d:/Apache24/logs/access.log&quot; ProxyPass / balancer://cluster/ stickysession=JSESSIONID|jsessionid nofailover=On ProxyPassReverse / balancer://cluster/ ------------------------------------------------------- 将证书复制到apache\conf下 server.crt server.csr server.key 启动apache2.4,依次启动tomcat1和tomcat2,浏览器输入https://localhost/test_war/index.jsp发现https访问可以进行。 https证书获取方式 自制证书 待续… 申请证书 待续…]]></content>
      <tags>
        <tag>负载均衡1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DB2相关]]></title>
    <url>%2F2017%2F09%2F04%2Fdb2%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[DB2编辑节点 调出db2 CLP windows cmd下执行 db2cmd或db2cw 调出db2 CLP 编辑节点： &lt;格式&gt; catalog tcpip node db2node remote hostname server service_port &lt;实例&gt; catalog tcpip node node1 remote 30.31.32.33 server 50000 &lt;格式&gt; catalog database db_name as alias_name at node db2node db_name是指远程数据库的名字， alias_name是客户端实例名， db2node是指上面你所指定的node。 &lt;实例&gt; catalog database db1 as tc1 at node node1 连接测试 &lt;格式&gt; connect to 数据库名 user 用户名 Using 密码 connect to tc1]]></content>
      <tags>
        <tag>db2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[navicat连接虚拟机的oracle]]></title>
    <url>%2F2017%2F07%2F28%2Fnavicat%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84oracle%2F</url>
    <content type="text"><![CDATA[navicat连接虚拟机的oracle环境说明: 虚拟机：VMware8 虚拟机系统：winxp oracle版本：32位，Oracle Database 10g Enterprise Edition Release 10.2.0.1.0 navicat版本：64位，navicat premium 11.0.17 连接 确定虚拟机的ip:VM&gt;edit&gt;virtual network 我的是NAT方式共享主机网络，ip是192.168.201.0(非真实) 进xp系统，cmd下ipconfig:192.168.201.128 确定主机与虚拟机能互相访问(最主要的是主机能访问虚拟机) 主机cmd下ping虚拟机xp系统的ip:ping 192.168.201.128 如果ping出现问题，手动关闭虚拟机xp系统的防火墙。 navicat连接oracle,这一步出现问题最多 navicat建立连接，填写ip为虚拟机xp系统的ip,服务名ORCL, 用户名可以填SYSTEM，还有密码(安装oracle的时候设置的), 点击连接测试，报无法加载OCI.dll 193错误，网上大多教程都是下载32位的basic-client,试了几次依旧报错，因为我的navicat是64位的，且版本是11，所以下载了： instantclient-basic-windows.x64-12.2.0.1.0 instantclient-sqlplus-windows.x64-12.2.0.1.0 这两个64位的，解压，将instantclient_12_2中的文件合并， 打开navicat，工具&gt;选项&gt;OCI:选择刚刚instantclient_12_2中的 oci.dll和sqlplus.exe,保存，重启navicat,连接oracle,OK了。 注意：navicat报错的时候，点开连接，里面有下载client的地址以及老版本的操作方式]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[12306]]></title>
    <url>%2F2017%2F07%2F24%2F12306%2F</url>
    <content type="text"><![CDATA[12306铺位选择代码 12306铺位选择： &lt;select name=&quot;passenger_1_seat_detail_select&quot; style=&quot;display: block&quot; id=&quot;passenger_1_seat_detail_select&quot; onchange=&quot;setSeatDetail(&apos;1&apos;)&quot;&gt; &lt;option value=&quot;0&quot;&gt;随机&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;上铺&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;中铺&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;下铺&lt;/option&gt; &lt;/select&gt; 注意： 点击edit as html 后，在对应的下敲回车留一行空格。 图示： 在图中红框圈住的地方，右键&gt;&gt;&gt;&gt;审查元素,出现图二内容 右键箭头指向的地方&gt;&gt;&gt;edit as html 在出现的代码最下方，敲一下回车(留一行空格)，复制下面的代码： &lt;select name=&quot;passenger_1_seat_detail_select&quot; style=&quot;display: block&quot; id=&quot;passenger_1_seat_detail_select&quot; onchange=&quot;setSeatDetail(&apos;1&apos;)&quot;&gt; &lt;option value=&quot;0&quot;&gt;随机&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;上铺&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;中铺&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;下铺&lt;/option&gt;&lt;/select&gt; 然后就可以继续订票了。]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>12306</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mvc]]></title>
    <url>%2F2017%2F07%2F07%2Fmvc%2F</url>
    <content type="text"><![CDATA[MVC图示 MVC调用 MVC三层结构]]></content>
      <tags>
        <tag>mvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL进阶]]></title>
    <url>%2F2017%2F06%2F02%2FSQL%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[简单表的拆分思路 如图 描述 有一张表 cars,有字段id,name,catename三个。 现要将其拆分成新cars表和cates俩表， 其中新cars表包含id,name和cates的主键cateid。 操作 1.创建cates表 DROP TABLE IF EXISTS `cates`; CREATE TABLE `cates` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8; 2.将cars中的cateName插入到cates中 insert into cates(name) select cateName from cars; 3.创建表cars_tmp存放cars表的id,name和cates的id DROP TABLE IF EXISTS `cars_tmp`; CREATE TABLE `cars_tmp` ( `id` int(11) DEFAULT NULL, `name` varchar(100) DEFAULT NULL, `cateid` int(11) DEFAULT NULL ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 4.将对应数据插入到cars_tmp中 insert into cars_tmp select c.id,c.name,cs.id from cars c join cates cs on c.cateName = cs.name; /inner join和join相同 5.删除老cars表，重命名cars_tmp表为cars drop table cars; alter table cars_tmp rename to cars; case转换 查询结果中字段性别 1和0 转换为 男/女 SELECT id, case sex WHEN &apos;1&apos; THEN &apos;男&apos; WHEN &apos;0&apos; THEN &apos;女&apos; END AS sex FROM person; 表结构： -- ---------------------------- DROP TABLE IF EXISTS `person`; CREATE TABLE `person` ( `id` int(11) NOT NULL, `sex` varchar(1) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 临时表创建临时表很容易，给正常的CREATE TABLE语句加上TEMPORARY关键字即可。 创建临时表 CREATE TEMPORARY TABLE tmp_table ( name VARCHAR(10) NOT NULL ) 向临时表中插数据 insert into tmp_table(name) select name from cars_old; 删除临时表 临时表将在你连接MySQL期间存在。当你断开时，MySQL将自动删除表并释放所用的空间。当然你可以在仍然连接的时候删除表并释放空间。 DROP TABLE tmp_table 查看表结构 查看表结构 desc table_name describe table_name order by order by 1/2/3的含义 SELECT * FROM table_name ORDER BY 1; SELECT id,name,sex FROM table_name ORDER BY 3; ORDER BY 1代表以 所查询字段 的第1个字段排序； ORDER BY 3代表以 所查询字段 的第3个字段排序，如果查询总字段的个数小于3个字段，则会报错。 数据库视图 什么是视图 视图，并不是真实存在的数据表（但是其对应的数据表是真实存在的），而是数据表字段的组合或者筛选，可以与存储过程对比理解，也可以把视图暂且理解为一个或多个数据表特定字段的组合。 如何创建视图 比如，现在存在数据表student DROP TABLE IF EXISTS `student`; CREATE TABLE `student` ( `id` int(11) NOT NULL, `sid` varchar(255) DEFAULT NULL, `sname` varchar(255) DEFAULT NULL, `ssex` varchar(255) DEFAULT NULL, `sage` varchar(255) DEFAULT NULL, `saddress` varchar(255) DEFAULT NULL, `sclass` varchar(255) DEFAULT NULL ) ENGINE=InnoDB DEFAULT CHARSET=utf8; -- ---------------------------- -- Records of student -- ---------------------------- INSERT INTO `student` VALUES (&apos;1&apos;, &apos;2017001&apos;, &apos;张三&apos;, &apos;男&apos;, &apos;21&apos;, &apos;上海&apos;, &apos;001&apos;); INSERT INTO `student` VALUES (&apos;2&apos;, &apos;2017002&apos;, &apos;李四&apos;, &apos;女&apos;, &apos;22&apos;, &apos;北京&apos;, &apos;002&apos;); 该表包含id,学号，姓名，性别，年龄，地址这几个字段，如果此刻只想暴露学号，姓名，性别这三个字段信息供外界查询，那么可以建立视图，用以隐藏其余不想暴露的字段。 create view v_student AS SELECT id,sid,sname,ssex FROM student; 上面的SQL创建了名为v_student的视图，该视图针对student数据表而存在，展示学号，姓名，性别三个字段。 视图的调用 视图的操作与普通数据表的操作一样 查询： select*from v_student; 插入： insert into v_student values(&apos;3&apos;,&apos;2017003&apos;,&apos;王五&apos;,&apos;男&apos;); 修改： UPDATE v_student set ssex=&apos;女&apos; WHERE sid = &apos;2017003&apos;; 删除： DELETE FROM v_student where sid=&apos;2017003&apos;; 视图的优劣 优点： 使用视图，可以定制用户数据，聚焦特定的数据。 使用视图，可以简化数据操作 数据隐藏 以合并分离的数据，创建分区视图 缺点： 性能差 修改限制 参考文章： http://blog.csdn.net/javajxz008/article/details/50720936 外连接与内链接 LEFT JOIN 左表为主表，查询结果含有左表所有满足条件的。 RIGHT JOIN 右表为主表，查询结果含有右表所有满足条件的。 INNER JOIN 只有两表同时满足条件的记录，才会被查询出来。 以info1和info2表中主键(id/sid)相同为条件，查询info1中的id和info2的sname为例： 表1： mysql&gt; select*from info1; +----+-------+ | id | name | +----+-------+ | 4 | 张三4 | | 11 | 张三1 | | 22 | 张三2 | | 33 | 张三3 | +----+-------+ 表2： mysql&gt; select*from info2; +-----+-------+ | sid | sname | +-----+-------+ | 1 | 李四1 | | 22 | 李四2 | | 33 | 李四3 | | 44 | 李四4 | +-----+-------+ 4 rows in set 左连接，以左表为主，其中id为11，4，和55的在info2表中没有对应的id,所以sname为NULL mysql&gt; select id,sname from info1 as a left join info2 as b on a.id = b.sid order by name; +----+-------+ | id | sname | +----+-------+ | 11 | NULL | | 22 | 李四2 | | 33 | 李四3 | | 4 | NULL | | 55 | NULL | +----+-------+ 5 rows in set 右连接，以右表为主，因此左表中的第五列没有被查询出来 mysql&gt; select id,sname from info1 as a right join info2 as b on a.id = b.sid order by name; +------+-------+ | id | sname | +------+-------+ | NULL | 李四1 | | NULL | 李四4 | | 22 | 李四2 | | 33 | 李四3 | +------+-------+ 4 rows in set 内连接，只查询a.id和b.sid一致的记录 mysql&gt; select id,sname from info1 as a inner join info2 as b on a.id = b.sid order by name; +----+-------+ | id | sname | +----+-------+ | 22 | 李四2 | | 33 | 李四3 | +----+-------+ 2 rows in set 给table起别名(DB2) LC.B_SH_DlvSeqInfo起别名为TC.B_SH_DLVSEQINFO CREATE ALIAS TC.B_SH_DLVSEQINFO FOR LC.B_SH_DlvSeqInfo; 索引 索引的创建与查看 UNION与UNION ALL 示例表结构 DROP TABLE IF EXISTS `cars`; CREATE TABLE `cars` ( `id` int(11) DEFAULT NULL, `name` varchar(100) DEFAULT NULL, `cateid` int(11) DEFAULT NULL, `new` int(255) DEFAULT NULL, KEY `myid` (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; -- ---------------------------- -- Records of cars -- ---------------------------- INSERT INTO `cars` VALUES (&apos;1001&apos;, &apos;car1&apos;, &apos;1&apos;, null); INSERT INTO `cars` VALUES (&apos;2&apos;, &apos;car2&apos;, &apos;2&apos;, null); INSERT INTO `cars` VALUES (&apos;3&apos;, &apos;car3&apos;, &apos;3&apos;, null); INSERT INTO `cars` VALUES (&apos;4&apos;, &apos;car4&apos;, &apos;4&apos;, null); INSERT INTO `cars` VALUES (&apos;5&apos;, &apos;car4&apos;, &apos;5&apos;, null); union查询与union all查询对比 UNION: mysql&gt; select &quot;信息名&quot; from cars -&gt; union -&gt; select name from cars; +--------+ | 信息名 | +--------+ | 信息名 | | car1 | | car2 | | car3 | | car4 | +--------+ UNION ALL: mysql&gt; select &quot;信息名&quot; from cars -&gt; union all -&gt; select name from cars; +--------+ | 信息名 | +--------+ | 信息名 | | 信息名 | | 信息名 | | 信息名 | | 信息名 | | car1 | | car2 | | car3 | | car4 | | car4 | +--------+ 对比结果： UNION会将查询的结果去重复，UNION ALL不会进行重复过滤。 但是，如果在UNION ALL中条件唯一（查询结果只有一条），一样可以做到和UNION一样的结果。 如下： mysql&gt; select sum(id),&quot;信息&quot; from cars -&gt; union -&gt; select id,name from cars; +---------+------+ | sum(id) | 信息 | +---------+------+ | 1015 | 信息 | | 1001 | car1 | | 2 | car2 | | 3 | car3 | | 4 | car4 | | 5 | car4 | +---------+------+ mysql&gt; select sum(id),&quot;信息&quot; from cars -&gt; union all -&gt; select id,name from cars; +---------+------+ | sum(id) | 信息 | +---------+------+ | 1015 | 信息 | | 1001 | car1 | | 2 | car2 | | 3 | car3 | | 4 | car4 | | 5 | car4 | +---------+------+ 因为sum（id）的结果只有一条，所以出现UNION ALL和UNION一样的结果。 IFNULL/ISNULL/NVLIFNULL/ISNULL/NVL 可以做数据表两个字段的查询，如字段1，字段2，若字段1为null，则用字段2代替 MySQL语法如下： SELECT IFNULL(new,name) from cars; +------------------+ | IFNULL(new,name) | +------------------+ | 33 | | car2 | | car3 | | car4 | | car4 | +------------------+ Oracle语法： SELECT NVL(new,name) from cars; DB2 SELECT COLUMN FROM TABLE FETCH FIRST N ROWS ONLY CASE的另一种用法 CASE的另一种用法 需求：如果我想更新id=1的status为1，id不为1的status为0 ，且id有外键 update AccountStatus a set a.statusSource=(case when a.statusSource =1 then 2 else 1 end ) --这样可以替换掉id为1的数据为0，id为0的数据为1 普通用法 将成绩划分等级： select grade,case when grade&gt;=90 then &apos;优秀&apos; when grade&gt;=80 then &apos;良好&apos; when grade&gt;=70 then &apos;中等&apos; when grade&gt;=60 then &apos;及格&apos; when grade is null then &apos;缺考&apos; else &apos;不及格&apos; end from sc Mysql的Limit limit select * from tbname LIMIT 10;--检索前10行数据，显示1-10条数据 select * from tbname LIMIT 1,10;--检索从第2行开始，累加10条id记录，共显示id为2....11 select * from tbname limit 5,10;--检索从第6行开始向前加10条数据，共显示id为6,7....15 select * from tbname limit 6,10;--检索从第7行开始向前加10条记录，显示id为7,8...16]]></content>
      <tags>
        <tag>SQL进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse]]></title>
    <url>%2F2017%2F05%2F23%2FEclipse%2F</url>
    <content type="text"><![CDATA[Eclipse快捷键 常用快捷键 Ctrl+1 快速修复(最经典的快捷键,就不用多说了) Ctrl+D: 删除当前行 Ctrl+Alt+↓ 复制当前行到下一行(复制增加) Ctrl+Alt+↑ 复制当前行到上一行(复制增加) Alt+↓ 当前行和下面一行交互位置(特别实用,可以省去先剪切,再粘贴了) Alt+↑ 当前行和上面一行交互位置(同上) Alt+← 前一个编辑的页面 Alt+→ 下一个编辑的页面(当然是针对上面那条来说了) Alt+Enter 显示当前选择资源(工程,or 文件)的属性 Shift+Enter 在当前行的下一行插入空行(这时鼠标可以在当前行的任一位置,不一定是最后) Shift+Ctrl+Enter 在当前行插入空行(原理同上条) Ctrl+Q 定位到最后编辑的地方 Ctrl+L 定位在某行(按下快捷键提示输入行数) Ctrl+M 最大化当前的Edit或View (再按则反之) Ctrl+/ 注释当前行,再按则取消注释 Ctrl+O 快速显示 OutLine Ctrl+T 快速显示当前类的继承结构 Ctrl+W 关闭当前Editer Ctrl+K 参照选中的Word快速定位到下一个 Ctrl+E 快速显示当前Editer的下拉列表(如果当前页面没有显示的用黑体表示) Ctrl+/(小键盘) 折叠当前类中的所有代码 Ctrl+×(小键盘) 展开当前类中的所有代码 Ctrl+Space 代码助手完成一些代码的插入(但一般和输入法有冲突,可以修改输入法的热键,也可以暂用Alt+/来代替) Ctrl+Shift+E 显示管理当前打开的所有的View的管理器(可以选择关闭,激活等操作) Ctrl+J 正向增量查找(按下Ctrl+J后,你所输入的每个字母编辑器都提供快速匹配定位到某个单词,如果没有,则在stutes line中显示没有找到了,查一个单词时,特别实用,这个功能Idea两年前就有了) Ctrl+Shift+J 反向增量查找(和上条相同,只不过是从后往前查) Ctrl+Shift+F4 关闭所有打开的Editer Ctrl+Shift+X 把当前选中的文本全部变味小写 Ctrl+Shift+Y 把当前选中的文本全部变为小写 Ctrl+Shift+F 格式化当前代码 Ctrl+Shift+P 定位(跳转)到对应的匹配符(譬如{}) (从前面定位后面时,光标要在匹配符里面,后面到前面,则反之) Ctrl+shift+上/下：在各个方法间跳 Ctrl+shift+左/右：从光标所在位置开始选择内容 Eclipse中重构常用快捷键 (注:一般重构的快捷键都是Alt+Shift开头的了) Alt+Shift+R 重命名 (是我自己最爱用的一个了,尤其是变量和类的Rename,比手工方法能节省很多劳动力) Alt+Shift+M 抽取方法 (这是重构里面最常用的方法之一了,尤其是对一大堆泥团代码有用) Alt+Shift+C 修改函数结构(比较实用,有N个函数调用了这个方法,修改一次搞定) Alt+Shift+L 抽取本地变量( 可以直接把一些魔法数字和字符串抽取成一个变量,尤其是多处调用的时候) Alt+Shift+F 把Class中的local变量变为field变量 (比较实用的功能) Alt+Shift+I 合并变量(可能这样说有点不妥Inline) Alt+Shift+V 移动函数和变量(不怎么常用) Alt+Shift+Z 重构的后悔药(Undo) 让eclipse与Myeclipse统一 重建clipse工程时做以下改变可让工程同时运行在MyEclipse和Eclipse下 build\classes改为：WebRoot\WEB-INF\classes WebContent改为：WebRoot]]></content>
      <tags>
        <tag>Eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA]]></title>
    <url>%2F2017%2F05%2F23%2FIDEA%2F</url>
    <content type="text"><![CDATA[IDEA常用快捷键 常用快捷键： Ctrl+Alt+L:自动格式化代码 Ctrl+Enter:另起一行 Alt+Insert:Generate-getter/setter等 Alt+Enter:各种错误解决方案提示 Ctrl+Alt+Shift+S:Project Structure即 Artifacts、Modules、Facets等设置 Shift+F6：重命名你的类、方法、变量等，可以选择替换掉注释中的内容 ctrl+d：复制当前行 ctrl+y：删除当前行 sout：system.out.print快捷方式 psvm：main放大快捷方式 Ctrl+shift +/- :展开/折叠全部代码 错误提示1099：tomcat和jdk版本不匹配 使用技巧find action(command + shift +a)下搜索快捷键： 如recent file 提示快捷键为 command + e 搜索文件: command+n 最近文件： command+e 书签标记 command+f11 书签跳转 control+书签数字 收藏代码 alt+shift+f 展现收藏列表 command+2 展现project导航栏 command+1 左边栏与代码编辑框的互相跳转 command+1跳转到左边栏，esc恢复到代码编辑框 IDEA常用插件 lombok 实体类不写getter/setter; Slf4j等； 详见笔记《Lombok参考手册》 iBATIS/MyBatis mini-plugin 方便接口到实现的跳转；dao接口到xml SQL语句的跳转 IDEA maven helper pom.xml文件中方便查看maven依赖冲突，依赖列表，依赖树 https://my.oschina.net/u/136229/blog/678918 JRebel 实现IDEA下应用的热部署热编译，修改静态文件，java文件，无需重启即可自动编译部署，使之生效； 收费插件； 详见笔记《jrebel》 EasyCode https://juejin.im/entry/5b6a61a1f265da0f7e62b1b0?utm_source=gold_browser_extension IDEA常用设置 参考 https://blog.csdn.net/qq_27093465/article/details/77449117 设置显示项目内存占用 preference&gt;appearence&amp;Behavior&gt;appearence&gt;window options下勾选show mwmory indicator]]></content>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UUID]]></title>
    <url>%2F2017%2F05%2F23%2FUUID%2F</url>
    <content type="text"><![CDATA[java生成8位UUID做主键 java生成8位UUID做主键 源码文件： http://op05inpyd.bkt.clouddn.com/UUIDTest.txt 源码内容： import java.util.UUID; /** * 生成8位UUID做主键 */ public class UUIDTest { public static void main(String[] args) { System.out.println(getShortUuid()); } public static String[] chars = new String[] { &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;, &quot;o&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot; }; public static String getShortUuid() { StringBuffer stringBuffer = new StringBuffer(); String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;); for (int i = 0; i &lt; 8; i++) { String str = uuid.substring(i * 4, i * 4 + 4); int strInteger = Integer.parseInt(str, 16); stringBuffer.append(chars[strInteger % 0x3E]); } return stringBuffer.toString().toLowerCase(); } } java生成普通UUID java生成普通UUID import java.util.UUID; /** * java普通UUID */ public class UUIDTest2 { public static void main(String[] args) { System.out.println(get32UUID()); } public static String get32UUID() { String uuid = UUID.randomUUID().toString().trim().replaceAll(&quot;-&quot;, &quot;&quot;); return uuid; } } ------------------------------------------------------------------------ public static void main(String[] args) { for (int i = 0; i &lt; 100; i++) { //import java.util.UUID; String uuidStr = UUID.randomUUID().toString(); System.out.println(uuidStr); System.out.println(uuidStr.replaceAll(&quot;-&quot;, &quot;&quot;)); } }]]></content>
      <tags>
        <tag>UUID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS总结]]></title>
    <url>%2F2017%2F05%2F18%2FJS%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[生成4位随机数 生成4位随机数 http://op05inpyd.bkt.clouddn.com/%E9%9A%8F%E6%9C%BA%E6%95%B0.txt &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gb2312&quot; /&gt; &lt;title&gt;随机数&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .textbox { margin-right: 5px; margin-top: 10px; width: 70px; font-family: 微软雅黑; text-align: center; font-weight: bold; font-size: 16px; color: Blue; } &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; //增加文本框 function CreateTextBox() { var count = GetTextBoxCount(); if (count &lt; 10) { var textBox = document.createElement(&quot;input&quot;); textBox.setAttribute(&quot;type&quot;, &quot;text&quot;); textBox.setAttribute(&quot;name&quot;, &quot;myname&quot;); textBox.className = &quot;textbox&quot;; document.body.appendChild(textBox); } else { alert(&quot;最多生成10个随机数&quot;); } } //减少文本框 function RemoveTextBox() { var count = GetTextBoxCount(); if (count &gt; 1) { document.body.removeChild(document.body.lastChild); } else { alert(&quot;请最少保留1个&quot;); } } //计算文本框的个数 function GetTextBoxCount() { var elements = document.getElementsByName(&quot;myname&quot;); return elements.length; } Array.prototype.Contains = function (num) { var flag = false; if (this.length &lt;= 0) { return flag; } for (var i = 0; i &lt; this.length; i++) { if (this[i] == num) { flag = true; break; } } return flag; } //生成4位随机数并放到数组中 function CreateRandomNumber(array, count) { while (array.length &lt; count) { var num = Math.floor((Math.random()) * 9000+1000); if (!array.Contains(num)) { array.push(num); } } } //将数组中的随机数赋值到界面的文本框中 function SetTextBoxValue() { var array = new Array(); var count = GetTextBoxCount(); CreateRandomNumber(array, count); var elements = document.getElementsByName(&quot;myname&quot;); for (var i = 0; i &lt; elements.length; i++) { elements[i].value = array[i]; } } &lt;/script&gt; &lt;/head&gt; &lt;body onload=&quot;CreateTextBox()&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;增加&quot; onclick=&quot;CreateTextBox()&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;减少&quot; onclick=&quot;RemoveTextBox()&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;生成随机数&quot; onclick=&quot;SetTextBoxValue()&quot; /&gt;&lt;br /&gt; &lt;/body&gt; &lt;/html&gt; 生成不重复的4位随机数 生成不重复的4位随机数 http://op05inpyd.bkt.clouddn.com/%E7%94%9F%E6%88%90%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%844%E4%BD%8D%E9%9A%8F%E6%9C%BA%E6%95%B0.txt /** * 生成4位随机数并赋值,已经有随机数的输入框，不再赋值 */ function GetTextBoxCount() { var elements = document.getElementsByName(&quot;ConfirmationCode&quot;); //TODO 只取空值的个数 var nums=0; for(var j = 0; j &lt; elements.length; j++){ if(elements[j].value == null || elements[j].value ==&quot;&quot;){ nums++; } } return elements.length; } Array.prototype.Contains = function (num) { var flag = false; if (this.length &lt;= 0) { return flag; } for (var i = 0; i &lt; this.length; i++) { if (this[i] == num) { flag = true; break; } } return flag; } function CreateRandomNumber(array,array2,count) { while (array.length &lt; count) { var num = Math.floor((Math.random()) * 9000+1000); //将随机生成的数字与页面原有随机数比较，保证不重复 if (!array.Contains(num) &amp;&amp; !array2.Contains(num)) { array.push(num); } } } function SetTextBoxValue() { var array = new Array(); var array2 = new Array(); var elements = document.getElementsByName(&quot;ConfirmationCode&quot;); //将已经存在的随机码存进array for (var i = 0; i &lt; elements.length; i++) { array2.push(elements[i]); } var count = GetTextBoxCount(); CreateRandomNumber(array,array2,count); for (var i = 0; i &lt; elements.length; i++) { //非空不赋值 if(elements[i].value == null || elements[i].value ==&quot;&quot;){ elements[i].value = array[i]; } } } /** * 检查用户手动输入确认码是否重复 */ function IsCodeExists(data){ //获取页面数据并存进数组中 var elements = document.getElementsByName(&quot;ConfirmationCode&quot;); var array4 = new Array(); for (var i = 0; i &lt; elements.length; i++) { array4.push(elements[i].value); } //对数组中的数据进行重复比较 var ary = array4; var nary=ary.sort(); for(var i=0;i&lt;ary.length;i++){ if (nary[i]==nary[i+1] &amp;&amp; nary[i] !=&quot;&quot;){ alert(&quot;确认码 &quot;+nary[i]+&quot; 重复，请重新输入！&quot;); } } } /** * 提交前再做一次重复判断，若重复，则弹窗提醒并且不提交 */ function btnsave_clicked(){ var flag=false; //获取页面数据并存进数组中 var elements = document.getElementsByName(&quot;ConfirmationCode&quot;); var array4 = new Array(); for (var i = 0; i &lt; elements.length; i++) { array4.push(elements[i].value); } //对数组中的数据进行重复比较 var ary = array4; var nary=ary.sort(); for(var i=0;i&lt;ary.length;i++){ if (nary[i]==nary[i+1] &amp;&amp; nary[i] !=&quot;&quot;){ flag=false; alert(&quot;确认码 &quot;+nary[i]+&quot; 重复，请重新输入！&quot;); return false; }else{ flag=true; } } if(flag){ //将要返回的数据打包封装 document.all.formdetail.value = getDetail2(); document.all.lg_sh_deliveryconfirmationcodform.action=&lt;select:link page=&quot;/lg_sh_deliveryconfirmationcodaction.do?method=save&quot;&gt;&lt;/select:link&gt;; document.all.lg_sh_deliveryconfirmationcodform.submit(); } } 给查询结果集计算行数并赋值行数 给查询结果集计算行数并赋值行数 //计算行数 function init(){ for(var i=1; i&lt;=intTotalRow; i++){ document.all.seq[i].value = i; } } ------ 对应的文本框属性 &lt;grid:text style=&quot;width:40px;&quot; readonly=&quot;true&quot; isReturn=&quot;true&quot; capital=&quot;序号&quot; property=&quot;seq&quot; tabindex=&quot;-1&quot;/&gt; div显示切换 点击按钮，让两个div切换显示，只显示一个 &lt;!DOCTYPE html&gt; &lt;script&gt; function btn1(){ document.getElementById(&apos;div1&apos;).style.display=&apos;none&apos;; document.getElementById(&apos;div2&apos;).style.display=&apos;block&apos;; } function btn2(){ document.getElementById(&apos;div1&apos;).style.display=&apos;block&apos;; document.getElementById(&apos;div2&apos;).style.display=&apos;none&apos;; } &lt;/script&gt; &lt;body&gt; &lt;div id=&quot;div1&quot; style=&quot;background:green;height:200px&quot;&gt; 第一个div高200px &lt;/div&gt; &lt;div id=&quot;div2&quot; style=&quot;background:gray; display:none;height:400px&quot;&gt; 第二个div高400px &lt;/div&gt; &lt;button id=&quot;btn1&quot; onclick=&quot;btn1()&quot;&gt;显示第二个&lt;/button&gt; &lt;button id=&quot;btn1&quot; onclick=&quot;btn2()&quot;&gt;显示第一个&lt;/button&gt; &lt;/body&gt; &lt;/html&gt; js过滤空格 过滤获取值的空格 1、过滤字符串两边的空格 str = $.trim(str) 2、过滤所有空格 str = str.replace(/ /g,&apos;&apos;) 例如： var num = document.getElementById(&apos;truckNumInput&apos;).value.replace(/ /g,&apos;&apos;); 输入框获取焦点 加载页面时输入框获取焦点 &lt;script&gt; window.onload = function(){ document.getElementById(&quot;name&quot;).focus(); } &lt;/script&gt; JS代码收集 代码位置(私有) https://git.coding.net/uxaw/keyboard.git 包含内容： 网页键盘 table点击变色 span标签内容居中 span标签内容居中 &lt;body&gt; &lt;div style=&quot;width:160px;height:100px;border:1px dashed #FFFFFF;margin:0 auto&quot; &gt; &lt;span style=&quot;height:100px;display:block;background:gray;margin:1px 1px;text-align:center;line-height:100px;&quot;&gt; 内容内容内容 &lt;/span&gt; &lt;/div&gt; &lt;/body&gt; JQuery格式 JQuery $.post(&quot;login.tushu&quot;,-------------------url { &quot;userName&quot;: userName, &quot;passWord&quot;: passWord }, ---------------------data function (respnum) { var obj = eval(&quot;(&quot; + respnum + &quot;)&quot;); var num = obj.num; if (0 == num) { loginNo.css(&quot;display&quot;, &quot;block&quot;); } else { //跳转页面 location.href = &quot;jsp/index.jsp&quot;; } }) -------------------callback 格式： jQuery.post( url, [data], [callback], [type] JSP中java代码获取路径 获取路径 &lt;% String path = request.getContextPath(); String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + path + &quot;/&quot;; %&gt; 得到结果： http://localhost:8090/ 自动跳转链接（定时） 自动跳转 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;/head&gt; &lt;script type=&quot;text/javascript&quot;&gt; function toDiscuz(){ document.getElementById(&quot;sp&quot;).click(); } &lt;/script&gt; &lt;body onload=&quot;toDiscuz()&quot;&gt; &lt;a href=&quot;https://www.baidu.com&quot;&gt;&lt;span id=&quot;sp&quot;&gt;自动点击&lt;/span&gt;&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 定时3秒后自动跳转 将&lt;body onload=&quot;toDiscuz()&quot;&gt; 改为： &lt;body onload=setTimeout(&quot;toDiscuz(&apos;run&apos;,&apos;1&apos;)&quot;,3000)&gt; bootstrap小窗口弹窗变灰无法操作 更改bootstrap.js源码： 在 .appendTo(this.$body 添加后 .find(&apos;.contentIndex&apos;) 改成： .appendTo(this.$body.find(&apos;.contentIndex&apos;)) 根据身份号码计算年龄 年龄 //计算年龄函数 function GetAge(identityCard) { var len = (identityCard + &quot;&quot;).length; if (len == 0) { return 0; } else { if ((len != 15) &amp;&amp; (len != 18))//身份证号码只能为15位或18位其它不合法 { return 0; } } var strBirthday = &quot;&quot;; if (len == 18)//处理18位的身份证号码从号码中得到生日和性别代码 { strBirthday = identityCard.substr(6, 4) + &quot;/&quot; + identityCard.substr(10, 2) + &quot;/&quot; + identityCard.substr(12, 2); } if (len == 15) { strBirthday = &quot;19&quot; + identityCard.substr(6, 2) + &quot;/&quot; + identityCard.substr(8, 2) + &quot;/&quot; + identityCard.substr(10, 2); } //时间字符串里，必须是“/” var birthDate = new Date(strBirthday); var nowDateTime = new Date(); var age = nowDateTime.getFullYear() - birthDate.getFullYear(); //再考虑月、天的因素;.getMonth()获取的是从0开始的，这里进行比较，不需要加1 if (nowDateTime.getMonth() &lt; birthDate.getMonth() || (nowDateTime.getMonth() == birthDate.getMonth() &amp;&amp; nowDateTime.getDate() &lt; birthDate.getDate())) { age--; } return age; } //赋值 document.getElementById(&apos;realAge&apos;).innerText=age; 待续…]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>随机数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu系统安装]]></title>
    <url>%2F2017%2F05%2F15%2Fubuntu%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[1.准备工作 所需材料： ubuntu系统镜像 制作ubuntu安装盘的工具 windows下修改磁盘的工具 ubuntu系统镜像下载地址为: http://cn.ubuntu.com/download/ 制作ubuntu安装盘的工具我们选择比较便捷的工具Universal-USB-Installer.exe windows下修改磁盘的工具，有多种选择，这里选择windows的装机工具大白菜或者用分区助手 http://bd.dabaicai.biz/ 2.划分一块空间作为ubuntu的系统盘 先用windows下修改磁盘的工具进pe 找到磁盘管理软件（桌面有快捷图标），划分一个盘符，并将其设定为系统分区，是系统分区，不是逻辑分区。注意记住划分的盘符大小，后面有点儿用。—后面第四步：开始安装ubuntu系统会用到。（我是这么做的） 或者直接选择一块盘符，删除分区试试，不进行格式化等操作了。（没实验，但原理上应该可行） 3.制作ubuntu安装盘 制作ubuntu安装盘 将U盘插入电脑usb接口，运行Universal-USB-Installer.exe，操作如下图所示 选完这三项后，点击 Creat，耐心等待即可。 4.开始安装ubuntu系统 安装ubuntu 重启电脑，进入BIOS，将U盘设置为第一启动项，保存，退出，此时电脑会重启，进入ubuntu安装界面， 选这第二项，安装ubuntu,然后根据提示，一步步作， 在有一步中ubuntu会识别到你的windows系统， 这一步选择其他/other,然后，然后选择你第二步第3条中创建的磁盘空间， 双击，选择大小（不要占满你所创建的空间），选择挂载点为 / 然后，再在剩余的空间上创建 交换空间 即swap,选择2GB或其他都行，看容量。 最后，建议留一点空间以后备用，这个空间此时暂时不再划分。 做完上述操作后，点击执行即可，等待系统安装完成。 安装完成后可能出现无法连接wifi的情况，原因是没有无线网卡驱动，建议找个有线网络先联网，或者手机开热点用蓝牙分享热点给电脑用，然后在电脑的 系统设置》软件和更新》附加驱动里，选择无线网卡驱动即可。]]></content>
      <tags>
        <tag>ubuntu系统安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu命令]]></title>
    <url>%2F2017%2F05%2F15%2Fubuntu%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[ubuntu下安装mysql 方式一： 1.sudo apt-get install mysql-server 切换到root用户执sudo命令 2.apt-get isntall mysql-client 3.sudo apt-get install libmysqlclient-dev 文件夹权限修改 级联文件夹权限设置为所有用户 ux@adm-Aspire:/usr/mysoft$ sudo chmod 777 * -R 对文件夹的操作复制到制定目录 sudo cp -a demo /usr/mysoft 删除目录 rm -rf demo unzip XX-Net-2.0.5.zip 重命名文件夹 mv oldfileName newName 解压rar文件 unrar x 记事本.rar ubuntu安装JDK 安装步骤： sudo mkdir /usr/lib/java8 cd Downloads sudo tar zxvf jdk-8u111-linux-x64.tar.gz -C/usr/lib/java8 cd /usr/lib/java8 sudo gedit ~/.bashrc vi ~/.bashrc #set oracle jdk environment export JAVA_HOME=/usr/lib/java8/jdk1.8.0_111 export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib export PATH=${JAVA_HOME}/bin:$PATH source ~/.bashrc java -version http://jingyan.baidu.com/article/ad310e80ae6d971849f49ed3.html im-config Yes 修改上面的ibus为fcitx. 后重启电脑 在终端中输入：fcitx-config-gtk3出现对话框如下 sudo tar zxvf ideaIU-2016.2.5-no-jdk.tar.gz -C/usr/mysoft 安装IDEAux@adm-Aspire:/usr$ cd /usr/mysoft/idea-IU-162.2228.15/bin ux@adm-Aspire:/usr/mysoft/idea-IU-162.2228.15/bin$ ls appletviewer.policy idea64.vmoptions idea.vmoptions libyjpagent-linux64.so fsnotifier idea.png inspect.sh libyjpagent-linux.so fsnotifier64 idea.properties libbreakgen64.so log.xml fsnotifier-arm idea.sh libbreakgen.so ux@adm-Aspire:/usr/mysoft/idea-IU-162.2228.15/bin$ ./idea.sh sudo无法解析主机名 解决方式： 解决方案 sudo gedit /etc/hosts 电源管理 安装电源管理工具并配置 $ sudo apt-get install laptop-mode-tools gksu lmt-config-gui]]></content>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java进阶]]></title>
    <url>%2F2017%2F05%2F15%2FJava%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[Spring spring3和spring4的架构图对比 spring3结构图： spring4架构图： Spring4架构解析 Spring4的5层架构 1.core 2.aop 3.data access 4.web 5.test 下载spring4的jar包将其归类： 1.core Container部分包含4个模块（spring核心容器） spring-core：依赖注入IoC与DI的最基本实现 spring-beans：Bean工厂与bean的装配 spring-context：spring的context上下文即IoC容器 spring-context-support：spring额外支持包，比如邮件服务、视图解析等 spring-expression：spring表达式语言 2.aop部分包含5个模块(AOP &amp; Instrumentation &amp; Messaging) spring-aop：面向切面编程 spring-aspects：集成AspectJ spring-instrument：提供一些类级的工具支持和ClassLoader级的实现，用于服务器 spring-instrument-tomcat：针对tomcat的instrument实现 spring-messaging：用于构建基于消息的应用程序 3.data access部分包含5个模块 spring-jdbc：jdbc的支持 spring-tx：事务控制 spring-orm：对象关系映射，集成orm框架 spring-oxm：对象xml映射 spring-jms：java消息服务 4.web部分包含4个模块 spring-web：基础web功能，如文件上传 spring-webmvc：mvc实现 spring-webmvc-portlet：基于portlet的mvc实现 spring-websocket：为web应用提供的高效通信工具 5.test部分只有一个模块，将spring-context-support也放在这吧 spring-test：spring测试，提供junit与mock测试功能 注： org.springframework.beans和org.springframework.context包是Spring框架IoC容器的基础 注：摘自以下地址&gt; 1.博客 http://www.cnblogs.com/ywlaker/p/6136625.html 2.spring官方文档 http://docs.spring.io/spring/docs/current/spring-framework-reference/html/index.html 查看各个jar的以来关系，请访问上述地址。 Maven的BOM清单统一管理spring版本&lt;!--统一spring各组件的版本--&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-framework-bom&lt;/artifactId&gt; &lt;version&gt;4.3.10.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;!--继承一个父模块，然后再引入相应的依赖--&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;!--junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--spring-context(IOC容器)--&gt; &lt;!--由于上面统一管理了spring的版本，因此此处不必指定context的版本--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 剔除commons-logging使用log4j&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.1.3.RELEASE&lt;/version&gt; &lt;exclusions&gt; &lt;!--排除commons-logging--&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt; &lt;version&gt;1.5.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.5.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.5.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.14&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; IOC该接口org.springframework.context.ApplicationContext代表Spring IoC容器,并负责实例化，配置和组装上述bean ApplicationContext，BeanFactory， IOC 的关系 关系 ApplicationContext是比Beanfactory更加先进的IOC容器的一种实现 ApplicationContext类型容器提供的集中实现 FileSystemXmlApplicationContext：从文件中加载bean定义以及相关资源的ApplicationContext实现。 ClassPathXmlApplicatonContext：从Classpath加载bean定义以及相关资源的Applicationcontext的实现。 XmlWebApplicationContext：用于web应用程序的ApplicationContext的实现。 ApplicationContext与BeanFactory的联系 接口ApplicationContext继承了ListableBeanFactory和HierarchicalBeanFactory这两个接口， 而这两个接口都是继承自BeanFactory接口，BeanFactory接口中有方法getBean(),返回类型为Object. http://www.cnblogs.com/Qbright/archive/2012/07/18/2597184.html beansjavaBeans,POJOs和spring bean javaBeans: 包含默认（无参数）的构造函数 允许通过访问器(getter和setter方法)来访问类的成员属性 实现java.io.Serializable接口 POJO POJO是 Plain Old Java Object（简单的Java对象）的缩写,作为一种花式的对普通Java对象的称呼. Spring beans Spring bean 表示受到Spring管理的对象。具体说来，它是被Spring框架容器初始化、配置和管理的对象 每一个Bean对应Spring容器里的一个Java实例，定义Bean时通常需要指定两个属性。 在Spring中，被Spring IoC 容器 管理的这些来自于应用主干的这些对象称作 beans 。bean是一个由Spring IoC容器进行实例化、装配和管理的对象。此外，bean只是你应用中许多对象中的一个 spring常用注解（annotation） http://www.cnblogs.com/xiaoxi/p/5935009.html 常用 @Component:@Component是所有受Spring 管理组件的通用形式，@Component注解可以放在类的头上，@Component不推荐使用。 @Controller:@Controller对应表现层的Bean，也就是Action。 @Controller注解标识UserAction之后，就表示要把UserAction交给Spring容器管理，在Spring容器中会存在一个名字为&quot;userAction&quot;的action。 这里的UserAction还使用了@Scope注解，spring 默认scope 是单例模式(scope=&quot;singleton&quot;)，这样只会创建一个Action对象，每次访问都是同一Action对象，数据不安全，struts2 是要求每次次访问都对应不同的Action，scope=&quot;prototype&quot; 可以保证当有请求的时候都创建一个Action对象。 @Service:@Service对应的是业务层Bean @Repository:@Repository对应数据访问层Bean @Autowired：自动装配，其作用是为了消除代码Java代码里面的getter/setter与bean属性中的property @Autowired 默认按类型装配，如果我们想使用按名称装配，可以结合@Qualifier注解一起使用。如下： @Autowired @Qualifier(&quot;personDaoBean&quot;) 存在多个实例配合使用 @Resource默认按名称装配，当找不到与名称匹配的bean才会按类型装配。 @Scope(&quot;prototype&quot;)：Spring默认产生的bean是单例的，&quot;prototype&quot;表示原型即每次都会new一个新的出来。 @Configuration把一个类作为一个IoC容器，它的某个方法头上如果注册了@Bean，就会作为这个Spring容器中的Bean。 一般 @Scope注解 作用域 @Lazy(true) 表示延迟初始化 @PostConstruct用于指定初始化方法（用在方法上） @PreDestory用于指定销毁方法（用在方法上） @DependsOn：定义Bean初始化及销毁时的顺序 @Primary：自动装配时当出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常 @PostConstruct 初始化注解 @PreDestroy 摧毁注解 默认 单例 启动就加载 @Async异步方法调用 sqlSessionTemplatesqlSessionFactorysqlSessionTemplateBeanNamesqlSessionFactoryBeanName SpringMVC 待续… MyBatis 待续… SSM简要概述 概述]]></content>
      <tags>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂记]]></title>
    <url>%2F2017%2F05%2F04%2F%E6%9D%82%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[鉴别iphone 鉴别iphone 机子到手后如何验机 1.新机开机后，会有一个感叹号（没有感叹号的证明机子不是未激活的），点击感叹号以后可以看到手机imei，官网查询一下是否未激活 2.电脑下载爱思助手这个软件，然后连接手机到电脑，打开设备信息，看看是否电池充电次数为0 3.官网确认未激活，电池确认没充电过，再用闪光灯检查手机的充电口和耳机口（官方售后喜欢这么检查，所以借鉴一下） 备注：未激活的意思是机子还没使用过的意思，电池充电次数是充电过几次的意思 windows创建计划任务创建定时重启任务 定时重启 windows搜索框搜索”计划任务”，(或者在控制面板（选择小图标显示）-管理工具-任务计划程序)，点击运行，结果如下图 选择创建基本任务(计划任务1.png): 选择启动程序(计划任务2.png): 选择System32\shutdown.exe(计划任务3.png): 添加参数-r,代表重启，-s代表关机(计划任务4.png): 创建定时唤醒任务 创建定时唤醒，利用定时执行程序唤醒休眠中的计算机，注意，是休眠中的计算机 填写任务名称，选择最高权限(可选)（定时唤醒1.png） 新建触发器，设定执行时间，选择执行任务时间为每天（定时唤醒2.png） 新建操作，选择要执行的程序（定时唤醒3.png） 设置条件，勾选 唤醒计算机执行此任务（定时唤醒4.png） 在设置选项勾选如图所示(可选)。（定时唤醒5.png） 远程可以选择使用teamviewer https://www.teamviewer.com/zhCN/ 注意： 为避免电脑长时间休眠等因素导致软件停止运行 首先，将电脑的电源选项改为从不休眠 然后，我的电脑-右键-管理-服务-找到teamviewer-双击，找到恢复选项，改为如下图(teamviewer.png)： 这样做是为了防止teamviewer服务停止运行后，能够重新启动服务，如果连续两次启动失败，那么重新启动计算机（前提是，已经将teamviewer设置为随计算机启动）。 PE装机U盘4G文件 首先把U盘格式化成NTFS格式(这样U盘就能复制超过4G的镜像文件了) 然后再用装机工具制作装机盘（如大白菜），制作装机盘时可选HDD-FAT32，并不会改变U盘的NTFS格式。 WPS弹窗永久关闭 找到WPS安装目录下的wtoolex目录，将其中的wpsnotify.exe替换为txt改变格式为exe的同名文件 为防止wps自动更新/自动更新wpsnotify.exe，同时也将updateself.exe，wpsupdate.exe替换为自己创建的空白exe同名文件 个人不喜欢WPS的云，所以将wpscloudsvr.exe也替换了 IDEA代码类型提示关闭 在settings&gt;Editor&gt;General&gt;Appearance下找到show Parameter取消勾选即可 DNS google DNS 8.8.8.8 8.8.4.4 OpenDNS 208.67.222.222 208.67.220.220 台湾中华电讯DNS 168.95.192.1 168.95.192.2 香港宽频DNS 203.80.96.9 203.80.96.10 查看所有进程占用端口 查看所有进程占用端口 netstat –ano 查看指定端口占用 netstat -ano|findstr &quot;8080&quot; Windows下mysql 1045错误编码 Access denied for user ‘root’@’localhost’ (using password:YES) 1.停止mysql服务 2.打开MySQL目录下的my.ini文件，在文件的最后添加一行“skip-grant-tables”，保存并关闭文件 3.启动mysql服务，cmd下登录mysql mysql -u root -p 不输密码直接回车 重置mysql的root密码，然后重启mysql服务 update user set password=PASSWORD(&quot;123456&quot;) where user=&apos;root&apos;; window下mysql启动/停止命令 启动 net start mysql 停止 net stop mysql 重启 windows下mysql没有restart命令，只能先停止再启动。]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>iphone</tag>
        <tag>计划任务</tag>
        <tag>远程</tag>
        <tag>PE装机4G大文件</tag>
        <tag>WPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础]]></title>
    <url>%2F2017%2F05%2F04%2FJava%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[JVM JVM介绍 JVM是Java Virtual Machine（Java虚拟机）的缩写， JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。 Java虚拟机包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆和一个存储方法域。 JVM屏蔽了与具体操作系统平台相关的信息，使Java程序只需生成在Java虚拟机上运行的目标代码（字节码）,就可以在多种平台上不加修改地运行。 JVM在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。 http://www.cnblogs.com/sunada2005/p/3577799.html equals与== 区别（20180401） 1）对于==，如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等； 如果作用于引用类型的变量，则比较的是所指向的对象的地址 2）对于equals方法，注意：equals方法不能作用于基本数据类型的变量 如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址； 诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。 示例： https://www.nowcoder.com/questionTerminal/04fd8ddb19024dd0acd89bbff85c0a50 String String字符串拼接方式，好处与不足 1.+号直接拼接 2.append() 3.Format》》String.format(&quot;%s和%s一起LOL&quot;, new String[]{ &quot;小明&quot;, &quot;小强&quot;}); 4.StringBuilder stringBuilder效率高，不产生新的对象 string对象操作的时候，总是产生新的对象， 然后自动回收旧的对象(如果没用的话)，效率是比stringBuilder在原对象上进行操作来的低的 参考链接: http://www.cnblogs.com/gc2013/p/4351015.html String 对象 String对象是不可变的，你可以给一个String对象加任意多的别名。因为String对象具有只读特性，所以指向它的任何引用都不可能改变它的值。 不可变性也会带来一定的效率问题。 http和https http和https 一、https协议需要到ca申请证书，一般免费证书很少，需要交费。 二、http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。 三、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 四、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、 身份认证的网络协议，比http协议安全。 Java数据类型 基本数据类型（四类八种） 整型( byte short int long ) 浮点型( float double ) 字符型( char ) 布尔型( boolean ) 引用数据类型 数组型 接口型 类类型 数据类型图示(java数据类型.png) 注意：byte,short,char都可以隐含转换为int，long不能转换为int char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中可以存储汉字(未包含在unicode编码中的特殊汉字除外).unicode编码占用两个字节，所以，char类型的变量也是占用两个字节。 堆栈区域 成员变量存在于堆内存中，默认有初始值。 局部变量存在于栈内存中，没有默认初始值。 图解1(堆栈图解1.png) 图解2(堆栈图解2.png) 集合简单总结 常用总结比较(集合总结2.png) 由此可得，HashMap可以存储一个key为null,多个value为null的键值对。 Collection和Map框架结构 比较常用的Collection子类与Map子类简图(Collection和Map框架结构.png) 泛型与容器的关系容器，即:存对象的地方，当把对象存进容器中时，就转变成了Object类型的对象，那么在取出对象元素时，就需要做类型转换(向下转换)，那么就可能发生类型转换异常(ClassCastException)，这个时候，如果有一种约束，来确保存进去的是一种具体类型，那么取出时就不用再做类型转换的工作了，那么也就可以有效防止类型转换异常的出现了，那么这种约束，就是java中的泛型，一种对容器概念的有效补充。 简单的容器分类 分类图(简单的容器分类.png) 接口类型的子类对象的意义 多态的体现(接口类型的子类对象的意义.png) LinkedList与ArrayList LinkedList LinkedList底层是由双向循环链表实现，里面的数据在逻辑上的存储是连续的，连续自然也就有顺序了 LinkedList与ArrayList的比较 LinkedList也像ArrayList一样实现了基本的List接口，但是它执行某些操作时比ArrayList更高效（在List的中间插入和移除），但在随机访问操作方面却要逊色一些。 ArrayList底层的实现是数组，所以用下标访问的速度比较快，但是插入和删除元素，会有移动元素的开销，所以速度比LinkedList差。 LikedList底层是链表实现的，所以插入和删除元素时间复杂度较LinkedList好，但是随即访问需要遍历元素，所以效率比ArrayList差 SetSet不保存重复元素 Iterator与Iterable 不同的包 java.lang.Iterable java.util.Iterator 数组增加元素 数组是定长，需要用Arrays.asList转换为List,再转换为ArrayList才能进行写操作 String[] arr = new String[2]; arr[0] = &quot;1&quot;; arr[1] = &quot;2&quot;; List&lt;String&gt; listArr = new ArrayList&lt;&gt;(Arrays.asList(arr)); listArr.add(2,&quot;5&quot;); java Native 方法 native方法 native关键字说明其修饰的方法是一个原生态方法，方法对应的实现不是在当前文件，而是在用其他语言（如C和C++）实现的文件中。Java语言本身不能对操作系统底层进行访问和操作，但是可以通过JNI接口调用其他语言来实现对底层的访问。 JNI JNI是Java本机接口（Java Native Interface），是一个本机编程接口，它是Java软件开发工具箱（Java Software Development Kit，SDK）的一部分。JNI允许Java代码使用以其他语言编写的代码和代码库。Invocation API（JNI的一部分）可以用来将Java虚拟机（JVM）嵌入到本机应用程序中，从而允许程序员从本机代码内部调用Java代码。 Object是抽象类吗？ 查看Object源码可以看到，许多方法是没有实现体的，但是Object类并不是抽象类，因为这些没有方法体的方法用Native修饰，其实现体并不是java语言写的。 引用传递与值传递 引用传递与值传递 JAVA里除了8种基本类型传参数是值传递，其他的类对象传参数都是引用传递 java中的编译时类型和运行时类型 运行时类型与编译时类型 Java中的许多对象（一般都是具有父子类关系的父类对象）在运行时都会出现两种类型：编译时类型和运行时类型，例如：Person person = new Student();这行代码将会生成一个person变量，该变量的编译时类型是Person，运行时类型是Student。 Java的引用变量有两个类型，一个是编译时类型，一个是运行时类型，编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。如果编译时类型和运行时类型不一致，会出现所谓的多态 jdk打包与解压 打包命令 jar -cvf diaowen.war diaowen 解压命令 jar xvf diaowen.war 多个数组/lit遍历分别赋值到实体类的属性 数组操作(List一样原理) String[] opinionUserList = opinionUser.split(&quot;###&quot;); String[] opinionContentList = opinionContent.split(&quot;###&quot;); String[] deptList = dept.split(&quot;###&quot;); if (opinionUserList != null &amp;&amp; opinionUserList.length &gt; 1) { for (int i = 0; i &lt; opinionUserList.length; i++) { DocOpinion des = new DocOpinion(); //属性拷贝 BeanUtils.copyProperties(docOpinion, des); des.setOpinionUser(opinionUserList[i]); des.setOpinionContent(opinionContentList[i]); des.setOpinionDept(deptList[i]); //其他值(在if外层已经获取到值了) des.setOpinionCode(code); des.setOpinionCodeName(codeName); des.setStatus(&quot;0&quot;); des.setSystemNo(&quot;ROOT&quot;); //数据插入 docOpinionMng.insertDocOpinion(des); }]]></content>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tomcat]]></title>
    <url>%2F2017%2F04%2F29%2Ftomcat%2F</url>
    <content type="text"><![CDATA[tomcat目录结构 web项目发布到Tomcat的三种常用方式 将web项目直接放到tomcat的webapps目录下，tomcat会根据文件夹名称自动生成虚拟路径。这种方式在开发中经常用到，一般有集成开发工具自动帮助我们将项目发布到webapps目录下。 在conf目录下创建Catalina目录，在此目录下新建localhost目录在localhost目录下新建xx.xml(建议xml的名字与项目名对应，当多个项目存在时，方便查找。)该xml基本配置如下： &lt;#我是占位符#Context path=&quot;/项目名&quot; docBase=&quot;E:/xxxx/projectName&quot; reloadable=&quot;true&quot; /&gt; path:指定访问该Web应用的URL入口。 docBase 是项目实际路径，这里一般写一个绝对的磁盘路径，当然也可以写相对路径， 相对路径是相对于tomcat安装目录的webapps目录的，通常设置虚拟目录的目的 是将tomcat的安装和项目的保存分开，所以这里建议你使用磁盘绝对路径，并且 这个磁盘路径不是在tomcat安装目录下。 workDir 是指Tomcat解析Jsp转换为Java文件，并编译为class存放的文件夹， 设置在项目文件夹里面，可以避免移植到其他地方首次读取jsp文件需要重新解析 reloadable 如果这个属性设为true，tomcat服务器在运行状态下会监视在 WEB-INF/classes和WEB-INF/lib目录下class文件的改动，如果监测到有class 文件被更新的，服务器会自动重新加载Web应用。 配置tomcat 安装目录下的conf/server.xml &lt;Host name=&quot;loaclhost&quot;&gt;标签里面添加 &lt;Context path=&quot;/aaaa&quot; docBase=&quot;C:\AAAA\BBBB&quot; /&gt; eclipse的tomcat插件 插件下载，注意对应版本 http://www.eclipsetotale.com/tomcatPlugin.html 插件安装 解压安装 将下载的文件解压，放到eclipse的plugins目录下，再在eclipse的Preferences&gt;tomcat配置即可。 tomcat的三个端口8005 8005端口 &lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt; 关闭tomcat通信接口 8009 8009端口 &lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot;/&gt; 与其他http服务器通信接口，用于http服务器集合 8080 8080端口 &lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt; 建立http连接 用，如浏览器访问 同一台服务器多个tomcat 同一台服务器N个tomcat 每个Tomcat需要上门一套端口。 如果多个Tomcat安装在同一台操作系统上，需要分配N组3个端口，共N*3个不同的端口。 否则报错： java.net.BindException: Address already in use: JVM_Bind java.lang.Exception: Socket bind failed]]></content>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows下的多版本JDK切换配置]]></title>
    <url>%2F2017%2F04%2F26%2Fwindows%E4%B8%8B%E7%9A%84%E5%A4%9A%E7%89%88%E6%9C%ACJDK%E5%88%87%E6%8D%A2%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[windows下多JDK安装系统下仅安装有一个JDK时C:\Program Files\Java\jdk1.6.0_22\lib;. CLASSPATH C:\Program Files\Java\jdk1.6.0_21\bin; PATH C:\Program Files\Java\jdk1.6.0_21 JAVA_HOME 同一系统中存在多个JDK版本时由于实际需要，可能在我们的PC中安装有多个版本的JDK，并在需要是随时切换版本，考虑到切换版本时需要更改环境变量配置，因此我们可以这样做： 我的电脑(windows10企业版)下同时安装有jdk1.8.0_102和jdk1.6.0_43两个版本(分别在不同的目录文件夹下) 首先，配置两个 子JAVA_HOME JAVA_HOME8 C:\mysoft\Java\jdk1.8.0_102 JAVA_HOME6 C:\mysoft\Java6\jdk1.6.0_43 然后，配置一个 JAVA_HOME 并引用上面配置的 子JAVA_HOME 中的一个 JAVA_HOME %JAVA_HOME6% PATH和CLASSPATH环境变量配置 CLASSPATH %JAVA_HOME%\lib;. PATH %JAVA_HOME%\bin; 可选：PATH下：%JAVA_HOME%\jre\bin; 仅仅做到上面的几步是不够的 上述步骤完成后，有可能会发下，dos命令下java -vrsion和javac -version的版本不一致，因为在path变量中，会先加载C:\Windows\System32下的java.exe,如下如： windows/System32下的java.exe 所以，需要将PATH变量中的%JAVA_HOME%\bin;放在Oracle默认变量之前。至此，每当需要切换JDK版本时，只需要改 JAVA_HOME 中所引用的 子JAVA_HOME名称 即可。]]></content>
      <tags>
        <tag>JDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EJB相关]]></title>
    <url>%2F2017%2F04%2F20%2FEJB%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[EJB的三种bean1.会话bean(session bean) 负责与客户端交互，是编写业务逻辑的地方，在会话bean中科院通过jdbc直接操作数据库， 但是大多情况下都是通过实体bean来完成对数据库的操作。 2.实体bean(entity bean) 它实际上属于java持久化规范(JPA)里的技术，JPA的出现主要是为了简化现有的持久化开发工作和整合ORM技术， 结束现在Hibernate、TopLink等ORM框架各自为营的局面。 3.消息驱动bean(message-driven bean) 它是专门用于异步处理java消息的组建，具有处理大量病发消息的能力。 未完待续…]]></content>
      <tags>
        <tag>&lt;font size=6&gt;EJB&lt;/font&gt;</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java源码计划]]></title>
    <url>%2F2017%2F04%2F20%2Fjava%E6%BA%90%E7%A0%81%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[JDK源码阅读计划：JDK（Java SE Development Kit） Java运行时环境(JVM) Java的基础类库 是Java的开发工具 第一部分：Java运行时环境 对于JVM，就是往死里学，往死里研究，能有多深就多深。 第二部分：Java的基础类库 第一级别：精读源码 java.io java.lang java.util Exception和Error这一类的，就不用读源码了 第二级别：深刻理解 java.lang.reflect java.net javax.net.* java.nio.* java.util.concurrent.* 第三级别：会用即可 java.lang.annotation javax.annotation.* java.lang.ref java.math java.rmi.* javax.rmi.* java.security.* javax.security.* java.sql javax.sql.* javax.transaction.* java.text javax.xml.* org.w3c.dom.* org.xml.sax.* javax.crypto.* javax.imageio.* javax.jws.* java.util.jar java.util.logging java.util.prefs java.util.regex java.util.zip 第四级别：无视它 swing awt ... 第三部分：Java的开发工具 javac jmap jconsole jstac jvisualvm JDK的bin目录find …… 可以把第一级别的那些包称作基础，第二级别的那些包称为进阶。最重要的还是那万年不变的JVM，JVM才是Java根基的根本，再牛的类，没了JVM它也就是一个无用的class文件而已。 Linux实践计划 习惯并持续ubunutu环境下编程 未来接触 高并发 分布式]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程]]></title>
    <url>%2F2017%2F04%2F09%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[线程的生命周期 线程的生命周期(线程生命周期2.png) 线程各个状态 就绪状态 创建线程对象后，调用了线程的start()方法（此时线程只是进入了线程队列，等待获取CPU服务（cpu可能正在执行其他程序），具备运行条件，但是并不一定已经开始运行了） 运行状态 处于就绪咋混个太的线程，一旦线程获取到CPU的服务之后，就进入到了运行状态，开始执行run()方法里面的逻辑。 终止 线程的run()方法执行完毕，或者人为线程调用了stop()方法（该做法已经被淘汰），线程便进入终止状态。 阻塞 一个正在执行的线程在某些情况下，由于某种原因而暂时让出了CPU资源，暂停了自己的执行，便进入了阻塞状态，如调用 sleep()方法。 关于sleep()与wait()的补充说明 sleep暂停线程，但是监控状态仍然保持，结束后会自动恢复； sleep是线程类(Thread)的方法，wait是Object类的方法； sleep不释放对象锁，wait放弃对象锁。 wait后进入等待锁定池，对此对象发出notify或notifyAll()方法后获得对象锁进入运行状态 线程的分类 用户线程 运行在前台，执行具体的任务。 如：程序的主线程，连接网络的子线程等都是用户线程。 守护线程 运行在后台，为其他前台线程（用户线程）服务。 守护线程的特点： 一旦所有用户线程都结束运行，守护线程也会随JVM一起结束工作。 守护线程的应用： 如：数据库连接池中的监测线程（如，监测连接个数与连接超时情况）； JVM虚拟机启动后的监测线程（如：监测虚拟机内存使用情况、监测程序中持有情况）。 最常见的守护线程：垃圾回收线程。 设置守护线程 可以通过调用Thread类的setDaemon(true)方法来设置当前的线程为守护线程。 注意： 1.setDaemon(true)必须在start()方法之前调用，否则会抛出IllegalThreadStateException异常。 即：守护线程的设置一定要放在线程的启动之前。 2.在守护线程中产生的新线程也是守护线程； 3.不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑。 原因：一旦所有用户线程都结束运行，守护线程也会随JVM一起结束工作，如果用户线程都结束了，守护线程的读写操作或计算逻辑岂不是要跪… 线程的创建 1.继承Thread类 class MyThread extends Thread{ ...... @Override public void run(){ ...... } } MyThread mt = new MyThread();//创建线程 mt.start();//启动线程 2.实现Runnable接口 class MyThread implements Runnable{ ...... @Override public void run(){ ...... } } MyThread mt = new MyThread(); Thread td = new Thread(mt);//创建线程 td.start();//启动线程 对比总结 无论用哪种方法，都要new一个Thread类对象，用Thread类的start方法来启动线程。]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信开发]]></title>
    <url>%2F2017%2F04%2F01%2F%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[开发环境接入准备外网映射工具按照微信公众平台的开发者文档要求，验证消息的确来自微信服务器时需要用到URL可参考ngrok工具: http://ngrok.2bdata.com/#introduction 进行下载配置(我的ngrok程序放在了F盘根目录下了)： 每次用的时候都需要启动cmd命令端 f: cd ngrok ngrok -config=ngrok.cfg -subdomain xxx 8080 运行结果就是： Tunnel Status online Version 1.7/1.7 Forwarding http://xxx.tunnel.2bdata.com -&gt; 127.0.0.1:8080 http://xxx.tunnel.2bdata.com/ Forwarding https://xxx.tunnel.2bdata.com -&gt; 127.0.0.1:8080 Web Interface 127.0.0.1:4040 # Conn 0 Avg Conn Time 0.00ms 验证消息的确来自微信服务器根据微信开发者文档要求 signature：微信加密签名，signature结合了开发者填写的token参数和请求中的timestamp参数、nonce参数。 timestamp：时间戳 nonce： 随机数 echostr：随机字符串 开发者通过检验signature对请求进行校验（下面有校验方式）。若确认此次GET请求来自微信服务器， 请原样返回echostr参数内容，则接入生效，成为开发者成功，否则接入失败。加密/校验流程如下： 1）将token、timestamp、nonce三个参数进行字典序排序 2）将三个参数字符串拼接成一个字符串进行sha1加密 3）开发者获得加密后的字符串可与signature对比，标识该请求来源于微信 部分参考代码： /** * 校验工具类 */ public class checkUtil { private static String token = &quot;uxawsenyweixin&quot;; //检验方法 public static boolean checkSignature(String signature, String timestamp, String nonce) throws AesException { String[] array = new String[]{token, timestamp, nonce}; //排序 Arrays.sort(array); //拼接字符串 StringBuffer sb = new StringBuffer(); for (int i = 0; i &lt; array.length; i++) { sb.append(array[i]); } String str = sb.toString(); //SHA1加密 String sha1Str = getSHA1(str); return sha1Str.equals(signature); } //加密方法getSHA1实现 public static String getSHA1(String str) throws AesException { try { // SHA1签名生成 MessageDigest md = MessageDigest.getInstance(&quot;SHA-1&quot;); md.update(str.getBytes()); byte[] digest = md.digest(); StringBuffer hexstr = new StringBuffer(); String shaHex = &quot;&quot;; for (int i = 0; i &lt; digest.length; i++) { shaHex = Integer.toHexString(digest[i] &amp; 0xFF); if (shaHex.length() &lt; 2) { hexstr.append(0); } hexstr.append(shaHex); } return hexstr.toString(); } catch (Exception e) { e.printStackTrace(); throw new AesException(AesException.ComputeSignatureError); } } } 文本转XML /** * 文本对象转成xml * * @param textMessage * @return */ public static String textMessageToXml(TextMessage textMessage) { XStream xStream = new XStream(); xStream.alias(&quot;xml&quot;, textMessage.getClass()); return xStream.toXML(textMessage); } xml转文本(map) /** * xml转map * * @param request * @return * @throws IOException * @throws DocumentException */ public static Map&lt;String, String&gt; xmlToMap(HttpServletRequest request) throws IOException, DocumentException { Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); SAXReader reader = new SAXReader(); //读取xml中的数据 InputStream input = request.getInputStream(); Document document = reader.read(input); //获取根元素 Element root = document.getRootElement(); List&lt;Element&gt; list = root.elements(); //遍历list并存进map for (Element e : list) { map.put(e.getName(), e.getText()); } input.close(); return map; } 完整参考代码见： https://git.coding.net/uxaw/weixin-v0.1.git BAEuxawsen.duapp.comhttp://weixin1230.duapp.com/weixin_war/weixinServlet]]></content>
      <tags>
        <tag>&lt;font</tag>
        <tag>size=2&gt;微信&lt;/font&gt;</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker初探]]></title>
    <url>%2F2017%2F01%2F24%2FDocker%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[简介下载安装 https://www.docker.com/products/docker-toolbox https://hub.docker.com/explore/ https://c.163.com/ 使用命令未完待续…]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL基础]]></title>
    <url>%2F2016%2F12%2F20%2FSQL%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[概念SQL: 结构化查询语言(Structured Query Language) mysql配置程序F:\mysql\server\bin\MySQLInstanceConfig.exe 数据库的删除命令drop 表索引，表的存储过程，表结构和数据 都会删除 delete 删除部分表记录(可以配合where条件) truncate 删除表的所有记录 SQL语法 SQL语句可以在单行或多行书写，以分号结尾 可使用空格和缩进来增强语句的可读性 MySQL不区别大小写，建议关键字使用大写如SELECT*FROM booktable; SQL语句分类1. DDL（Data Definition Language）：数据定义语言，用来定义数据库对象：库、表、列等； &gt; 创建、删除、修改：库、表结构！！！ DDL：数据库或表的结构操作(*****) 2. DML（Data Manipulation Language）：数据操作语言，用来定义数据库记录（数据）； &gt; 增、删、改：表记录 DML：对表的记录进行更新（增、删、改）(*****) 3. DCL（Data Control Language）：数据控制语言，用来定义访问权限和安全级别； DCL：对用户的创建，及授权！ 4. DQL*****（Data Query Language）：数据查询语言，用来查询记录（数据）。 DQL：对表的记录的查询（*****，难点） DML(对表的记录进行更新（增、删、改）)1. 插入数据* INTERT INTO 表名(列名1,列名2, ...) VALUES(列值1, 列值2, ...); &gt; 在表名后给出要插入的列名，其他没有指定的列等同与插入null值。所以插入记录总是插入一行，不可能是半行。 &gt; 在VALUES后给出列值，值的顺序和个数必须与前面指定的列对应 * INTERT INTO 表名 VALUES(列值1, 列值2) &gt; 没有给出要插入的列，那么表示插入所有列。 &gt; 值的个数必须是该表列的个数。 2. 修改数据* UPDATE 表名 SET 列名1=列值1, 列名2=列值2, ... [WHERE 条件] * 条件(条件可选的)： &gt; 条件必须是一个boolean类型的值或表达式：UPDATE t_person SET gender=&apos;男&apos;, age=age+1 WHERE sid=&apos;1&apos;; &gt; 运算符：=、!=、&lt;&gt;、&gt;、&lt;、&gt;=、&lt;=、BETWEEN...AND、IN(...)、IS NULL、NOT、OR、AND 例句： WHERE age &gt;= 18 AND age &lt;= 80 WHERE age BETWEEN 18 AND 80 WHERE name=&apos;zhangSan&apos; OR name=&apos;liSi&apos; WHERE name IN (&apos;zhangSan&apos;, &apos;liSi&apos;) WHERE age IS NULL, 不能使用等号 WHERE age IS NOT NULL DQL:数据查询语言，用来查询记录（数据）一、 基本查询1. 字段(列)控制 1) 查询所有列 SELECT * FROM 表名; SELECT * FROM emp; --&gt; 其中“*”表示查询所有列 2) 查询指定列 SELECT 列1 [, 列2, ... 列N] FROM 表名; SELECT empno, ename, sal, comm FROM 表名; 3) 完全重复的记录只一次 当查询结果中的多行记录一模一样时，只显示一行。一般查询所有列时很少会有这种情况，但只查询一列（或几列）时，这总可能就大了！ SELECT DISTINCT * | 列1 [, 列2, ... 列N] FROM 表名; SELECT DISTINCT sal FROM emp; --&gt; 保查询员工表的工资，如果存在相同的工资只显示一次！ 4) 列运算 I 数量类型的列可以做加、减、乘、除运算 SELECT sal*1.5 FROM emp; SELECT sal+comm FROM emp; II 字符串类型可以做连续运算 SELECT CONCAT(&apos;$&apos;, sal) FROM emp; III 转换NULL值 有时需要把NULL转换成其它值，例如com+1000时，如果com列存在NULL值，那么NULL+1000还是NULL，而我们这时希望把NULL当前0来运算。 SELECT IFNULL(comm, 0)+1000 FROM emp; --&gt; IFNULL(comm, 0)：如果comm中存在NULL值，那么当成0来运算。 IV 给列起别名 你也许已经注意到了，当使用列运算后，查询出的结果集中的列名称很不好看，这时我们需要给列名起个别名，这样在结果集中列名就显示别名了 SELECT IFNULL(comm, 0)+1000 AS 奖金 FROM emp; --&gt; 其中AS可以省略 例句： 查询指定列 SELECT empno,ename,sal 工资,comm FROM emp; 查询不重复记录 SELECT DISTINCT job,sal,ename FROM emp; 查询结果做运算 SELECT*,sal*2 实际工资 FROM emp; IFNULL条件转换NULL值 SELECT*,sal+IFNULL(comm,0) 实际绩效工资 FROM emp; CONCAT字符串连接 SELECT CONCAT(&quot;我是&quot;,ename) FROM emp; SELECT CONCAT(&apos;我是&apos;,ename) FROM emp; 用IS NOT NULL做NULL条件判断，不能用!=NULL或&lt;&gt;NULL SELECT*FROM emp WHERE comm IS NOT NULL; 给列起别名 SELECT ename AS 姓名,job AS 工作岗位 FROM emp; 或 SELECT ename 姓名,job 工作岗位 FROM emp; 2.条件控制 1) 条件查询 与前面介绍的UPDATE和DELETE语句一样，SELECT语句也可以使用WHERE子句来控制记录。 * SELECT empno,ename,sal,comm FROM emp WHERE sal &gt; 10000 AND comm IS NOT NULL; * SELECT empno,ename,sal FROM emp WHERE sal BETWEEN 20000 AND 30000; * SELECT empno,ename,job FROM emp WHERE job IN (&apos;经理&apos;, &apos;董事长&apos;); 2) 模糊查询 当你想查询姓张，并且姓名一共两个字的员工时，这时就可以使用模糊查询 * SELECT * FROM emp WHERE ename LIKE &apos;张_&apos;; --&gt; 模糊查询需要使用运算符：LIKE，其中_匹配一个任意字符，注意，只匹配一个字符而不是多个。 --&gt; 上面语句查询的是姓张，名字由两个字组成的员工。 * SELECT * FROM emp WHERE ename LIKE &apos;___&apos;; /*姓名由3个字组成的员工*/ 如果我们想查询姓张，名字几个字可以的员工时就要使用“%”了。 SELECT * FROM emp WHERE ename LIKE &apos;张%&apos;; --&gt; 其中%匹配0~N个任意字符，所以上面语句查询的是姓张的所有员工。 SELECT * FROM emp WHERE ename LIKE &apos;%阿%&apos;; --&gt; 千万不要认为上面语句是在查询姓名中间带有阿字的员工，因为%匹配0~N个字符，所以姓名以阿开头和结尾的员工也都会查询到。 SELECT * FROM emp WHERE ename LIKE &apos;%&apos;; --&gt; 这个条件等同与不存在，但如果姓名为NULL的查询不出来！ 例句： 条件查询 按工资范围查询 SELECT*FROM emp WHERE sal &gt;= 2000 AND sal &lt;=20000; SELECT*FROM emp WHERE sal BETWEEN 2000 AND 20000; 按职位查询 SELECT * FROM emp WHERE job IN(&apos;销售员&apos;,&apos;经理&apos;) ORDER BY job; 关键字：IN 或 NOT IN 模糊查询 姓张，且为两个字 SELECT*FROM emp WHERE ename LIKE &apos;张_&apos;; 姓张，字数不限 SELECT*FROM emp WHERE ename LIKE&apos;张%&apos;; 查询以 牛 字结尾的姓名 SELECT*FROM emp WHERE ename LIKE &apos;%牛&apos;; 查询姓名中带 牛 字的，无论是开头，中间，还是结尾带 牛 字的，都会被查询出来 SELECT*FROM emp WHERE ename LIKE&apos;%牛%&apos;; 二、 排序1) 升序 SELECT * FROM WHERE emp ORDER BY sal ASC; --&gt; 按sal排序，升序！ --&gt; 其中ASC是可以省略的 2) 降序 SELECT * FROM WHERE emp ORDER BY comm DESC; --&gt; 按comm排序，降序！ --&gt; 其中DESC不能省略 3) 使用多列作为排序条件 SELECT * FROM WHERE emp ORDER BY sal ASC, comm DESC; --&gt; 使用sal升序排，如果sal相同时，使用comm的降序排 例句： 按sal升序排列，若sal相同，按comm降序排列 SELECT*FROM emp ORDER BY sal ASC,comm DESC; 三、聚合函数(用来做某列的纵向运算的) 聚合函数用来做某列的纵向运算，在条件中不能出现聚合函数。 1) COUNT SELECT COUNT(*) FROM emp; --&gt; 计算emp表中所有列都不为NULL的记录的行数 SELECT COUNT(comm) FROM emp; --&gt; 云计算emp表中comm列不为NULL的记录的行数 2) MAX SELECT MAX(sal) FROM emp; --&gt; 查询最高工资 3) MIN SELECT MIN(sal) FROM emp; --&gt; 查询最低工资 4) SUM SELECT SUM(sal) FROM emp; --&gt; 查询工资合 5) AVG SELECT AVG(sal) FROM emp; --&gt; 查询平均工资 例句： 查询总人数(注意，下句中数字1和*的意思相同，都表示所有。不论是1还是2，3等，都一样的意思) SELECT COUNT(*) FROM emp; SELECT COUNT(1) FROM emp; 查询工资sal总额 SELECT SUM(sal) FROM emp; 查询平均工资 SELECT AVG(sal) FROM emp; 查询最高工资的员工 SELECT MAX(sal),ename FROM emp; 查询最低工资的员工 SELECT MIN(sal),ename FROM emp; 查询以上所有 SELECT COUNT(*) 总人数,COUNT(sal) 工资总和,AVG(sal) 平均工资,MAX(sal) 最高工资,MIN(sal) 最低工资 FROM emp; 三、 分组查询分组查询是把记录使用某一列进行分组，然后查询组信息。 例如：查看所有部门的记录数。 SELECT deptno, COUNT(*) FROM emp GROUP BY deptno; --&gt; 使用deptno分组，查询部门编号和每个部门的记录数 SELECT job, MAX(SAL) FROM emp GROUP BY job; --&gt; 使用job分组，查询每种工作的最高工资 组条件 以部门分组，查询每组记录数。条件为记录数大于3 SELECT deptno, COUNT(*) FROM emp GROUP BY deptno HAVING COUNT(*) &gt; 3; 关键字的先后顺序： select from where （分组前）条件关键字 group by 分组关键字 having (分组)后置条件关键字 order by 排序关键字 例句： 查询各部门人数 SELECT deptno 部门编号,COUNT(*) 总人数 FROM emp GROUP BY deptno; 查询各岗位人数 SELECT job 工作岗位,COUNT(*) 人数 FROM emp GROUP BY job; 查询各岗位中工资大于20000的人数-------------------(分组前的条件) SELECT job,COUNT(*) 人数 FROM emp WHERE sal&gt;=2000 GROUP BY job; 查询各岗位中工资大于2000，且人数不少于3---------------(分组后的条件) SELECT job 工作岗位,COUNT(*) FROM emp WHERE sal&gt;=2000 GROUP BY job HAVING COUNT(*)&gt;=3; HAVING在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与合计函数一起使用。 四、 limit子句(方言)LIMIT用来限定查询结果的起始行，以及总行数。 注意：mysql记录下标从0计数 例如：查询起始行为第5行，一共查询3行记录 SELECT * FROM emp LIMIT 4, 3; --&gt; 其中4表示从第5行开始，其中3表示一共查询3行。即第5、6、7行记录。 select * from emp limit 0, 5; 1. 一页的记录数：10行 2. 查询第3页 select * from emp limit 20, 10; (当前页-1) * 每页记录数 (3-1) * 10 查询第17页，每页8条记录 (17-1) * 8, 8 例句： 查询第3页，每页4条记录 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (3-1）*4=8,即，从第9行记录开始查询，第9行下标为8 SELECT * FROM stu LIMIT 8,4; 五、 多表查询多表查询分类： * 合并结果集(了解) * 连接查询 * 子查询 合并结果集 合并结果集 * 要求被合并的表(实际是被合并的结果集)中，列的类型和列数相同（上下合并，而不是横向合并） * UNION，去除重复行 * UNION ALL，不去除重复行 SELECT * FROM cd UNION ALL SELECT * FROM ab; 例句： 不去除重复行 SELECT deptno FROM emp UNION ALL SELECT deptno FROM dept; 去除重复行 SELECT deptno FROM emp UNION SELECT deptno FROM dept; 内链接（内连接多表查询） * 方言：SELECT * FROM 表1 别名1, 表2 别名2 WHERE 别名1.xx=别名2.xx * 标准：SELECT * FROM 表1 别名1 INNER JOIN 表2 别名2 ON 别名1.xx=别名2.xx * 自然：SELECT * FROM 表1 别名1 NATURAL JOIN 表2 别名2 * 内连接查询出的所有记录都满足条件。 内连接查询的语句逻辑可以参考下面SQL语句推导： SELECT * FROM emp,dept; 下列三种SQL语句，建议使用标准版语句，便于数据库的更换； 例句： 标准版（通用）SQL语句 查询每个员工的姓名，工资，部门名称 SELECT e.ename,e.sal,d.dname FROM emp e INNER JOIN dept d ON e.deptno=d.deptno; mysql方言版 查询每个员工的姓名，工资，部门名称 SELECT e.ename,e.sal,d.dname FROM emp e,dept d WHERE e.deptno=d.deptno; 自然版 查询每个员工的姓名，工资，部门名称 SELECT e.ename,e.sal,d.dname FROM emp e NATURAL JOIN dept d 外连接(外连接多表查询) 外连接有一主一次，左外即左表为主 如下面例子：即emp为主，那么主表中所有的记录无论满足条件与否，都会被打印出来。 当不满足条件是，右表部门使用NULL来补位。 左外连接 查询所有员工的姓名，薪水，所属部门(部门名称) SELECT e.ename,e.sal,d.dname FROM emp e LEFT OUTER JOIN dept d ON e.deptno=d.deptno; ------------用IFNULL做判断后的假名------------------ SELECT e.ename,e.sal,IFNULL(d.dname,&apos;无部门&apos;) AS dname FROM emp e LEFT OUTER JOIN dept d ON e.deptno=d.deptno; 右外连接emp 查询所有部门中员工的姓名，薪水，所属部门(部门名称) SELECT e.ename,e.sal,d.dname FROM emp e RIGHT OUTER JOIN dept d ON e.deptno=d.deptno; 全连接 查询所有部门的所有员工的姓名，薪水，所属部门(部门名称)---利用左外连接和右外连接 进行合并结果集 完成全外连接查询（因为mysql不支持全连接查询） SELECT e.ename,e.sal,d.dname FROM emp e LEFT OUTER JOIN dept d ON e.deptno=d.deptno UNION SELECT e.ename,e.sal,d.dname FROM emp e RIGHT OUTER JOIN dept d ON e.deptno=d.deptno; 子查询 子查询：一条查询语句中有多个SELECT关键字，就是子查询(也叫嵌套查询) 1. 出现的位置： select后也可以有，但是不规范，所以不用 * where后作为条件存在 * from后作为表存在(多行多列) 2. 条件 * (***)单行单列：SELECT * FROM 表1 别名1 WHERE 列1 [=、&gt;、&lt;、&gt;=、&lt;=、!=] (SELECT 列 FROM 表2 别名2 WHERE 条件) * (**)多行单列：SELECT * FROM 表1 别名1 WHERE 列1 [IN, ALL, ANY] (SELECT 列 FROM 表2 别名2 WHERE 条件) * (*)单行多列：SELECT * FROM 表1 别名1 WHERE (列1,列2) IN (SELECT 列1, 列2 FROM 表2 别名2 WHERE 条件) * (***)多行多列：SELECT * FROM 表1 别名1 , (SELECT ....) 别名2 WHERE 条件 例句： 1. 查询本公司工资最高的员工信息 select* from emp where sal= (select max(sal) from emp); 2. 查询emp表中职位和部门与殷天正一样的所有员工的姓名，部门，工作岗位 SELECT b.ename,b.deptno,b.job FROM emp b WHERE (deptno,job) IN (SELECT deptno,job FROM emp WHERE ename=&apos;殷天正&apos;) 3．查询员工中工资比30部门中所有人工资高的员工的姓名，工资 SELECT a.ename,a.sal FROM emp a WHERE sal &gt; ALL (SELECT MAX(sal) FROM emp WHERE deptno=&apos;30&apos;) 3. 查询员工中工资比任何一个30部门中工资高的员工的姓名，工作岗位，工资 SELECT a.ename,a.job,a.sal FROM emp a WHERE sal&gt; ANY (SELECT sal FROM emp WHERE deptno=&apos;30&apos;) 员工表练习 员工表建表SQL： http://op05inpyd.bkt.clouddn.com/%E5%91%98%E5%B7%A5%E8%A1%A8%E5%BB%BA%E8%A1%A8SQL.sql 员工表查询练习SQL: http://op05inpyd.bkt.clouddn.com/%E5%91%98%E5%B7%A5%E8%A1%A8SQL%E5%AD%A6%E4%B9%A0.sql 多表查询练习之学生表 参考博客： http://www.cnblogs.com/qixuejia/p/3637735.html 建表SQL http://op05inpyd.bkt.clouddn.com/%E5%AD%A6%E7%94%9F%E8%A1%A8%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%BB%BA%E8%A1%A8%E8%AF%AD%E5%8F%A5.sql 学生表多表查询练习： SQL文件链接： http://op05inpyd.bkt.clouddn.com/%E5%AD%A6%E7%94%9F%E8%A1%A8%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0%E7%AD%94%E6%A1%88%E8%AF%AD%E5%8F%A5.sql SQL语句 2017/9/22 9:54:52 (改) 1、查询“001”课程比“002”课程成绩高的所有学生的学号 --------------子查询版------------------------------- SELECT a.sid 学生编号 FROM (SELECT sid,score FROM sc WHERE cid=&apos;1&apos;)a, (SELECT sid,score FROM sc WHERE cid=&apos;2&apos;)b WHERE a.score&gt;b.score AND a.sid=b.sid -----------------非子查询版--------------------------- SELECT a.* FROM sc AS a LEFT JOIN sc AS b ON a.Sid = b.Sid AND a.Cid = &apos;1&apos; AND b.Cid=&apos;2&apos; WHERE a.score&gt;b.score 2、查询平均成绩大于60分的同学的学号和平均成绩 SELECT sid,a.score FROM (SELECT sid,AVG(score) score FROM sc GROUP BY sid)a WHERE a.score&gt;60; -----------------非子查询版--------------------------- SELECT sid,AVG(SCORE) FROM sc GROUP BY sid HAVING AVG(SCORE) &gt;60; 3、查询所有同学的学号、姓名、选课数、总成绩 SELECT a.sid,a.sname,b.num,c.sumscore FROM student a, (SELECT sid,COUNT(cid) num FROM sc GROUP BY sid) b, (SELECT sid,SUM(score) sumscore FROM sc GROUP BY sid) c WHERE a.sid=b.sid AND b.sid=c.sid; -----------------非子查询版--------------------------- SELECT a.sid,a.sname,COUNT(b.Cid),SUM(b.score) FROM student AS a LEFT JOIN sc AS b ON a.Sid = b.Sid GROUP BY a.Sid; 4、查询姓“叶”的老师的个数 SELECT COUNT(*) 个数 FROM teacher WHERE Tname LIKE &apos;叶%&apos;; -----------------或----------------------------------- SELECT COUNT(1) 个数 FROM teacher WHERE Tname LIKE &apos;叶%&apos;; 5、查询没学过“叶平”老师课的同学的学号、姓名 有误： SELECT a.sid ,b.sname FROM sc a,student b WHERE cid != (SELECT cid FROM course WHERE tid = (SELECT tid FROM teacher WHERE tname=&apos;叶平&apos;)) AND a.sid=b.sid GROUP BY sid; -------------------------改---------------------------------- SELECT Sid,Sname FROM student WHERE sid NOT IN( SELECT a.Sid FROM student AS a LEFT JOIN sc AS b ON b.Sid = a.Sid LEFT JOIN course AS c ON c.Cid = b.Cid INNER JOIN teacher AS d ON d.Tid = c.Tid AND d.Tname =&apos;叶平&apos; ) 6、查询学过“001”并且也学过编号“002”课程的同学的学号、姓名 SELECT a.sid,c.sname FROM student c, (SELECT sid FROM sc WHERE cid=1)a, (SELECT sid FROM sc WHERE cid=2)b WHERE a.sid = b.sid AND c.sid=b.sid 7、查询学过“叶平”老师所教的所有课的同学的学号、姓名 SELECT a.sid,sname FROM sc a,student b WHERE cid = (SELECT cid FROM course WHERE tid = (SELECT tid FROM teacher WHERE tname=&apos;叶平&apos;)) AND a.sid=b.sid 8、查询课程编号“002”的成绩比课程编号“001”课程低的所有同学的学号、姓名 SELECT a.sid,sname FROM student c, (SELECT sid,score FROM sc WHERE cid=&apos;1&apos;)a, (SELECT sid,score FROM sc WHERE cid=&apos;2&apos;)b WHERE a.score&gt;b.score AND a.sid = b.sid AND c.sid=b.sid 9、查询所有课程成绩小于60分的同学的学号、姓名 SELECT b.sid,a.sname FROM student a, (SELECT sid FROM sc WHERE score &lt;60)b WHERE a.sid=b.sid GROUP BY sname 10、查询没有学全所有课的同学的学号、姓名 SELECT a.sid,sname FROM student b, (SELECT sid,COUNT(cid) anum FROM sc GROUP BY sid)a WHERE a.anum&lt; (SELECT COUNT(cname)bnum FROM course) AND a.sid=b.sid MySql的备份与恢复数据库mysqldump -uroot -p123 exam&gt;C:\mydb1.sql 存储过程存储过程的优点 增强SQL语句的功能和灵活性； 实现较快的执行速度； 减少网络流量。 创建存储过程 查询中拼接字符串 拼接列与字符串 select username,password,CONCAT(username,&quot;@test.com&quot;) as email from pre_ucenter_members 未完待续…..]]></content>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven相关]]></title>
    <url>%2F2016%2F11%2F19%2FMaven%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[maven简介1.maven可以很方便的管理项目依赖关系。 2.maven可以伴随整个项目生命周期，关于这一点，下面Maven命令中可窥见一斑。 maven安装配置1.windows下配置环境变量： M2_HOME F:\apache-maven-3.5.0 在path下追加： %M2_HOME%\bin; 查看maven版本以及验证环境变量是否配置成功： cmd下 mvn -version maven默认依赖包下载存放位置： C:\Users\UX\.m2 2.自定义修改： 将F:\apache-maven-3.5.0\conf下的settings.xml复制到C:\Users\UX\.m2的.m2文件夹下 做出下列两项修改： 1.修改为官方推荐的仓库中心： 配置文件： http://op05inpyd.bkt.clouddn.com/settings.xml &lt;mirror&gt; &lt;id&gt;UK&lt;/id&gt; &lt;name&gt;UK Central&lt;/name&gt; &lt;url&gt;http://uk.maven.org/maven2&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 或者改为阿里的： &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 2.自定义依赖包下载到本地的存放位置： &lt;localRepository&gt;F:\MavenRepository\repository &lt;/localRepository&gt; Maven命令1.maven基本命令： mvn -v 查看maven版本信息 mvn compile 编译项目 mvn test 测试 mvn package 打包项目 mvn clean 删除target mvn install 将本项目安装到本地仓库中 2.名词解释： groupId： 组织名，一般是公司网站的反写+项目名 artifactId： 项目名-模块名 version： 版本号 -Dpackage： 代码所在的包名 3.使用maven创建模板项目： 例如： mvn archetype:generate -DgroupId=com.ux.mavenproject -DartifactId=mavenproject-demo -Dversion=1.0.0SNAPSHOT -Dpackage=com.ux.mavenproject.demo -DarchetypeCatalog=internal 回车 回车 Y 创建maven项目时的参数 添加此参数可快速创建maven项目，避免下载缓慢问题archetypeCatalog=internal mac下安装maven mac下安装maven export M2_HOME=/Users/ux/Applications/apache-maven-3.5.2 export PATH=$PATH:$M2_HOME/bin source ~/.bash_profile Maven 依赖搜索顺序 当我们执行 Maven 构建命令时，Maven 开始按照以下顺序查找依赖的库： 步骤 1 － 在本地仓库中搜索，如果找不到，执行步骤 2，如果找到了则执行其他操作。 步骤 2 － 在中央仓库中搜索，如果找不到，并且有一个或多个远程仓库已经设置，则执行步骤 4，如果找到了则下载到本地仓库中已被将来引用。 步骤 3 － 如果远程仓库没有被设置，Maven 将简单的停滞处理并抛出错误（无法找到依赖的文件）。 步骤 4 － 在一个或多个远程仓库中搜索依赖的文件，如果找到则下载到本地仓库已被将来引用，否则 Maven 将停止处理并抛出错误（无法找到依赖的文件）。]]></content>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git操作相关]]></title>
    <url>%2F2016%2F10%2F19%2FGit%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[加入git版本控制 基本命令 1.创建项目 2.git init 3.git add [需要加入版本控制的文件] 4.git commit -m&quot;提交信息&quot; 5.关联远程仓库 git remote add origin https://git.coding.net/uxaw/surveyDemo.git 6. 首次推动并关联远分枝 git push -u origin master 拉取或者推送时如果提示分支找不到，需要到远程仓库合并一下分支. 我们第一次推送master分支时，加上了 –u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来 7.拉取远程仓库：$ git pull [remoteName] [localBranchName] $ git pull （可省略origin master） 8. 以后推送 git push origin master 9.切换分支 git checkout -b mytagname tagname tagname：分支名称 mytagname：存到本地的重命名，建议和原分支名称一致 *.推送远程仓库：$ git push [remoteName] [localBranchName] $ git push origin master:matser 参考链接：http://blog.csdn.net/free_wind22/article/details/50967723 10.更改远程仓库链接： 如：修改远程仓库项目名将导致项目的访问 URL（包含 Git 仓库的 URL）将会改变，在此之前的 URL 地址将失效。 Git仓库地址修改命令： git remote set-url origin [NEW_URL] 忽略已跟踪文件 还没有加到版本控制中 (1)还没有Git add 在 .gitignore中添加 (2)已经git add 先git rm -r --cached 文件 在.gitignore中添加 已经加到版本控制中 先git rm -r --cached 文件名 再在.gitignore中添加 最后gti commit -m提交.gitignore&apos; git bash下创建gitignore的命令： touch .gitignore Git相关命令 查看状态： git status 远程仓库版本覆盖本地版本： $ git fetch –all //与远程同步 $ git reset --hard origin/master //将本地的状态回退到和远程的一样 git fetch 只是下载远程的库的内容，不做任何的合并git reset 把HEAD指向刚刚下载的最新的版本 查看所关联的远程仓库 $ git remote -v 创建.gitignore文件 git bash下创建gitignore的命令： touch .gitignore 设置账户 设置用户名和邮箱： git config --global user.name &quot;ux&quot; git config --global user.email &quot;ux@gmail.com&quot; 查看用户名和邮箱 $ git config user.name $ git config user.email Git里程碑 创建添加里程碑 创建本地里程碑： git tag v1.0 删除本地里程碑： git tag -d v1.0 共享推送里程碑到远成仓库： git push origin v1.0 删除远程仓库里程碑： git push origin :v1.0 Git第三方客户端SourceTree sourcetree git第三方桌面客户端： Source Tree https://www.sourcetreeapp.com/ 安装sourceTree时跳过账户登录 C:\Users\UX\AppData\Local\Atlassian\SourceTree下新建(或者替换)accounts.json （UX是我的计算机用户名,找到自己的对应即可,我的版本是2.0.19.1） accounts.json内容如下： [ { &quot;$id&quot;: &quot;1&quot;, &quot;$type&quot;: &quot;SourceTree.Api.Host.Identity.Model.IdentityAccount, SourceTree.Api.Host.Identity&quot;, &quot;IsDefault&quot;: false, &quot;Authenticate&quot;: true, &quot;HostInstance&quot;: { &quot;$id&quot;: &quot;2&quot;, &quot;$type&quot;: &quot;SourceTree.Host.Atlassianaccount.AtlassianAccountInstance, SourceTree.Host.AtlassianAccount&quot;, &quot;Host&quot;: { &quot;$id&quot;: &quot;3&quot;, &quot;$type&quot;: &quot;SourceTree.Host.Atlassianaccount.AtlassianAccountHost, SourceTree.Host.AtlassianAccount&quot;, &quot;Id&quot;: &quot;atlassian account&quot; }, &quot;BaseUrl&quot;: &quot;https://id.atlassian.com/&quot; }, &quot;Credentials&quot;: { &quot;$id&quot;: &quot;4&quot;, &quot;$type&quot;: &quot;SourceTree.Model.BasicAuthCredentials, SourceTree.Api.Account&quot;, &quot;Username&quot;: &quot; &quot;, &quot;Email&quot;: null, &quot;AvatarURL&quot;: null, &quot;AuthenticationScheme&quot;: { &quot;$type&quot;: &quot;SourceTree.Model.BasicAuthAuthenticationScheme, SourceTree.Api.Account&quot;, &quot;Value&quot;: &quot;Username/Password&quot;, &quot;Name&quot;: &quot;Basic&quot;, &quot;Description&quot;: &quot;Password&quot;, &quot;HeaderValuePrefix&quot;: &quot;Basic&quot;, &quot;UsernameIsRequired&quot;: true }, &quot;Id&quot;: &quot; &quot;, &quot;DisplayName&quot;: null } } ] 或者到此链接复制： http://op05inpyd.bkt.clouddn.com/accounts.json 多git服务使用配置(ssh key)Mac下配置多个Git账户(ssh key方式)查看用户名和邮箱 git config user.name git config user.email 1.如果之前已经使用该命令进行配置，则先使用如下命令清除git config --global --unset user.name git config --global --unset user.email 2.设置全局账户git config --global user.name &quot;ux&quot; git config --global user.email &quot;ux@gmail.com&quot; 3.对每个账户生成一对密钥1.首先进入保存秘钥的目录(mac下路径如下) cd ~/.ssh 2.然后，根据账户邮箱生成秘钥。例如我在GitHub上的邮箱是ux@gmail.com，则命令为： ssh-keygen -t rsa -C &quot;ux@gmail.com&quot; 3.输入完成后，会有如下提示 Generatingpublic/privatersa key pair.Enter fileinwhich to save the key (/Users/liugui/.ssh/id_rsa): 这里要求对秘钥进行命名，默认的文件名是id_rsa。为了方便区分，我这里命名为id_rsa_github 接下来的提示都直接进行回车，直到秘钥生成。通过ls命令，可以看到刚刚生成的密钥对id_rsa_github和id_rsa_github.pub。 其中id_rsa_github.pub是公钥 4.私钥添加到本地ssh-add ~/.ssh/id_rsa_github // 将GitHub私钥添加到本地 5.对本地秘钥进行配置由于添加了多个密钥文件，所以需要对这多个密钥进行管理。在.ssh目录下新建一个config文件： touch config config配置内容如下： #############github############### #网站的别名，随意取 Host github.com #托管网站的域名 HostName github.com #托管网站上的用户名 User uxawseny #使用的密钥文件 IdentityFile ~/.ssh/is_rsa_github ##############公司git################ #网站的别名，随意取 Host git.cp.com #托管网站的域名 HostName git.cp.com #托管网站上的用户名 User myname #使用的密钥文件 IdentityFile ~/.ssh/id_rsa_cp 这里的host name最好和git服务器的SSH下载方式上的 git@github.com:uxawseny/test.git @符号后面的一直，这样每次clone时就默认不用手动更改了， 比如github的ssh key的host name，就命名为github.com 6.公钥添加到托管网站将公钥id_rsa_github.pub中的内容复制到github 7.测试是否成功这时候，可以测试一下配置是否成功，测试命令使用别名。例如，对于GitHub，本来应该使用的测试命令是： ssh -T git@github.com 8.选择SSH协议的复制命令，如对于GitLab上代码库test，其复制命令为git clone git@github.com:ux/test.git 9.添加其他git账户依次操作即可10.做完这些后几个清除全局用户名和邮箱，否则不同仓库提交时的用户名和邮箱信息都是一样的。git config --global --unset user.name git config --global --unset user.email 用上述命令清除掉全局用户名和邮箱信息后，再在每个项目中设置用户名和邮箱信息（不使用全局参数） git config --unset user.name git config--unset user.email 或者在IDEA中提交时再填写用户名和邮箱，但是要记得取消勾选&quot;作为全局设置&quot; 参考文章 https://www.jianshu.com/p/6507ce357ad2 github项目fork之后实时同步原项目的更新1.将fork到的项目git clone拉取到本地2.进到拉取的project目录下，然后增加远程分支(fork的原始项目地址)，名为 update_new（名字任意）到本地git remote add update_new https://github.com/_original/_project.git 3.查看分支时候添加成功（会发现多了刚才添加的远程分支）git remote -v 4.然后把远程原始分支 update_new 的代码拉到本地git fetch update_new 5.合并对方远程原始分支 update_new 的代码git merge update_new/master 6.最后把最新的代码推送到你的github上git push origin master 参考文章 https://www.cnblogs.com/relucent/p/6479213.html]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo引擎及Next主题]]></title>
    <url>%2F2016%2F04%2F19%2FHexo%E5%BC%95%E6%93%8E%E5%8F%8ANext%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Hexo初始化博客框架windows/macHexo安装和搭建依赖Nodejs和Git,可自行下载，下面的命令都是在上述环境OK的情况下进行的 windows下，可以新建文件夹，然后右键运行git bash,运行各种命令。 git bash下运行如下命令： 1.安装Hexo 安装命令： npm install -g hexo-cli macos下要以管理员权限执行： sudo npm install -g hexo-cli 更新命令（hexo 3.4.3出现文章目录书签链接问题，更新3.4.4即可解决bug）： npm update hexo 如果提示文件夹写入权限不足，则： sudo npm update hexo 卸载： macos下要以管理员权限执行： sudo npm uninstall hexo-cli -g 如果卡死，则这样安装： npm install -g hexo-cli --no-optional macos下要以管理员权限执行： sudo npm install -g hexo-cli --no-optional 注意： 将Windows平台下的hexo文件直接全部拷贝到macOS下使用，可能会报下面这个错误： Cannot find module &apos;./build/Release/DTraceProviderBindings 此时只需要在另外一个文件键执行 hexo init npm install 然后将这个新文件夹中的node_modules文件夹复制并替换掉原来Windows平台下的node_modules文件夹即可。 然后又报错： ERROR Deployer not found: git 执行这个命令即可： sudo npm install hexo-deployer-git --save 20171207更 本人懒得再配置_config.yml以及主题相关配置文件，所以macOS下git,node.js,hexo-cli安装完后直接将Windows平台下的hexo整个文件夹复制到macOS下，执行时报模块找不到错误，虽然不影响正常执行结果的产生，但是看着不爽。经测试，替换node_modules可以解决报错问题。(2017-12-07) 20180825更： 安装Node.js v8.11.4后一并带的npm v5.6.0，此时直接执行sudo npm install -g hexo-cli后安装完成后并没有报任何错，直接执行hexo g -d也完全正常，下面是安装完成后的日志：（2018-08-25） This package has installed: • Node.js v8.11.4 to /usr/local/bin/node • npm v5.6.0 to /usr/local/bin/npm Make sure that /usr/local/bin is in your $PATH. sudo npm install -g hexo-cli [fsevents] Success: &quot;/usr/local/lib/node_modules/hexo-cli/node_modules/fsevents/lib/binding/Release/node-v57-darwin-x64/fse.node&quot; already installed Pass --update-binary to reinstall or --build-from-source to recompile + hexo-cli@1.1.0 2.初始化框架 $ hexo init &lt;yourFolder&gt; $ cd &lt;yourFolder&gt; $ npm install 初始化完成后的目录结构 ├── _config.yml //网站的 配置 信息，您可以在此配置大部分的参数。 ├── package.json ├── scaffolds //模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 ├── source //资源文件夹是存放用户资源的地方。 | ├── _drafts | └── _posts └── themes //主题 文件夹。Hexo 会根据主题来生成静态页面。 3.新建文章（默认在/source/_post里添加hello-world.md文件） $ hexo new &quot;Hello World&quot; 4.生成网站静态代码(将/source的.md文件生成到/public中，形成网站的静态文件) $ hexo generate 5.启动服务器 $ hexo server -p 3000 $hexo s --debug 可用于预览 6.部署网站 $ hexo deploy 7.配置你所要部署的站点 部署网站之前需要生成静态文件，即可以用$ hexo generate -d直接生成并部署。此时需要在根目录下的_config.yml中配置你所要部署的站点： ## Docs: http://hexo.io/docs/deployment.html deploy: type: git repo: git@github.com:Repos.git branch: master 注意:配置repo等的时候，要留两个空格，不然可能不起作用 hexo其它命令 创建目录 hexo new page &quot;about&quot; 创建文章 $ hexo new &quot;Hello World&quot; 使用Next主题1.获取next主题 $ cd your-hexo-site $ git clone https://github.com/iissnan/hexo-theme-next themes/next 2.启用next主题(修改根目录下的_config.yml中的theme属性) # Extensions ## Plugins: http://hexo.io/plugins/ ## Themes: http://hexo.io/themes/ theme: next 3.验证是否启用 $ hexo s --debug 4.关于Next主题更多参考Next官网 http://theme-next.iissnan.com/ 文章分类categories和tags设置1.创建分类文件夹下面两行命令会在source目录下创建名为categories和tags的文件夹 $ hexo new page &quot;categories&quot; $ hexo new page &quot;tags&quot; 2.配置文件开启 在themes\next\_config.yml搜索menu,将categories和tags前对应的#号注释去掉即可 3.md文件头标明分类 使用$ hexo new &quot;文件名&quot;创建文章后，打开对应的文件，在题头添加分类和标签，例如： --- title: 文章名 date: 2016-11-19 22:20:53 categories: &quot;分组名&quot; tags: 标签名 --- 文章侧栏开关themes\next\_config.yml下搜索sidebar，display改选为hide即可。 重装操作系统后，需要安装node js和Hexo重新安装操作系统后，操作以下两步即可再次使用原有hexo文件： 安装nodejs 下载node js for windows并安装 dos下输入node -v查看nodejs版本 安装hexo $ npm install -g hexo-cli 更改tags标签默认字体颜色找到hexo\themes\next\source\css\_custom\custom.styl 添加如下内容： // Custom styles. .tag-cloud-tags a { color: black !important; //font-weight: bold font-size: medium } 搜索功能暂时选择启用local search: 安装 $ npm install hexo-generator-searchdb --save 配置 根目录配置文件中添加 search: path: search.xml field: post format: html limit: 10000 开启 主题配置文件中搜索local search,将false改为true # Local search local_search: enable: true 修改导航栏高度 找到对用css配置文件并修改为3px(原来为25px 0 20px) themes\next\source\css\_schemes\Mist\)header.styl .header-inner padding:3px 0 3px 修改页面宽度 hexo下next主题修改页面宽度 Pisces Scheme 直接在thems/next/source/css/_variables/custom.styl文件中添加： $main-desktop = 1350px $content-desktop = 1100px 改进（20180106）： $main-desktop = 95% $content-desktop = calc(100% - 252px) https://github.com/iissnan/hexo-theme-next/issues/759#issuecomment-202242848 http://theme-next.iissnan.com/faqs.html 引入评论功能 更新next主题到v6 注册leancloud.cn https://leancloud.cn/dashboard/login.html#/signin 进入控制台后点击左下角创建应用复制appid和appkey到next主题配置文件_config.yml下对应位置 配置文件中开启 valine: enable: true appid: irtttvMVkwwwwwxYtsavbj0-gzGeeeesz # your leancloud application appid appkey: swsshwwwwgjANceeeeeKl # your leancloud application appkey notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: 嗨，欢迎你在这里留言~ # comment box placeholder avatar: wavatar # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size visitor: false 参考链接 https://valine.js.org/quickstart.htmlhttps://www.jianshu.com/p/6bc6a8977c36 去除powered by valine 文件位置 /hexo/themes/next-v6/layout/_third-party/comments/valine.swig 在new Valine方法下添加代码： new Valine({ ...... }); //去除powered by valine var infoEle = document.querySelector(&apos;#comments .info&apos;); if (infoEle &amp;&amp; infoEle.childNodes &amp;&amp; infoEle.childNodes.length &gt; 0){ infoEle.childNodes.forEach(function(item) { item.parentNode.removeChild(item); }); } 当有新评论时邮件通知博主 部署Valine-Admin添加邮件通知功能 https://github.com/zhaojun1998/Valine-Admin 配置如下： 新建文章时，在相同目录下创建同名文件夹（便于图片管理） 新建文章时，在相同目录下创建同名文件夹（便于图片管理） 打开站点配置文件_config.yml，搜索post_asset_folder字段，设置其值为true 安装hexo-asset-image：npm install hexo-asset-image --save 此时hexo new &quot;fileName&quot;会在/source/_posts目录下创建同名的文件夹 只需在 md 文件里使用 ![title](图片名.jpg) ，无需路径名就可以插入图片。 参考文章： https://blog.csdn.net/weixin_39345384/article/details/80785373]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC]]></title>
    <url>%2F2016%2F03%2F01%2FJDBC%2F</url>
    <content type="text"><![CDATA[JDBC概述 jdbc概述 JDBC从物理结构上说就是Java语言访问数据库的一套接口集合。从本质上来说就是调用者(程序员)和实现者(数据库厂商)之间的协议。 JDBC API 使得开发人员可以使用纯Java的方式来连接数据库，并进行操作。 ODBC：基于C语言的数据库访问接口。 JDBC：是Java版的ODBC。 JDBC 特性：高度的一致性、简单性(常用的接口只有4、5个)。 JDBC 编程的步骤 基本步骤： 1.加载和注册数据库驱动 2.连接数据库 3.创建Statement对象 //为了类型安全和批量更新的效率，改用PreparedStatement 4.操作数据库，执行SQL语句 5.处理数据(游标) 6.释放资源，断开与数据库的连接 代码示例 public class ConnTest2 { private static final String URL = &quot;jdbc:mysql://localhost:3306/jdbc_test&quot;; private static final String USER = &quot;root&quot;; private static final String PASSWORD = &quot;123&quot;; public static void main(String[] args) throws ClassNotFoundException, SQLException { //加载驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //获取数据库连接 Connection conn = DriverManager.getConnection(URL,USER,PASSWORD); Statement stmt = conn.createStatement(); //通过数据库的连接操作数据库，实现对数据库的增删改查 ResultSet rs = stmt.executeQuery(&quot;SELECT user_name,age FROM person&quot;); while(rs.next()){ System.out.println(rs.getString(&quot;user_name&quot;)+&quot;,&quot;+rs.getInt(&quot;age&quot;)); } } } 但是通常情况下，为了代码复用，都会将连接语句封装成一个工具类DBUtils package com.jdbc.utils; import java.sql.Connection; import java.sql.DriverManager; import java.sql.SQLException; /** * 数据库连接工具类 供其他类使用 */ public class DBUtils { private static final String URL = &quot;jdbc:mysql://localhost:3306/jdbc_test&quot;; private static final String USER = &quot;root&quot;; private static final String PASSWORD = &quot;123&quot;; private static Connection conn = null; public static Connection getConnection() throws ClassNotFoundException, SQLException { //加载数据库驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //获取数据库连接信息 conn = DriverManager.getConnection(URL, USER, PASSWORD); //Statement stmt = conn.createStatement(); //返回数据库连接信息对外提供使用 return conn; } } Dao层方法调用DBUtils //删除 public void del(Person person) throws SQLException, ClassNotFoundException { Connection conn = DBUtils.getConnection(); String sql; sql = &quot;DELETE FROM person WHERE id=?&quot;; PreparedStatement ptmt = conn.prepareStatement(sql); ptmt.setInt(1, person.getId()); ptmt.execute(); } JDBC几个重要接口 参考博客： http://blog.csdn.net/gotohbu/article/details/4501811 JDBC中包括了两个包：java.sql和javax.sql java.sql 基本功能。 javax.sql 扩展功能。 java.sql 这个包中的类和接口主要针对基本的数据库编程服务，如生成连接、执行语句以及准备语句和运行批处理查询等。同时也有一些高级的处理，比如批处理更新、事务隔离和可滚动结果集等 javax.sql 它主要为数据库方面的高级操作提供了接口和类。 如为连接管理、分布式事务和旧有的连接提供了更好的抽象，它引入了容器管理的连接池、分布式事务和行集等。 Statement与PreparedStatement Statement SQL语句执行接口，代表了一个数据库的状态，在向数据库发送相应的SQL语句时，都需要创建Statement接口或PreparedStatement接口。 在具体应用中，Statement主要用于操作不带参数(可以直接运行)的SQL语句，比如删除语句、添加或更新 PreparedStatement Statement、PreparedStatement、CallableStatement 三种方式分析比较 1.JDBC提供了Statement、PreparedStatement 和 CallableStatement三种方式来执行查询语句， 其中 Statement 用于通用查询， PreparedStatement 用于执行参数化查询， 而 CallableStatement则是用于存储过程 2.对于PreparedStatement来说，数据库可以使用已经编译过及定义好的执行计划， 由于PreparedStatement对象已预编译过，所以其执行速度要快于Statement对象。 3.PreparedStatement： 可变参数的SQL,编译一次,执行多次,效率高; 支持批量更新,批量删除; 可以阻止常见的SQL注入式攻击。 PreparedStatement中，“?” 叫做占位符，一个占位符必定只能对应一个值 JDBC中Transaction编程(事务编程) 事务的特点 1. 原子性(Atomicity)：事务是一个完整的操作 2. 一致性(Consistency):当事务完成时，数据必须处于一致状态 3. 隔离性(Isolation):对数据进行修改的所有并发事务是彼此隔离的 4. 永久性(Durability):事务完成时，它对数据库的修改被永久保持 JDBC替代品 主要有一下替代品 commons-dbutils hibernate mybatis]]></content>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
</search>
