<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[车是是是]]></title>
    <url>%2F2019%2F09%2F05%2F%E8%BD%A6%E6%98%AF%E6%98%AF%E6%98%AF%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[java内存分析]]></title>
    <url>%2F2019%2F08%2F22%2Fjava%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[UXdeMacBookPro:cgov-doc-common ux$ jps 9395 DocCommonWebConfiguration 9411 Jps 9396 Launcher 683 717 RemoteMavenServer UXdeMacBookPro:cgov-doc-common ux$ jmap -dump:format=b,file=heap.bin 9395 Dumping heap to /Users/ux/code/compy/rj/ideaSpringCloud/cgov/cgov-doc-common/heap.bin ... Heap dump file created UXdeMacBookPro:cgov-doc-common ux$ jhat -J-Xmx512m heap.bin Reading from heap.bin... Dump file created Thu Aug 22 16:19:29 CST 2019 Snapshot read, resolving... Resolving 2316249 objects...]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于]]></title>
    <url>%2F2019%2F01%2F25%2Fabout%2F</url>
    <content type="text"><![CDATA[这是关于的页面，可以在这里向世界介绍你！]]></content>
  </entry>
  <entry>
    <title><![CDATA[http常见status]]></title>
    <url>%2F2018%2F08%2F30%2Fhttp%E5%B8%B8%E8%A7%81status%2F</url>
    <content type="text"><![CDATA[HTTP Status http常见status 200,OK: 用户请求成功，如查询数据成功返回。 400,错误的请求： URL匹配上Controller，但方法参数匹配错误，旧货跑出错误 404,NOT Found: 用户发出的请求针对的资源不存在。 405,用户来访问本页面的HTTP Method不被允许： 比如以GET请求方式请求了以@PostMapping限定请求方式的的Controller方法。 406,表示无法使用请求的内容特性来响应请求的资源： 比如，请求后缀以html结尾，但同时请求的HTTP头中又包含了Accept:application/json。 500,服务器内部错误，无法完成请求： 通常是Controller抛出的异常。]]></content>
      <tags>
        <tag>http常见status</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jrebel]]></title>
    <url>%2F2018%2F07%2F01%2Fjrebel%2F</url>
    <content type="text"><![CDATA[用途 用途 IDEA安装jrebel插件，即可实现热部署，更改静态文件以及java文件，都不需要再耗费大量的时间重启了。 安装 安装JRebel插件 1.IDEA&gt;pluggings&gt;搜索jrebel插件直接安装，安装完重启IDEA即可 2.下载反向代理，激活jrebel: https://github.com/ilanyu/ReverseProxy/releases/latest 3.运行反向代理软件，打开IDEA中JRebel的激活界面，在License Server处填写云翔反向代 理的机器ip，格式为：http://10.200.55.11:8888/GUID。 其中端口为8888，GUID为随机码，网上生成的： https://www.guidgenerator.com/online-guid-generator.aspx 4.激活完成后改为offline模式 地址示例：http://10.200.55.11:8888/7c06a95e-64fb-462f-9b69-edf4ad5a7ca2 其他问题 其他问题 1.tomcat的On update action 改为update classes and resources 2.如果出现内存溢出，VM options添加参数： -server -XX:PermSize=256M -XX:MaxPermSize=512m -Dfile.encoding=UTF-8 -Djava.awt.headless=true -Djava.awt.headless=true是系统缺少了显示设备、键盘或鼠标的设置参数，不是内存参数配置。在此配置只是不让代码在运行时在dock栏显示一个小窗口而已。 参考链接 参考链接 https://www.cnblogs.com/wang1024/p/7211194.html]]></content>
      <tags>
        <tag>jrebel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lombok参考手册]]></title>
    <url>%2F2018%2F05%2F23%2FLombok%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[Lombok参考手册Lombok是一个可以通过简单的注解形式来帮助我们简化消除一些必须有但显得臃肿的Java代码的工具，通过使用对应的注解，可以在编译源码的时候生成对应的方法。官方地址：https://projectlombok.org/，github项目地址：https://github.com/rzwitserloot/lombok。 lombok常用注解使用lombok注解需要在项目中引用lombok jar包。 @Data：注解在类上；提供类所有属性的getting和setting方法，此外还提供了equals、canEqual、hashCode 、toString 方法 @Setter：注解在属性上；为属性提供setting方法 @Getter：注解在属性上；为属性提供getting方法 @Slf4j：注解在类上；为类提供一个属性名为log 的slf4j日志对象 @NoArgsConstructor：注解在类上：为类提供一个无参的构造方法 @AllArgsConstructor ：注解在类上；为类提供一个全参的构造方法 @NonNull：注解在参数上；如果该参数为null 会throw new NullPointerException(参数名); @Cleanup：注释在引用变量前，自动回收资源 默认调用close方法 @SneakyThrows ：注解在方法上，为方法抛出指定异常 样例如下： 使用lombok注解的java代码： 1234567891011121314151617181920212223242526272829303132333435import lombok.*;import lombok.extern.slf4j.Slf4j;import java.io.ByteArrayInputStream;import java.io.*;import java.util.ArrayList;@Data@Slf4j@NoArgsConstructor@AllArgsConstructorpublic class Something &#123; private String name; private final String country; private final Object lockObj = new Object(); public void sayHello(@NonNull String target) &#123; String content = String.format("hello,%s", target); System.out.println(content); log.info(content); &#125; public void addBalabala() &#123; val list = new ArrayList&lt;String&gt;(); list.add("haha"); System.out.println(list.size()); &#125; @SneakyThrows(IOException.class) public void closeBalabala() &#123; @Cleanup InputStream is = new ByteArrayInputStream("hello world".getBytes()); System.out.println(is.available()); &#125;&#125; 等效于下面的这段java代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import java.beans.ConstructorProperties;import java.io.ByteArrayInputStream;import java.io.IOException;import java.util.ArrayList;import java.util.Collections;import lombok.NonNull;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class Something &#123; private static final Logger log = LoggerFactory.getLogger(Something.class); private String name; private final String country; private final Object lockObj = new Object(); public void sayHello(@NonNull String target) &#123; if(target == null) &#123; throw new NullPointerException("target"); &#125; else &#123; String content = String.format("hello,%s", new Object[]&#123;target&#125;); System.out.println(content); log.info(content); &#125; &#125; public void addBalabala() &#123; ArrayList list = new ArrayList(); list.add("haha"); System.out.println(list.size()); &#125; public void closeBalabala() &#123; try &#123; ByteArrayInputStream bis = new ByteArrayInputStream("hello world".getBytes()); try &#123; System.out.println(bis.available()); &#125; finally &#123; if(Collections.singletonList(bis).get(0) != null) &#123; bis.close(); &#125; &#125; &#125; catch (IOException e) &#123; throw e; &#125; &#125; public String getName() &#123; return this.name; &#125; public String getCountry() &#123; return this.country; &#125; public Object getLockObj() &#123; return this.lockObj; &#125; public void setName(String name) &#123; this.name = name; &#125; public boolean equals(Object o) &#123; //... &#125; protected boolean canEqual(Object other) &#123; return other instanceof Something; &#125; public int hashCode() &#123; //... &#125; public String toString() &#123; //... &#125; @ConstructorProperties(&#123;"name", "country"&#125;) public Something(String name, String country) &#123; this.name = name; this.country = country; &#125;&#125; 与IDE集成与Eclipse集成第一步：下载lombok.jar 安装包 下载地址：http://projectlombok.org/ 第二步： 与Eclipse集成 1、 将 lombok.jar 复制到eclipse.ini所在的文件夹目录下2、 打开 eclipse.ini ，在最后面插入以下两行并保存： -Xbootclasspath/a:lombok.jar -javaagent:lombok.jar3、 重启eclipse 。 与IntelliJ IDEA集成第一步：安装lombok插件 方式一，通过Plugins安装 打开IDEA，Settings -&gt; Plugin，在搜索框中输入lombok plugin ，根据提示安装，安装后重启即可。 方式二，下载安装包安装 下载lombok插件，下载地址为：https://github.com/mplushnikov/lombok-intellij-plugin/releases ; Plugin -&gt; Install plugin from disk... ，选择下载的zip包安装，安装后重启即可; 第二步：Enable annotation processing Settings -&gt; Build,Exectution,Deployment -&gt; Compiler -&gt; Annotation Processors ，勾选Enable annotation processing ，点击apply 保存，重启后即可使用lombok 注解编码了。]]></content>
      <tags>
        <tag>lombok</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http请求]]></title>
    <url>%2F2018%2F05%2F17%2Fhttp%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[post/get请求工具类 HttpRequest工具类 package com.code.util; import java.io.*; import java.net.URL; import java.net.URLConnection; import java.util.List; import java.util.Map; public class HttpRequest { /** * 向指定URL发送GET方法的 请求 * * @param url 发送请求的URL * @param param 请求参数，请求参数应该是name1=value1&amp;name2=value2的形式。 * @return URL所代表远程资源的响应 */ public static String sendGet(String url, String param) { String result = &quot;&quot;; BufferedReader in = null; try { String urlName = url + &quot;?&quot; + param; URL realUrl = new URL(urlName); // 打开和URL之间的连接 URLConnection conn = realUrl.openConnection(); // 设置通用的请求属性 conn.setRequestProperty(&quot;accept&quot;, &quot;*/*&quot;); conn.setRequestProperty(&quot;connection&quot;, &quot;Keep-Alive&quot;); conn.setRequestProperty(&quot;user-agent&quot;, &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&quot;); // 建立实际的连接 conn.connect(); // 获取所有响应头字段 Map&lt;String, List&lt;String&gt;&gt; map = conn.getHeaderFields(); // 遍历所有的响应头字段 for (String key : map.keySet()) { System.out.println(key + &quot;---&gt;&quot; + map.get(key)); } // 定义BufferedReader输入流来读取URL的响应 in = new BufferedReader( new InputStreamReader(conn.getInputStream(),&quot;UTF-8&quot;)); String line; while ((line = in.readLine()) != null) { result += line; } } catch (Exception e) { System.out.println(&quot;发送GET请求出现异常！&quot; + e); e.printStackTrace(); } // 使用finally块来关闭输入流 finally { try { if (in != null) { in.close(); } } catch (IOException ex) { ex.printStackTrace(); } } return result; } /** * 向指定URL发送POST方法的请求 * * @param url 发送请求的URL * @param param 请求参数，请求参数应该是name1=value1&amp;name2=value2的形式。 * @return URL所代表远程资源的响应 */ public static String sendPost(String url, String param) { PrintWriter out = null; BufferedReader in = null; String result = &quot;&quot;; try { URL realUrl = new URL(url); // 打开和URL之间的连接 URLConnection conn = realUrl.openConnection(); // 设置通用的请求属性 conn.setRequestProperty(&quot;accept&quot;, &quot;*/*&quot;); conn.setRequestProperty(&quot;connection&quot;, &quot;Keep-Alive&quot;); conn.setRequestProperty(&quot;user-agent&quot;, &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&quot;); // 发送POST请求必须设置如下两行 conn.setDoOutput(true); conn.setDoInput(true); // 获取URLConnection对象对应的输出流 out = new PrintWriter(conn.getOutputStream()); // 发送请求参数 out.print(param); // flush输出流的缓冲 out.flush(); // 定义BufferedReader输入流来读取URL的响应 in = new BufferedReader( new InputStreamReader(conn.getInputStream(),&quot;UTF-8&quot;)); String line; while ((line = in.readLine()) != null) { result += line; } } catch (Exception e) { System.out.println(&quot;发送POST请求出现异常！&quot; + e); e.printStackTrace(); } // 使用finally块来关闭输出流、输入流 finally { try { if (out != null) { out.close(); } if (in != null) { in.close(); } } catch (IOException ex) { ex.printStackTrace(); } } return result; } } 调用 调用方式（详情参考lib下http文件夹中的附件） //String loginParam = &quot;accessKey=test&amp;accessSecret=test&amp;clientId=clientId&amp;clientType=PC&quot;; String loginParam = &quot;accessKey=&quot; + accessKey + &quot;&amp;accessSecret=&quot; + accessSecret + &quot;&amp;clientId=&quot; + clientId + &quot;&amp;clientType=&quot; + clientType; //登陆接口： String loginUrl = &quot;https://open.wellsign.cn/dandanqian/api/index.php/Conv/User/login&quot;; //loginParam = &quot;accessKey=test&amp;accessSecret=test&amp;clientId=clientId&amp;clientType=PC&quot;; String loginSuccess = HttpRequest.sendPost(loginUrl, loginParam);]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[freemarker]]></title>
    <url>%2F2018%2F05%2F17%2Ffreemarker%2F</url>
    <content type="text"><![CDATA[待续]]></content>
      <tags>
        <tag>freemarker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM思维导图]]></title>
    <url>%2F2018%2F04%2F12%2FJVM%2F</url>
    <content type="text"><![CDATA[图解 启动流程图]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery]]></title>
    <url>%2F2018%2F03%2F02%2FJQuery%2F</url>
    <content type="text"><![CDATA[JQuery基础jquery优点 强大的选择器 解决浏览器的兼容 完善的时间机制 出色的ajax封装 丰富的UI 特性与工具方法 链式操作 回调函数 迭代器 延迟对象 队列 JQuery基础归类 样式 DOM 事件 动画 JQuery高级AJAX data包含中文时乱码 提交方式由GET改为POST]]></content>
      <tags>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java项目集成Discuz的单点登录]]></title>
    <url>%2F2017%2F12%2F29%2Fjava%E9%A1%B9%E7%9B%AE%E9%9B%86%E6%88%90Discuz%E7%9A%84%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[条件准备 部署Discuz 参见文章：windows下discuz论坛 Linux下原理相同 Java项目 普通Javaweb项目即可 Discuz用户中心访问程序包 云盘地址 链接:https://pan.baidu.com/s/1dFtW97z 密码:mkay 下载解压，将里面的 com.fivestars.interfaces.bbs包 和 config.properties 和 Jsp_demo.jsp 和 web.xml 拷贝出来 备用。 Java项目与Discuz整合单点登录将配置和工具类放到Java项目 清单 1.discuz工具包 2.web.xml添加discuz工具包路径 3.discuz配置文件 4.修改Java项目登录代码 5.discuz jsp 将工具包放到Java项目中： com.fivestars.interfaces.bbs包（src根目录） 和 config.properties（src根目录） 分别放到对应目录（参考下载的Demo目录结构） 将web.xml中的复制到Java项目的web.xml中，内容如下： &lt;servlet&gt; &lt;servlet-name&gt;api&lt;/servlet-name&gt; &lt;servlet-class&gt;com.fivestars.interfaces.bbs.api.UC&lt;/servlet-class&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;api&lt;/servlet-name&gt; &lt;url-pattern&gt;/api/uc.php&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; Discuz的UCenter中配置参数，使其与Java项目通信 访问Discuz的用户管理中心（我的discuz在apache下部署的名称为bbs,部署机器ip为192.148.1.147），如： http://192.168.1.147/bbs/uc_server 以创始人或管理员身份登录 点击应用管理，添加新应用 1.应用类型 选择：其他 2.应用名称 随便写，最好和Java项目名保持一致 3.应用的主URL Java项目的访问地址，如： http://localhost:8080/discuzTest 4.通信密钥 随便写，如123456，后面在Java项目中要用到 5.是否开启同步登陆 勾选：是 6.是够接受通知 勾选：是 最后提交,提交后在应用管理用看到，此时应用通信还处于失败状态，接下来配置Java项目 修改Java项目中的config.properties 修改前面复制到Java src跟目录下的config.properties内容，内容如下（根据实际情况配置）： #UCenter访问地址 UC_API = http://192.168.1.147/bbs/uc_server #uc ip address，UCenter ip地址 UC_IP = 192.168.1.147 #key，通信密钥 UC_KEY = 123456 #appid,应用ID（在应用管理&gt;应用列表中可以看到） UC_APPID = 4 #connect mode: default value is &quot;&quot;，可以不填 UC_CONNECT = 启动Java项目，进入UCenter&gt;应用管理，可以看到此时的通信情况会变为：通信成功。 单点登录开发 Java项目中访问Discuz, 假定点击一个按钮跳转到一个loginDiscuz.jsp页面，提供Discuz论坛地址，点击地址后跳转到论坛首页： 将上面Jsp_demo.jsp中的代码拷贝到loginDiscuz.jsp中，稍加修改： http://ogy57hyu6.bkt.clouddn.com/2-logindiscuz.jsp.txt 注：其中下面的代码比较重要 out.println($ucsynlogin + &quot;&lt;a href=&apos;http://localhost/bbs&apos; target=&apos;_blank&apos;&gt;&lt;span style=&apos;font-size:18px&apos;&gt;点此访问论坛！&lt;/span&gt;&lt;/a&gt;&quot;); 将返回的$ucsynlogin输出到页面，才能是单点登录成功。 如何用postman访问整合好的Java项目，如： http://192.168.1.147:8080/discuzTest/Jsp_demo.jsp 会看到返回一段js: &lt;script type=&quot;text/javascript&quot; src=&quot;http://localhost/bbs/api/uc.php?time=1514532782&amp;code=2f15Z57hlywzRB9IwfMmFH%2BVicj4NZLJyxbcdwiTFsOfI1mv2SPKISVXNEkTEmtP9AdwcNfJJPB9z9F36U4T%2FGvSm%2BHvR4%2BefOyk6x4k1zS0KmP%2BZKXM9i6Pj%2BizV06jNyT7kLnYVyPChoOwEMeoqomqIKYbnBaI5pN3&quot; reload=&quot;1&quot;&gt;&lt;/script&gt; 将js中的src中的内容复制粘贴到浏览器地址栏访问，如果不报错， 再访问Discuz地址，可以看到不用输入登录信息，用户已经处于登录状态。 关于上面返回值中的URL中的localhost 上面返回的链接中是src=”http://localhost/bbs。。。 如果想要返回discuz所在服务器ip，如src=”http://local192.168.1.147/host/bbs。。。。 需要在UCenter的应用管理中将Discuz的 应用的主URL 由http://localhost/bbs替换为所对应的ip，如： http://192.168.1.147/bbs 如图： bug修改 UCenter可能无法登陆bug修正 在discuz\uc_server\model\admin.php 找到adminbase函数，将 $this-&gt;cookie_status = 0; 修改为： $this-&gt;cookie_status = isset($_COOKIE[&apos;sid&apos;]) ? 1 : 0; 单点登录后关闭浏览器用户没有注销bug修正（十分不安全） 在discuz\source\function\function_core.php 找到dsetcookie函数，将 $path = $httponly &amp;&amp; PHP_VERSION &lt; &apos;5.2.0&apos; ? $config[&apos;cookiepath&apos;].&apos;; HttpOnly&apos; : $config[&apos;cookiepath&apos;]; 修改为： //将cookie的生命周期改为浏览器会话结束时结束 $cookie_life = -1; $life = $life &gt; 0 ? $cookie_life : ($life &lt; 0 ? getglobal(&apos;timestamp&apos;) - 31536000 : 0); 参考文章 bug修改 http://blog.sina.com.cn/s/blog_a77576280102vgga.html 单点登录 http://blog.51cto.com/linhongyu/1614618 discuz全部文件 云盘地址 链接:https://pan.baidu.com/s/1pLSilC3 密码:tned 包含文件列表 1-discuzTest.rar 2-修改后的logindiscuz.jsp 3-修改后的config.properties 4-修改后的Discuz部署的文件 5-官网下载的Discuz原包 6-Windows下的xamp（PHP集成环境）]]></content>
      <tags>
        <tag>discuz单点登录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下Nginx的负载均衡与HTTPS]]></title>
    <url>%2F2017%2F12%2F19%2Flinux%E4%B8%8BNginx%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%B8%8EHTTPS%2F</url>
    <content type="text"><![CDATA[负载均衡在http代码块中添加 upstream upstream_weblogic { server 192.168.1.191:7001; server 192.168.1.192:7001; } location / { root html; index index.html index.htm; proxy_pass http://upstream_weblogic; proxy_set_header Host $host; proxy_set_header Connection close; proxy_connect_timeout 100ms; # 代理机器连接超时时长(默认的60s太长了) expires 30d; } http跳转HTTPS##server配置begin server { listen 80; listen 443 ssl; server_name www.aaa.com; if ($scheme != https) { #rewrite ^(.*)$ https://$host$1 permanent; return 301 https://$host$request_uri; } ##server配置end # HTTPS 专用配置 begin # http://nginx.org/en/docs/http/configuring_https_servers.html ssl_certificate /usr/local/nginx/nginx.crt; ssl_certificate_key /usr/local/nginx/nginx.key; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # SSL(包括 v3)都有漏洞，应该用 TLS(TLS1.0 = SSL 3.1) ssl_ciphers HIGH:!aNULL:!MD5; # HTTPS 专用配置 end } 添加头信息让浏览器加载http资源（该方法只适用于静态资源）server中添加： add_header &apos;Content-Security-Policy&apos; &apos;upgrade-insecure-requests&apos;; 这一句可以让浏览器加载http的资源。但是有的浏览器不支持，比如IE 或者在页面的head中加入： &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;upgrade-insecure-requests&quot;&gt; 意思是自动将http的不安全请求升级为https 完整配置#user nobody; worker_processes 1; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #pid logs/nginx.pid; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; #log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; # &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; # &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; upstream upstream_weblogic { server 192.168.1.190:7001; server 192.168.1.190:7001; } ignore_invalid_headers on; underscores_in_headers on; merge_slashes on; #include /etc/nginx/conf.d/*.conf; ## 各个 server{} 块 server { listen 80; listen 443 ssl; server_name www.aaa.com; if ($scheme != https) { #rewrite ^(.*)$ https://$host$1 permanent; return 301 https://$host$request_uri; } #charset koi8-r; # 让浏览器自动升级请求为https add_header &apos;Content-Security-Policy&apos; &apos;upgrade-insecure-requests&apos;; #access_log logs/host.access.log main; location / { root html; index index.html index.htm; proxy_pass http://upstream_weblogic; proxy_set_header Host $host; proxy_set_header Connection close; proxy_connect_timeout 100ms; # 代理机器连接超时时长(默认的60s太长了) expires 30d; } # HTTPS 专用配置 # http://nginx.org/en/docs/http/configuring_https_servers.html ssl_certificate /usr/local/nginx/nginx.crt; ssl_certificate_key /usr/local/nginx/nginx.key; # SSL(包括 v3)都有漏洞，应该用 TLS(TLS1.0 = SSL 3.1) ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers HIGH:!aNULL:!MD5; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \.php$ { # proxy_pass http://127.0.0.1; #} # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} # deny access to .htaccess files, if Apache&apos;s document root # concurs with nginx&apos;s one # #location ~ /\.ht { # deny all; #} } # another virtual host using mix of IP-, name-, and port-based configuration # #server { # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / { # root html; # index index.html index.htm; # } #} # HTTPS server # # server { # listen 443 ssl; # server_name 10.201.50.2; # # ssl_certificate /usr/local/nginx/nginx.crt; # ssl_certificate_key /usr/local/nginx/nginx.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / { # root html; # index index.html index.htm; # } # } } 使用OpenSSL生成证书sudo openssl req -x509 -nodes -days 36500 -newkey rsa:2048 -keyout /usr/local/nginx/nginx.key -out /usr/local/nginx/nginx.crt 这样自制证书，会被提示不安全。 Nginx文件链接:https://pan.baidu.com/s/1qXJHXA8 密码:gd0w 参考文章 http://www.xitongzhijia.net/xtjc/20150910/57367.html?1441869885 https://www.cnblogs.com/hustskyking/p/upgrade-insecure-requests.htmlhttps://googlechrome.github.io/samples/csp-upgrade-insecure-requests/index.html http://nginx.org/en/docs/http/ngx_http_headers_module.html 阿里： https://ninghao.net/blog/4449]]></content>
      <tags>
        <tag>nginx-https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下安装Nginx]]></title>
    <url>%2F2017%2F12%2F19%2Flinux%E4%B8%8B%E5%AE%89%E8%A3%85Nginx%2F</url>
    <content type="text"><![CDATA[centos7 64位下安装nginx 软件准备 安装Nginx需要先安装下列软件包： GCC PCRE zlib openssl GCC和PCRE之前在centos7中使用源码安装apache2.4的时候已经安装过，这里用再安装； 这里需要下载安装zlib后再安装nginx zlib官网下载地址： http://www.zlib.net/ openssl官网下载地址 https://www.openssl.org/source/ nginx官网下载地址： http://nginx.org/en/download.html 安装 将zlib、OpenSSL、nginx源码包上传到centos7 打开terminal执行： scp /Users/ux/Downloads/zlib-1.2.11.tar.gz ux@10.211.55.5:/home/ux/mysoft/ scp /Users/ux/Downloads/nginx-1.12.2.tar.gz ux@10.211.55.5:/home/ux/mysoft/ 该命令将macOS系统中位于下载文件夹下的zlib-1.2.11.tar.gz和nginx-1.12.2.tar.gz 源码包上传到centos7的/home/ux/mysoft文件夹下。 解压，编译，安装 解压zlib： gzip -d zlib-1.2.11.tar.gz tar -xf zlib-1.2.11.tar 编译安装zlib： cd zlib-1.2.11 ./configure sudo make sudo make install 解压OpenSSL gzip -d openssl-1.0.2n.tar.gz tar -xf openssl-1.0.2n.tar 安装OpenSSL ./config --prefix=/usr/local/ssl --openssldir=/usr/local/ssl sudo make sudo make install 如果zlib正常安装，则继续安装nginx: 解压nginx gzip -d nginx-1.12.2.tar.gz tar -xf nginx-1.12.2.tar 编译安装nginx： cd nginx-1.12.2 ./configure --prefix=/usr/local/nginx --with-openssl=/home/ux/mysoft/openssl-1.0.2n --with-http_ssl_module 注意：这一步要指定OpenSSL源码包的位置（是OpenSSL源码包位置，不是OpenSSL的安装位置！！），否则后续无法使用ssl模块。 sudo make sudo make install 启动测试 在安装nginx时执行./configure可以看到。nginx默认安装到 /usr/local/nginx/下 启动nginx： cd /usr/local/nginx/sbin ./nginx 快速停止nginx: ./nginx -s stop 正常停止nginx: ./nginx -s quit 置文件修改重装载命令： ./nginx -s reload 关闭防火墙或者把80端口放行： systemctl stop firewalld.service #停止firewall systemctl disable firewalld.service #禁止firewall开机启动 firewall-cmd --zone=public --add-port=80/tcp --permanent #开启80端口，这样外部就能访问nginx的80端口了 --zone #作用域 --add-port=80/tcp #添加端口，格式为：端口/通讯协议 --permanent #永久生效，没有此参数重启后失效 软件包百度云连接 链接 链接:https://pan.baidu.com/s/1qYyZvhM 密码:1xti 参考文章 openssl http://blog.csdn.net/u012889638/article/details/49310123]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EL表达式]]></title>
    <url>%2F2017%2F12%2F05%2FEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[EL表达式概念 EL表达式概念 JSTL一般要配合EL表达式一起使用,来实现在jsp中不出现java代码段。所以我们先来学习EL表达式 EL（Expression Language）表达式语言：用于计算和输出存储在标志位置（page、request、session、application）的java对象的值,然后对它们执行简单操作；EL是JSP2.0规范的一部分，只要容器支持Servlet2.4/JSP2.0，就可以在JSP2.0网页中直接使用EL。通常与 JSTL 标记一起作用，能用简单而又方便的符号来表示复杂的行为。 EL表达式使用 开启和关闭EL表达式 开启 在servlet2.4之后默认方法为false，即可以不写或写成 &lt;%@ page isELIgnored=&quot;false&quot; %&gt; 关闭 &lt;%@ page isELIgnored=&quot;true&quot; %&gt; 还有一种批量禁用EL的方法，可以在WEB-INF/web.xml中使用jsp-property-group标签批量禁用el，web.xml中进行如下配置 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd&quot; version=&quot;2.4&quot;&gt; &lt;jsp-config&gt; &lt;jsp-property-group&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;el-ignored&gt;true&lt;/el-ignored&gt; &lt;/jsp-property-group&gt; &lt;/jsp-config&gt; &lt;/web-app&gt; EL基本格式 EL表达式的格式：用美元符号（$）定界,内容包括在花括号（{}）中; ${} 用法：这是一个EL表达式取值的方法. 例如: 点号记法：${BeanName.beanProperty} 数组记法：${BeanName[“beanProperty”]} 此外，您可以将多个表达式与静态文本组合在一起以通过字符串并置来构造动态属性值; 例如: Hello {loginInfoBean.suser} ${loginInfoBean.spwd} EL作用域的默认顺序 使用EL的时候，默认会以一定顺序（page、request、session、application）搜索四个作用域，将最先找到的变量值显示出来 名称 作用域 page 在当前页面有效 request 在当前请求中有效 session 在当前会话中有效 application 在所有应用程序中有效 http://blog.csdn.net/zycgod/article/details/44408459 EL存取器 存取器用来检索对象的特性或集合的元素。存取器: 通过 “[]” 或 “.” 符号获取相关数据 例: //获取输出bean中的suser属性值; ${userBean.suser} 或 ${userBean[“suser”]} //获取map中key为id对应的值; ${mcType[“id”]} EL运算符 和 EL隐藏对象 参考本文末尾处的链接 参考链接： http://blog.csdn.net/u010168160/article/details/49182867]]></content>
      <tags>
        <tag>EL表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA下mapper.xml颜色]]></title>
    <url>%2F2017%2F12%2F05%2FIDEA%E4%B8%8Bmapper-xml%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[解决在Intellij IDEA下使用ssm框架时，mapper.xml文件显示黄色色块问题 解决方法 将文件头的 &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; 改为： &quot;http://Mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; 或者： &quot;http://mybatis.org/dtd/mybatis-3-Mapper.dtd&quot;&gt; 这样改不会影响项目正常运行，而且会消除mapper.xml文件色块问题。]]></content>
      <tags>
        <tag>IDEA</tag>
        <tag>mapper.xml颜色问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac连接数据库的代替方案]]></title>
    <url>%2F2017%2F11%2F29%2Fmac%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BB%A3%E6%9B%BF%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[代替工具 工具 Intellij IDEA 使用方式 IDEA工具栏&gt; View&gt;Tool windows&gt;Database 调出数据库连接界面。 点击+号，选择数据库类型，如图： 填写数据库用户名，密码，url,点击下载相应的数据库驱动。 点击test connection 测试成功则表明连接成功，保存信息即可，测试结果如果失败，则表明信息不对， 核查用户名，密码，url重新测试连接。如图： 数据库url填写参考 mysql： jdbc:mysql://localhost:3306 驱动类型：MySql DB2(该数据库在Windows服务器上): jdbc:db2://192.168.1.99:50000/tradecc 驱动类型:DB2(LUW) (具体详见本地lib包：IDEA连接数据库)]]></content>
      <tags>
        <tag>mac下连接数据库代替方案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下配置apache-weblogic负载均衡+https]]></title>
    <url>%2F2017%2F11%2F27%2Flinux%E4%B8%8B%E9%85%8D%E7%BD%AEapache-weblogic%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-https%2F</url>
    <content type="text"><![CDATA[加载所需要的模块（httpd.conf文件中） 所需模块清单 LoadModule lbmethod_bybusyness_module modules/mod_lbmethod_bybusyness.so LoadModule proxy_module modules/mod_proxy.so LoadModule proxy_ajp_module modules/mod_proxy_ajp.so LoadModule proxy_balancer_module modules/mod_proxy_balancer.so LoadModule proxy_http_module modules/mod_proxy_http.so LoadModule rewrite_module modules/mod_rewrite.so LoadModule slotmem_shm_module modules/mod_slotmem_shm.so LoadModule socache_shmcb_module modules/mod_socache_shmcb.so #ssl模块 LoadModule ssl_module modules/mod_ssl.so #weblogic模块 LoadModule weblogic_module modules/mod_wl_24.so apache-weblogic负载均衡（httpd.conf文件中） 在LoadModule weblogic_module modules/mod_wl_24.so下方添加以下配置即可： &lt;IfModule mod_weblogic.c&gt; ###多台weblogic改成相应的ip即可，这里用两个相同的服务器地址暂代。 WeblogicCluster 10.211.55.3:7001,10.211.55.3:7001 MatchExpression * #WLLogFile &quot;/home/ux/Desktop/apache2.log&quot; #Debug On #DebugConfigInfo On KeepAliveEnabled On KeepAliveSecs 15 &lt;/IfModule&gt; 注：注释掉的视情况开启。 引入SSL配置文件（httpd.conf文件中） 引入httpd-ssl.conf 找到： # Secure (SSL/TLS) connections #Include conf/extra/httpd-ssl.conf 改为： # Secure (SSL/TLS) connections Include conf/extra/httpd-ssl.conf 自动跳转https(httpd.conf文件中) http自动跳转https 找到ServerName，将Rewrite规则写在其下面即可： ###### ServerName www.aa.com:80 RewriteEngine on RewriteCond %{SERVER_PORT} !^443$ RewriteRule ^(.*)?$ https://%{SERVER_NAME}$1 [L,R=301] 修改httpd-ssl.conf文件 修改ServerName 找到： &lt;VirtualHost _default_:443&gt; 将ServerName改为自己的域名，例如： ServerName www.aa.com:443 配置证书 打开httpd-ssl.conf看到， SSLCertificateFile “/usr/local/apache2/conf/server.crt” SSLCertificateKeyFile “/usr/local/apache2/conf/server.key” #SSLCACertificateFile “/usr/local/apache2/conf/ssl.crt/ca-bundle.crt” 前两个已经默认被加载，后一个需要我们手动加载，去掉注释即可。 所需模块文件获取方式（注：实验机器为centos7 64位） mod_ssl.so： sudo yum install -y mod_ssl 安装完成后我们可以看到mod_ssl的配置文件/etc/httpd/modules/下找到mod_ssl.so文件 mod_wl_24.so： 百度下载的.... 文件包： 链接:http://pan.baidu.com/s/1gfxo77P 密码:cy47 参考链接 http://blog.csdn.net/qq229596421/article/details/51789872 负载均衡其他配置方式 URL分发 &lt;IfModule mod_weblogic.c&gt; WebLogicCluster johndoe02：8005，johndoe：8006 调试打开 WLLogFile c：/tmp/global_proxy.log WLTempDir“c：/ myTemp” DebugConfigInfo On KeepAliveEnabled打开 KeepAliveSecs 15 &lt;/ IfModule&gt;配置 SetHandler weblogic-handler WebLogicCluster agarwalp01：7001 &lt;/位置&gt; SetHandler weblogic-handler PathTrim /web 调试关闭 WLLogFile c：/tmp/web_log.log &lt;/位置&gt; SetHandler weblogic-handler PathTrim /foo 调试错误 WLLogFile c：/tmp/foo_proxy.log &lt;/位置&gt; 所有匹配/ jurl / 的请求都将调试级别设置为ALL，并且日志消息将被记录到c:/tmp/global_proxy.log文件中。 所有匹配/ web / 的请求都将设置为“关闭”调试级别，并且不会记录日志消息。 所有匹配/ foo / *的请求都将调试级别设置为ERR，并且日志消息将被记录到c:/tmp/foo_proxy.log文件中。 Oracle建议您使用该MatchExpression语句而不是块。 https下让浏览器自动将HTTP资源升级为HTTPS 在apache的httpd.conf中添加如下配置 找到加载模块代码，并去掉注释： LoadModule headers_module modules/mod_headers.so 搜索 &lt;IfModule headers_module&gt; 将 &lt;IfModule headers_module&gt; # # Avoid passing HTTP_PROXY environment to CGI&apos;s on this or any proxied # backend servers which have lingering &quot;httpoxy&quot; defects. # &apos;Proxy&apos; request header is undefined by the IETF, not listed by IANA # RequestHeader unset Proxy early &lt;/IfModule&gt; 改为 &lt;IfModule headers_module&gt; # # Avoid passing HTTP_PROXY environment to CGI&apos;s on this or any proxied # backend servers which have lingering &quot;httpoxy&quot; defects. # &apos;Proxy&apos; request header is undefined by the IETF, not listed by IANA # RequestHeader unset Proxy early Header set Content-Security-Policy &quot;upgrade-insecure-requests&quot; &lt;/IfModule&gt; 参考链接 https://www.cnblogs.com/hustskyking/p/upgrade-insecure-requests.htmlhttp://httpd.apache.org/docs/current/mod/mod_headers.html apache完整包 链接:https://pan.baidu.com/s/1mizN7Uo 密码:c4p2]]></content>
      <tags>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下安装apache]]></title>
    <url>%2F2017%2F11%2F27%2Flinux%E4%B8%8B%E5%AE%89%E8%A3%85apache%2F</url>
    <content type="text"><![CDATA[安装包准备 下载APR源码包 http://apr.apache.org 详细地址： http://apr.apache.org/download.cgi 下载APR-Util源码包 http://apr.apache.org 详细地址： http://apr.apache.org/download.cgi 下载PCRE源码包 http://www.pcre.org 详细地址： https://ftp.pcre.org/pub/pcre/ 下载Apache Server2.4源码包 http://httpd.apache.org/ 详细地址： http://httpd.apache.org/download.cgi#apache24 安装过程 安装unzip yum install -y unzip zip 全部解压 解压命令： gzip -d pcre-8.36.tar.gz tar -xf pcre-8.36.tar 或者 tar xzvf this.tar.gz 安装gcc 无论你是要安装APR、APR-Util、PCRE还是Apache Server或者是其他的一些软件， 总之，只要是源码安装，那么就需要一个ANSI-C编译器。如果你没有，那就用yum装一个吧， 既然推荐使用GCC，那就装个GCC吧。 执行命令：yum install -y gcc 首先安装apr 依次执行命令： cd apr-1.6.3 ./configure sudo make sudo make install 然后安装apr-util 依次执行命令： cd apr-util-1.6.1 ./configure --with-apr=/usr/local/apr sudo make sudo make install 在安装APR-Util时，需要指定APR的安装路径，所以需要带上选项--with-apr=/usr/local/apr，如果你不带上这个选项，在configure的时候会看到下图的错误提示 最后安装pcre 依次执行命令： cd pcre-8.41 在执行./configure时出错，提示configure: error: You need a C++ compiler for C++ support 此时使用yum安装安装gcc-c++： yum install -y gcc gcc-c++ 然后再执行： ./configure sudo make sudo make install 开始安装apache2.4 解压apache源码包 gzip -d httpd-2.4.29.tar.gz tar -xf httpd-2.4.29.tar 依次执行命令： ./configure --enable-mods-shared=all sudo make sudo make install Apache默认安装在/usr/local/apache2目录下。同样，这里你也可以使用 –prefix=目录名 来指定一个安装目录，例如： ./configure --prefix=/usr/mydir --enable-mods-shared=all 启动apache进行测试 启动命令： /usr/local/apache2/bin/apachectl -k start 如果提示以下信息，则是配置文件httpd.conf中的ServerName没有修改： AH00558: httpd: Could not reliably determine the server&apos;s fully qualified domain name, using localhost.localdomain. Set the &apos;ServerName&apos; directive globally to suppress this message 防火墙 开关防火墙 systemctl status firewalld 如果处于running运行状态，就把它关掉： systemctl stop firewalld 然后，查看一下防火墙是否已经关掉： systemctl status firewalld 如果处于dead状态，就说明已经关掉了。 如果你希望每次系统启动的时候都不要启动防火墙，可以执行命令： systemctl disable firewalld 同样，如果你希望每次系统启动的时候都启动防火墙，可以执行命令： systemctl enable firewalld 文件夹权限 刚安装完apache发现普通用户没有apache的写入权限，方便起见，将apache下的所有文件设置为了所有用户可读写： 修改apache2下所有文件权限(777:everyone均可读写)： sudo chmod -R 777 /usr/local/apache2/ 安装过程中可能出现的错误 expat库缺失提示 安装expat库: yum install expat-devel 文件包链接 apache2.4源码包以及依赖源码包 链接:http://pan.baidu.com/s/1jIQUArk 密码:5ccg 参考链接 参考文章（已亲测） https://jingyan.baidu.com/article/7e4409533d7f0f2fc0e2ef91.html]]></content>
      <tags>
        <tag>linux安装apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac下安装mysql]]></title>
    <url>%2F2017%2F11%2F25%2Fmac%E4%B8%8B%E5%AE%89%E8%A3%85mysql%2F</url>
    <content type="text"><![CDATA[下载安装包 下载地址 安装mysql社区版，免费。下载地址： https://dev.mysql.com/downloads/ 下载MySQL Community Server (GPL)版本。 macOS下下载的安装包是dmg格式的。 安装 macOS下安装mysql macOS下的mysql dmg安装包基本就是傻瓜式安装，一路确定即可，但是要注意最后一步的mysql installer弹窗，会提示mysql的root用户的默认密码，抄下即可，方便后续登录root用户以及修改密码。 macOS下启动与关闭mysql服务，可以在 系统偏好设置&gt; 最下边看到mysql图标，点击去即可启动/关闭 mysql服务。 更改字符集 更改默认字符集和密码 mysql默认安装后，会出现中文乱码现象，需要更改字符集设置。 root用户登录mysql，查看字符集信息： show variables like &apos;character%&apos;; 结果类似下面（这是改过字符集设置后的结果） mysql&gt; show variables like &apos;character%&apos;; +--------------------------+-----------------------------------------------------------+ | Variable_name | Value | +--------------------------+-----------------------------------------------------------+ | character_set_client | utf8 | | character_set_connection | utf8 | | character_set_database | utf8 | | character_set_filesystem | binary | | character_set_results | utf8 | | character_set_server | utf8 | | character_set_system | utf8 | | character_sets_dir | /usr/local/mysql-5.7.20-macos10.12-x86_64/share/charsets/ | +--------------------------+-----------------------------------------------------------+ 8 rows in set (0.00 sec) 打开终端，进入/etc，执行ls -a 查看有没有my.cnf文件，没有则创建my.cnf: sudo vim /etc/my.cnf ，输入计算机管理员密码，创建my.cnf文件，并复制 [client] default-character-set=utf8 [mysqld] character-set-server=utf8 按下esc按键，输入:wq保存退出即可。 重启mysql服务，OK。 修改mysql密码 修改root用户密码 mysql –u root 进入mysql update user set password=PASSWORD(‘123456’) where User=&apos;root&apos;; 允许远程访问 允许远程访问mysql mysql -u root –p mysql&gt;use mysql; mysql&gt;update user set host = &apos;%&apos; where user = &apos;root&apos;; 查看结果： mysql&gt;select host, user from user; mac安装完mysql后用随即密码无法登陆，重置密码(20180828) 关闭mysql服务 苹果-&gt;系统偏好设置-&gt;最下边点mysql 在弹出页面中 关闭mysql服务（点击stop mysql server） 关闭密码验证 进入终端输入：cd /usr/local/mysql/bin/ 回车后 登录管理员权限 sudo su 回车后输入以下命令来禁止mysql验证功能 ./mysqld_safe --skip-grant-tables &amp; 回车后mysql会自动重启（偏好设置中mysql的状态会变成running） 设置密码 输入命令 ./mysql 回车后，输入命令 FLUSH PRIVILEGES; 回车后，输入命令 SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos; = PASSWORD(&apos;你的新密码&apos;); 密码修改完成，可以成功登陆。]]></content>
      <tags>
        <tag>macOS下安装mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac快捷键]]></title>
    <url>%2F2017%2F11%2F20%2Fmac%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[mac快捷键 command相关 Finder： （桌面上）command+N/command+方向键上 新建窗口： （对应的应用中）command+N 保存删除新建拷贝复制文件： 保存：command+S 删除：command+delete 粘贴：command+C 拷贝：command+V 剪切：command+X 复制： （拷贝不包含粘贴，复制是直接粘贴，相当于win下的ctrl+v,ctrl+v连续执行） 新建（文件夹）：command+shift+N 快捷搜索程序： command+空格键 关闭窗口： command+W（关闭窗口） command+Q(彻底关闭程序) 光标位置切换： command+方向键左/右：定位到当前行首/末尾 command+方向键上/下：定位到当前页首/尾 control control+F2：快速定位到左上角菜单栏 control+F3:快速定位到Dock栏 control+F8：快速定位到右上角状态栏 control+F4:快速定位到活跃窗口 control+F5:快速定位到当前窗口的工具框（如输入框等） 以上关于control的组合快捷键在系统偏好&gt;键盘&gt;快捷键&gt;键盘中定义 F1~F12标准功能 mac默认情况F1~F12是多媒体功能，在系统偏好设置&gt;键盘&gt;键盘&gt;勾选&quot;将F1、F2等键用作标准功能&quot;，勾选后，F1~F12就不会影响开发软件下的快捷组合键了。 触摸板 四指向上推：当前运行程序 五指捏/合:所有程序页面打开/关闭 拇指+其余四手指开/合：打开桌面 mac商店 mac商店中的应用有限制，比如网易云音乐，在网易官网下载的和在mac商店下载的对于快捷键的支持是不一样的，网易官网下载的比较好用。 command+option+i chrome浏览器调试界面（win下的f12功能） command+shift+a 打开应用程序文件夹 command+shift+h Chrome浏览器主页 command+L 浏览器地址栏 command+ +/- 放大/缩小 浏览器页面 自带高清壁纸 自带高清壁纸 /Library/Screen Savers/Default Collections/]]></content>
      <tags>
        <tag>mac快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java杂记]]></title>
    <url>%2F2017%2F11%2F03%2Fjava%E6%9D%82%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[字符串截取 字符串路径截取 filename=&quot;2017\11\01\050000001\7b3d73a2e080c2722e1fb6e71be2f0be_aaa2.doc&quot; //截取最后一个反斜杠后面的内容，即：7b3d73a2e080c2722e1fb6e71be2f0be_aaa2.doc String filenameStr = filename.substring(filename.lastIndexOf(&quot;\\&quot;)+1); //截取开头到最后一个反斜杠之间的内容，即：2017\11\01\050000001\ String filePathStr = filename.substring(0,filename.lastIndexOf(&quot;\\&quot;)+1); URL转码解码 //转码 String filenameStr2 = java.net.URLEncoder.encode(filenameStr, &quot;utf-8&quot;); //解码 java.net.URLDecoder.decode(str, ENCODE); 参考网址: http://www.cnblogs.com/haha12/p/4344992.html 重新拼接 //重新拼接 filename = filePathStr+filenameStr2; 反斜杠转正斜杠 //将反斜杠替换为正斜杠 filename.replace(&quot;\\&quot;, &quot;/&quot;)) 字符串年月日时分秒毫秒 //年月日时分秒毫秒 java.text.SimpleDateFormat date = new java.text.SimpleDateFormat(&quot;yyyyMMddHHmmssSS&quot;); String currentTimeMillis = date.format(new Date(System.currentTimeMillis())); 截图文件后缀重新拼接 //fileName=&quot;fjsdfidjfi.swf&quot; String suffix = fileName.substring(fileName.lastIndexOf(&quot;.&quot;)); //拼接得到结果：20171102103140271.swf String newFileName = currentTimeMillis + suffix; Date转时间戳 Date转时间戳 import java.sql.Timestamp; import java.text.SimpleDateFormat; import java.util.Calendar; import java.util.Date; public class Test { public static void main(String[] args) { Timestamp timestamp = new Timestamp((new Date()).getTime()); //System.out.println(&quot;wre:&quot;+timestamp); String s = timestamp.toString(); Timestamp ts = Timestamp.valueOf(s); Calendar c = Calendar.getInstance(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy/MM/dd/HH:mm:ss&quot;);//hh:12小时制，HH小时制度 System.out.println(sdf.format(c.getTime())); } } StringUtils截取字符串 截取 }, 之后的字符串，不包含 }, String str4 = StringUtils.substringAfter(jsonArray.toString(),&quot;},&quot;); 依赖包 import org.apache.commons.lang3.StringUtils; 依赖包maven配置 &lt;!-- commons-lang3 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;/dependency&gt; ## 待续…]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java杂记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[navicat连接虚拟机的oracle]]></title>
    <url>%2F2017%2F07%2F28%2Fnavicat%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84oracle%2F</url>
    <content type="text"><![CDATA[navicat连接虚拟机的oracle环境说明: 虚拟机：VMware8 虚拟机系统：winxp oracle版本：32位，Oracle Database 10g Enterprise Edition Release 10.2.0.1.0 navicat版本：64位，navicat premium 11.0.17 连接 确定虚拟机的ip:VM&gt;edit&gt;virtual network 我的是NAT方式共享主机网络，ip是192.168.201.0(非真实) 进xp系统，cmd下ipconfig:192.168.201.128 确定主机与虚拟机能互相访问(最主要的是主机能访问虚拟机) 主机cmd下ping虚拟机xp系统的ip:ping 192.168.201.128 如果ping出现问题，手动关闭虚拟机xp系统的防火墙。 navicat连接oracle,这一步出现问题最多 navicat建立连接，填写ip为虚拟机xp系统的ip,服务名ORCL, 用户名可以填SYSTEM，还有密码(安装oracle的时候设置的), 点击连接测试，报无法加载OCI.dll 193错误，网上大多教程都是下载32位的basic-client,试了几次依旧报错，因为我的navicat是64位的，且版本是11，所以下载了： instantclient-basic-windows.x64-12.2.0.1.0 instantclient-sqlplus-windows.x64-12.2.0.1.0 这两个64位的，解压，将instantclient_12_2中的文件合并， 打开navicat，工具&gt;选项&gt;OCI:选择刚刚instantclient_12_2中的 oci.dll和sqlplus.exe,保存，重启navicat,连接oracle,OK了。 注意：navicat报错的时候，点开连接，里面有下载client的地址以及老版本的操作方式]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[12306]]></title>
    <url>%2F2017%2F07%2F24%2F12306%2F</url>
    <content type="text"><![CDATA[12306铺位选择代码 12306铺位选择： &lt;select name=&quot;passenger_1_seat_detail_select&quot; style=&quot;display: block&quot; id=&quot;passenger_1_seat_detail_select&quot; onchange=&quot;setSeatDetail(&apos;1&apos;)&quot;&gt; &lt;option value=&quot;0&quot;&gt;随机&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;上铺&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;中铺&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;下铺&lt;/option&gt; &lt;/select&gt; 注意： 点击edit as html 后，在对应的下敲回车留一行空格。 图示： 在图中红框圈住的地方，右键&gt;&gt;&gt;&gt;审查元素,出现图二内容 右键箭头指向的地方&gt;&gt;&gt;edit as html 在出现的代码最下方，敲一下回车(留一行空格)，复制下面的代码： &lt;select name=&quot;passenger_1_seat_detail_select&quot; style=&quot;display: block&quot; id=&quot;passenger_1_seat_detail_select&quot; onchange=&quot;setSeatDetail(&apos;1&apos;)&quot;&gt; &lt;option value=&quot;0&quot;&gt;随机&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;上铺&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;中铺&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;下铺&lt;/option&gt;&lt;/select&gt; 然后就可以继续订票了。]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>12306</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL进阶]]></title>
    <url>%2F2017%2F06%2F02%2FSQL%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[简单表的拆分思路 如图 描述 有一张表 cars,有字段id,name,catename三个。 现要将其拆分成新cars表和cates俩表， 其中新cars表包含id,name和cates的主键cateid。 操作 1.创建cates表 DROP TABLE IF EXISTS `cates`; CREATE TABLE `cates` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8; 2.将cars中的cateName插入到cates中 insert into cates(name) select cateName from cars; 3.创建表cars_tmp存放cars表的id,name和cates的id DROP TABLE IF EXISTS `cars_tmp`; CREATE TABLE `cars_tmp` ( `id` int(11) DEFAULT NULL, `name` varchar(100) DEFAULT NULL, `cateid` int(11) DEFAULT NULL ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 4.将对应数据插入到cars_tmp中 insert into cars_tmp select c.id,c.name,cs.id from cars c join cates cs on c.cateName = cs.name; /inner join和join相同 5.删除老cars表，重命名cars_tmp表为cars drop table cars; alter table cars_tmp rename to cars; case转换 查询结果中字段性别 1和0 转换为 男/女 SELECT id, case sex WHEN &apos;1&apos; THEN &apos;男&apos; WHEN &apos;0&apos; THEN &apos;女&apos; END AS sex FROM person; 表结构： -- ---------------------------- DROP TABLE IF EXISTS `person`; CREATE TABLE `person` ( `id` int(11) NOT NULL, `sex` varchar(1) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 临时表创建临时表很容易，给正常的CREATE TABLE语句加上TEMPORARY关键字即可。 创建临时表 CREATE TEMPORARY TABLE tmp_table ( name VARCHAR(10) NOT NULL ) 向临时表中插数据 insert into tmp_table(name) select name from cars_old; 删除临时表 临时表将在你连接MySQL期间存在。当你断开时，MySQL将自动删除表并释放所用的空间。当然你可以在仍然连接的时候删除表并释放空间。 DROP TABLE tmp_table 查看表结构 查看表结构 desc table_name describe table_name order by order by 1/2/3的含义 SELECT * FROM table_name ORDER BY 1; SELECT id,name,sex FROM table_name ORDER BY 3; ORDER BY 1代表以 所查询字段 的第1个字段排序； ORDER BY 3代表以 所查询字段 的第3个字段排序，如果查询总字段的个数小于3个字段，则会报错。 数据库视图 什么是视图 视图，并不是真实存在的数据表（但是其对应的数据表是真实存在的），而是数据表字段的组合或者筛选，可以与存储过程对比理解，也可以把视图暂且理解为一个或多个数据表特定字段的组合。 如何创建视图 比如，现在存在数据表student DROP TABLE IF EXISTS `student`; CREATE TABLE `student` ( `id` int(11) NOT NULL, `sid` varchar(255) DEFAULT NULL, `sname` varchar(255) DEFAULT NULL, `ssex` varchar(255) DEFAULT NULL, `sage` varchar(255) DEFAULT NULL, `saddress` varchar(255) DEFAULT NULL, `sclass` varchar(255) DEFAULT NULL ) ENGINE=InnoDB DEFAULT CHARSET=utf8; -- ---------------------------- -- Records of student -- ---------------------------- INSERT INTO `student` VALUES (&apos;1&apos;, &apos;2017001&apos;, &apos;张三&apos;, &apos;男&apos;, &apos;21&apos;, &apos;上海&apos;, &apos;001&apos;); INSERT INTO `student` VALUES (&apos;2&apos;, &apos;2017002&apos;, &apos;李四&apos;, &apos;女&apos;, &apos;22&apos;, &apos;北京&apos;, &apos;002&apos;); 该表包含id,学号，姓名，性别，年龄，地址这几个字段，如果此刻只想暴露学号，姓名，性别这三个字段信息供外界查询，那么可以建立视图，用以隐藏其余不想暴露的字段。 create view v_student AS SELECT id,sid,sname,ssex FROM student; 上面的SQL创建了名为v_student的视图，该视图针对student数据表而存在，展示学号，姓名，性别三个字段。 视图的调用 视图的操作与普通数据表的操作一样 查询： select*from v_student; 插入： insert into v_student values(&apos;3&apos;,&apos;2017003&apos;,&apos;王五&apos;,&apos;男&apos;); 修改： UPDATE v_student set ssex=&apos;女&apos; WHERE sid = &apos;2017003&apos;; 删除： DELETE FROM v_student where sid=&apos;2017003&apos;; 视图的优劣 优点： 使用视图，可以定制用户数据，聚焦特定的数据。 使用视图，可以简化数据操作 数据隐藏 以合并分离的数据，创建分区视图 缺点： 性能差 修改限制 参考文章： http://blog.csdn.net/javajxz008/article/details/50720936 外连接与内链接 LEFT JOIN 左表为主表，查询结果含有左表所有满足条件的。 RIGHT JOIN 右表为主表，查询结果含有右表所有满足条件的。 INNER JOIN 只有两表同时满足条件的记录，才会被查询出来。 以info1和info2表中主键(id/sid)相同为条件，查询info1中的id和info2的sname为例： 表1： mysql&gt; select*from info1; +----+-------+ | id | name | +----+-------+ | 4 | 张三4 | | 11 | 张三1 | | 22 | 张三2 | | 33 | 张三3 | +----+-------+ 表2： mysql&gt; select*from info2; +-----+-------+ | sid | sname | +-----+-------+ | 1 | 李四1 | | 22 | 李四2 | | 33 | 李四3 | | 44 | 李四4 | +-----+-------+ 4 rows in set 左连接，以左表为主，其中id为11，4，和55的在info2表中没有对应的id,所以sname为NULL mysql&gt; select id,sname from info1 as a left join info2 as b on a.id = b.sid order by name; +----+-------+ | id | sname | +----+-------+ | 11 | NULL | | 22 | 李四2 | | 33 | 李四3 | | 4 | NULL | | 55 | NULL | +----+-------+ 5 rows in set 右连接，以右表为主，因此左表中的第五列没有被查询出来 mysql&gt; select id,sname from info1 as a right join info2 as b on a.id = b.sid order by name; +------+-------+ | id | sname | +------+-------+ | NULL | 李四1 | | NULL | 李四4 | | 22 | 李四2 | | 33 | 李四3 | +------+-------+ 4 rows in set 内连接，只查询a.id和b.sid一致的记录 mysql&gt; select id,sname from info1 as a inner join info2 as b on a.id = b.sid order by name; +----+-------+ | id | sname | +----+-------+ | 22 | 李四2 | | 33 | 李四3 | +----+-------+ 2 rows in set 给table起别名(DB2) LC.B_SH_DlvSeqInfo起别名为TC.B_SH_DLVSEQINFO CREATE ALIAS TC.B_SH_DLVSEQINFO FOR LC.B_SH_DlvSeqInfo; 索引 索引的创建与查看 UNION与UNION ALL 示例表结构 DROP TABLE IF EXISTS `cars`; CREATE TABLE `cars` ( `id` int(11) DEFAULT NULL, `name` varchar(100) DEFAULT NULL, `cateid` int(11) DEFAULT NULL, `new` int(255) DEFAULT NULL, KEY `myid` (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; -- ---------------------------- -- Records of cars -- ---------------------------- INSERT INTO `cars` VALUES (&apos;1001&apos;, &apos;car1&apos;, &apos;1&apos;, null); INSERT INTO `cars` VALUES (&apos;2&apos;, &apos;car2&apos;, &apos;2&apos;, null); INSERT INTO `cars` VALUES (&apos;3&apos;, &apos;car3&apos;, &apos;3&apos;, null); INSERT INTO `cars` VALUES (&apos;4&apos;, &apos;car4&apos;, &apos;4&apos;, null); INSERT INTO `cars` VALUES (&apos;5&apos;, &apos;car4&apos;, &apos;5&apos;, null); union查询与union all查询对比 UNION: mysql&gt; select &quot;信息名&quot; from cars -&gt; union -&gt; select name from cars; +--------+ | 信息名 | +--------+ | 信息名 | | car1 | | car2 | | car3 | | car4 | +--------+ UNION ALL: mysql&gt; select &quot;信息名&quot; from cars -&gt; union all -&gt; select name from cars; +--------+ | 信息名 | +--------+ | 信息名 | | 信息名 | | 信息名 | | 信息名 | | 信息名 | | car1 | | car2 | | car3 | | car4 | | car4 | +--------+ 对比结果： UNION会将查询的结果去重复，UNION ALL不会进行重复过滤。 但是，如果在UNION ALL中条件唯一（查询结果只有一条），一样可以做到和UNION一样的结果。 如下： mysql&gt; select sum(id),&quot;信息&quot; from cars -&gt; union -&gt; select id,name from cars; +---------+------+ | sum(id) | 信息 | +---------+------+ | 1015 | 信息 | | 1001 | car1 | | 2 | car2 | | 3 | car3 | | 4 | car4 | | 5 | car4 | +---------+------+ mysql&gt; select sum(id),&quot;信息&quot; from cars -&gt; union all -&gt; select id,name from cars; +---------+------+ | sum(id) | 信息 | +---------+------+ | 1015 | 信息 | | 1001 | car1 | | 2 | car2 | | 3 | car3 | | 4 | car4 | | 5 | car4 | +---------+------+ 因为sum（id）的结果只有一条，所以出现UNION ALL和UNION一样的结果。 IFNULL/ISNULL/NVLIFNULL/ISNULL/NVL 可以做数据表两个字段的查询，如字段1，字段2，若字段1为null，则用字段2代替 MySQL语法如下： SELECT IFNULL(new,name) from cars; +------------------+ | IFNULL(new,name) | +------------------+ | 33 | | car2 | | car3 | | car4 | | car4 | +------------------+ Oracle语法： SELECT NVL(new,name) from cars; DB2 SELECT COLUMN FROM TABLE FETCH FIRST N ROWS ONLY CASE的另一种用法 CASE的另一种用法 需求：如果我想更新id=1的status为1，id不为1的status为0 ，且id有外键 update AccountStatus a set a.statusSource=(case when a.statusSource =1 then 2 else 1 end ) --这样可以替换掉id为1的数据为0，id为0的数据为1 普通用法 将成绩划分等级： select grade,case when grade&gt;=90 then &apos;优秀&apos; when grade&gt;=80 then &apos;良好&apos; when grade&gt;=70 then &apos;中等&apos; when grade&gt;=60 then &apos;及格&apos; when grade is null then &apos;缺考&apos; else &apos;不及格&apos; end from sc Mysql的Limit limit select * from tbname LIMIT 10;--检索前10行数据，显示1-10条数据 select * from tbname LIMIT 1,10;--检索从第2行开始，累加10条id记录，共显示id为2....11 select * from tbname limit 5,10;--检索从第6行开始向前加10条数据，共显示id为6,7....15 select * from tbname limit 6,10;--检索从第7行开始向前加10条记录，显示id为7,8...16]]></content>
      <tags>
        <tag>SQL进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA]]></title>
    <url>%2F2017%2F05%2F23%2FIDEA%2F</url>
    <content type="text"><![CDATA[IDEA常用快捷键 常用快捷键： Ctrl+Alt+L:自动格式化代码 Ctrl+Enter:另起一行 Alt+Insert:Generate-getter/setter等 Alt+Enter:各种错误解决方案提示 Ctrl+Alt+Shift+S:Project Structure即 Artifacts、Modules、Facets等设置 Shift+F6：重命名你的类、方法、变量等，可以选择替换掉注释中的内容 ctrl+d：复制当前行 ctrl+y：删除当前行 sout：system.out.print快捷方式 psvm：main放大快捷方式 Ctrl+shift +/- :展开/折叠全部代码 错误提示1099：tomcat和jdk版本不匹配 使用技巧find action(command + shift +a)下搜索快捷键： 如recent file 提示快捷键为 command + e 搜索文件: command+n 最近文件： command+e 书签标记 command+f11 书签跳转 control+书签数字 收藏代码 alt+shift+f 展现收藏列表 command+2 展现project导航栏 command+1 左边栏与代码编辑框的互相跳转 command+1跳转到左边栏，esc恢复到代码编辑框 IDEA常用插件 lombok 实体类不写getter/setter; Slf4j等； 详见笔记《Lombok参考手册》 iBATIS/MyBatis mini-plugin 方便接口到实现的跳转；dao接口到xml SQL语句的跳转 IDEA maven helper pom.xml文件中方便查看maven依赖冲突，依赖列表，依赖树 https://my.oschina.net/u/136229/blog/678918 JRebel 实现IDEA下应用的热部署热编译，修改静态文件，java文件，无需重启即可自动编译部署，使之生效； 收费插件； 详见笔记《jrebel》 EasyCode https://juejin.im/entry/5b6a61a1f265da0f7e62b1b0?utm_source=gold_browser_extension IDEA常用设置 参考 https://blog.csdn.net/qq_27093465/article/details/77449117 设置显示项目内存占用 preference&gt;appearence&amp;Behavior&gt;appearence&gt;window options下勾选show mwmory indicator]]></content>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS总结]]></title>
    <url>%2F2017%2F05%2F18%2FJS%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[生成4位随机数 生成4位随机数 http://op05inpyd.bkt.clouddn.com/%E9%9A%8F%E6%9C%BA%E6%95%B0.txt &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gb2312&quot; /&gt; &lt;title&gt;随机数&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .textbox { margin-right: 5px; margin-top: 10px; width: 70px; font-family: 微软雅黑; text-align: center; font-weight: bold; font-size: 16px; color: Blue; } &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; //增加文本框 function CreateTextBox() { var count = GetTextBoxCount(); if (count &lt; 10) { var textBox = document.createElement(&quot;input&quot;); textBox.setAttribute(&quot;type&quot;, &quot;text&quot;); textBox.setAttribute(&quot;name&quot;, &quot;myname&quot;); textBox.className = &quot;textbox&quot;; document.body.appendChild(textBox); } else { alert(&quot;最多生成10个随机数&quot;); } } //减少文本框 function RemoveTextBox() { var count = GetTextBoxCount(); if (count &gt; 1) { document.body.removeChild(document.body.lastChild); } else { alert(&quot;请最少保留1个&quot;); } } //计算文本框的个数 function GetTextBoxCount() { var elements = document.getElementsByName(&quot;myname&quot;); return elements.length; } Array.prototype.Contains = function (num) { var flag = false; if (this.length &lt;= 0) { return flag; } for (var i = 0; i &lt; this.length; i++) { if (this[i] == num) { flag = true; break; } } return flag; } //生成4位随机数并放到数组中 function CreateRandomNumber(array, count) { while (array.length &lt; count) { var num = Math.floor((Math.random()) * 9000+1000); if (!array.Contains(num)) { array.push(num); } } } //将数组中的随机数赋值到界面的文本框中 function SetTextBoxValue() { var array = new Array(); var count = GetTextBoxCount(); CreateRandomNumber(array, count); var elements = document.getElementsByName(&quot;myname&quot;); for (var i = 0; i &lt; elements.length; i++) { elements[i].value = array[i]; } } &lt;/script&gt; &lt;/head&gt; &lt;body onload=&quot;CreateTextBox()&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;增加&quot; onclick=&quot;CreateTextBox()&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;减少&quot; onclick=&quot;RemoveTextBox()&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;生成随机数&quot; onclick=&quot;SetTextBoxValue()&quot; /&gt;&lt;br /&gt; &lt;/body&gt; &lt;/html&gt; 生成不重复的4位随机数 生成不重复的4位随机数 http://op05inpyd.bkt.clouddn.com/%E7%94%9F%E6%88%90%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%844%E4%BD%8D%E9%9A%8F%E6%9C%BA%E6%95%B0.txt /** * 生成4位随机数并赋值,已经有随机数的输入框，不再赋值 */ function GetTextBoxCount() { var elements = document.getElementsByName(&quot;ConfirmationCode&quot;); //TODO 只取空值的个数 var nums=0; for(var j = 0; j &lt; elements.length; j++){ if(elements[j].value == null || elements[j].value ==&quot;&quot;){ nums++; } } return elements.length; } Array.prototype.Contains = function (num) { var flag = false; if (this.length &lt;= 0) { return flag; } for (var i = 0; i &lt; this.length; i++) { if (this[i] == num) { flag = true; break; } } return flag; } function CreateRandomNumber(array,array2,count) { while (array.length &lt; count) { var num = Math.floor((Math.random()) * 9000+1000); //将随机生成的数字与页面原有随机数比较，保证不重复 if (!array.Contains(num) &amp;&amp; !array2.Contains(num)) { array.push(num); } } } function SetTextBoxValue() { var array = new Array(); var array2 = new Array(); var elements = document.getElementsByName(&quot;ConfirmationCode&quot;); //将已经存在的随机码存进array for (var i = 0; i &lt; elements.length; i++) { array2.push(elements[i]); } var count = GetTextBoxCount(); CreateRandomNumber(array,array2,count); for (var i = 0; i &lt; elements.length; i++) { //非空不赋值 if(elements[i].value == null || elements[i].value ==&quot;&quot;){ elements[i].value = array[i]; } } } /** * 检查用户手动输入确认码是否重复 */ function IsCodeExists(data){ //获取页面数据并存进数组中 var elements = document.getElementsByName(&quot;ConfirmationCode&quot;); var array4 = new Array(); for (var i = 0; i &lt; elements.length; i++) { array4.push(elements[i].value); } //对数组中的数据进行重复比较 var ary = array4; var nary=ary.sort(); for(var i=0;i&lt;ary.length;i++){ if (nary[i]==nary[i+1] &amp;&amp; nary[i] !=&quot;&quot;){ alert(&quot;确认码 &quot;+nary[i]+&quot; 重复，请重新输入！&quot;); } } } /** * 提交前再做一次重复判断，若重复，则弹窗提醒并且不提交 */ function btnsave_clicked(){ var flag=false; //获取页面数据并存进数组中 var elements = document.getElementsByName(&quot;ConfirmationCode&quot;); var array4 = new Array(); for (var i = 0; i &lt; elements.length; i++) { array4.push(elements[i].value); } //对数组中的数据进行重复比较 var ary = array4; var nary=ary.sort(); for(var i=0;i&lt;ary.length;i++){ if (nary[i]==nary[i+1] &amp;&amp; nary[i] !=&quot;&quot;){ flag=false; alert(&quot;确认码 &quot;+nary[i]+&quot; 重复，请重新输入！&quot;); return false; }else{ flag=true; } } if(flag){ //将要返回的数据打包封装 document.all.formdetail.value = getDetail2(); document.all.lg_sh_deliveryconfirmationcodform.action=&lt;select:link page=&quot;/lg_sh_deliveryconfirmationcodaction.do?method=save&quot;&gt;&lt;/select:link&gt;; document.all.lg_sh_deliveryconfirmationcodform.submit(); } } 给查询结果集计算行数并赋值行数 给查询结果集计算行数并赋值行数 //计算行数 function init(){ for(var i=1; i&lt;=intTotalRow; i++){ document.all.seq[i].value = i; } } ------ 对应的文本框属性 &lt;grid:text style=&quot;width:40px;&quot; readonly=&quot;true&quot; isReturn=&quot;true&quot; capital=&quot;序号&quot; property=&quot;seq&quot; tabindex=&quot;-1&quot;/&gt; div显示切换 点击按钮，让两个div切换显示，只显示一个 &lt;!DOCTYPE html&gt; &lt;script&gt; function btn1(){ document.getElementById(&apos;div1&apos;).style.display=&apos;none&apos;; document.getElementById(&apos;div2&apos;).style.display=&apos;block&apos;; } function btn2(){ document.getElementById(&apos;div1&apos;).style.display=&apos;block&apos;; document.getElementById(&apos;div2&apos;).style.display=&apos;none&apos;; } &lt;/script&gt; &lt;body&gt; &lt;div id=&quot;div1&quot; style=&quot;background:green;height:200px&quot;&gt; 第一个div高200px &lt;/div&gt; &lt;div id=&quot;div2&quot; style=&quot;background:gray; display:none;height:400px&quot;&gt; 第二个div高400px &lt;/div&gt; &lt;button id=&quot;btn1&quot; onclick=&quot;btn1()&quot;&gt;显示第二个&lt;/button&gt; &lt;button id=&quot;btn1&quot; onclick=&quot;btn2()&quot;&gt;显示第一个&lt;/button&gt; &lt;/body&gt; &lt;/html&gt; js过滤空格 过滤获取值的空格 1、过滤字符串两边的空格 str = $.trim(str) 2、过滤所有空格 str = str.replace(/ /g,&apos;&apos;) 例如： var num = document.getElementById(&apos;truckNumInput&apos;).value.replace(/ /g,&apos;&apos;); 输入框获取焦点 加载页面时输入框获取焦点 &lt;script&gt; window.onload = function(){ document.getElementById(&quot;name&quot;).focus(); } &lt;/script&gt; JS代码收集 代码位置(私有) https://git.coding.net/uxaw/keyboard.git 包含内容： 网页键盘 table点击变色 span标签内容居中 span标签内容居中 &lt;body&gt; &lt;div style=&quot;width:160px;height:100px;border:1px dashed #FFFFFF;margin:0 auto&quot; &gt; &lt;span style=&quot;height:100px;display:block;background:gray;margin:1px 1px;text-align:center;line-height:100px;&quot;&gt; 内容内容内容 &lt;/span&gt; &lt;/div&gt; &lt;/body&gt; JQuery格式 JQuery $.post(&quot;login.tushu&quot;,-------------------url { &quot;userName&quot;: userName, &quot;passWord&quot;: passWord }, ---------------------data function (respnum) { var obj = eval(&quot;(&quot; + respnum + &quot;)&quot;); var num = obj.num; if (0 == num) { loginNo.css(&quot;display&quot;, &quot;block&quot;); } else { //跳转页面 location.href = &quot;jsp/index.jsp&quot;; } }) -------------------callback 格式： jQuery.post( url, [data], [callback], [type] JSP中java代码获取路径 获取路径 &lt;% String path = request.getContextPath(); String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + path + &quot;/&quot;; %&gt; 得到结果： http://localhost:8090/ 自动跳转链接（定时） 自动跳转 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;/head&gt; &lt;script type=&quot;text/javascript&quot;&gt; function toDiscuz(){ document.getElementById(&quot;sp&quot;).click(); } &lt;/script&gt; &lt;body onload=&quot;toDiscuz()&quot;&gt; &lt;a href=&quot;https://www.baidu.com&quot;&gt;&lt;span id=&quot;sp&quot;&gt;自动点击&lt;/span&gt;&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 定时3秒后自动跳转 将&lt;body onload=&quot;toDiscuz()&quot;&gt; 改为： &lt;body onload=setTimeout(&quot;toDiscuz(&apos;run&apos;,&apos;1&apos;)&quot;,3000)&gt; bootstrap小窗口弹窗变灰无法操作 更改bootstrap.js源码： 在 .appendTo(this.$body 添加后 .find(&apos;.contentIndex&apos;) 改成： .appendTo(this.$body.find(&apos;.contentIndex&apos;)) 根据身份号码计算年龄 年龄 //计算年龄函数 function GetAge(identityCard) { var len = (identityCard + &quot;&quot;).length; if (len == 0) { return 0; } else { if ((len != 15) &amp;&amp; (len != 18))//身份证号码只能为15位或18位其它不合法 { return 0; } } var strBirthday = &quot;&quot;; if (len == 18)//处理18位的身份证号码从号码中得到生日和性别代码 { strBirthday = identityCard.substr(6, 4) + &quot;/&quot; + identityCard.substr(10, 2) + &quot;/&quot; + identityCard.substr(12, 2); } if (len == 15) { strBirthday = &quot;19&quot; + identityCard.substr(6, 2) + &quot;/&quot; + identityCard.substr(8, 2) + &quot;/&quot; + identityCard.substr(10, 2); } //时间字符串里，必须是“/” var birthDate = new Date(strBirthday); var nowDateTime = new Date(); var age = nowDateTime.getFullYear() - birthDate.getFullYear(); //再考虑月、天的因素;.getMonth()获取的是从0开始的，这里进行比较，不需要加1 if (nowDateTime.getMonth() &lt; birthDate.getMonth() || (nowDateTime.getMonth() == birthDate.getMonth() &amp;&amp; nowDateTime.getDate() &lt; birthDate.getDate())) { age--; } return age; } //赋值 document.getElementById(&apos;realAge&apos;).innerText=age; 待续…]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>随机数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java进阶]]></title>
    <url>%2F2017%2F05%2F15%2FJava%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[Spring spring3和spring4的架构图对比 spring3结构图： spring4架构图： Spring4架构解析 Spring4的5层架构 1.core 2.aop 3.data access 4.web 5.test 下载spring4的jar包将其归类： 1.core Container部分包含4个模块（spring核心容器） spring-core：依赖注入IoC与DI的最基本实现 spring-beans：Bean工厂与bean的装配 spring-context：spring的context上下文即IoC容器 spring-context-support：spring额外支持包，比如邮件服务、视图解析等 spring-expression：spring表达式语言 2.aop部分包含5个模块(AOP &amp; Instrumentation &amp; Messaging) spring-aop：面向切面编程 spring-aspects：集成AspectJ spring-instrument：提供一些类级的工具支持和ClassLoader级的实现，用于服务器 spring-instrument-tomcat：针对tomcat的instrument实现 spring-messaging：用于构建基于消息的应用程序 3.data access部分包含5个模块 spring-jdbc：jdbc的支持 spring-tx：事务控制 spring-orm：对象关系映射，集成orm框架 spring-oxm：对象xml映射 spring-jms：java消息服务 4.web部分包含4个模块 spring-web：基础web功能，如文件上传 spring-webmvc：mvc实现 spring-webmvc-portlet：基于portlet的mvc实现 spring-websocket：为web应用提供的高效通信工具 5.test部分只有一个模块，将spring-context-support也放在这吧 spring-test：spring测试，提供junit与mock测试功能 注： org.springframework.beans和org.springframework.context包是Spring框架IoC容器的基础 注：摘自以下地址&gt; 1.博客 http://www.cnblogs.com/ywlaker/p/6136625.html 2.spring官方文档 http://docs.spring.io/spring/docs/current/spring-framework-reference/html/index.html 查看各个jar的以来关系，请访问上述地址。 Maven的BOM清单统一管理spring版本&lt;!--统一spring各组件的版本--&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-framework-bom&lt;/artifactId&gt; &lt;version&gt;4.3.10.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;!--继承一个父模块，然后再引入相应的依赖--&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;!--junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--spring-context(IOC容器)--&gt; &lt;!--由于上面统一管理了spring的版本，因此此处不必指定context的版本--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 剔除commons-logging使用log4j&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.1.3.RELEASE&lt;/version&gt; &lt;exclusions&gt; &lt;!--排除commons-logging--&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt; &lt;version&gt;1.5.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.5.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.5.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.14&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; IOC该接口org.springframework.context.ApplicationContext代表Spring IoC容器,并负责实例化，配置和组装上述bean ApplicationContext，BeanFactory， IOC 的关系 关系 ApplicationContext是比Beanfactory更加先进的IOC容器的一种实现 ApplicationContext类型容器提供的集中实现 FileSystemXmlApplicationContext：从文件中加载bean定义以及相关资源的ApplicationContext实现。 ClassPathXmlApplicatonContext：从Classpath加载bean定义以及相关资源的Applicationcontext的实现。 XmlWebApplicationContext：用于web应用程序的ApplicationContext的实现。 ApplicationContext与BeanFactory的联系 接口ApplicationContext继承了ListableBeanFactory和HierarchicalBeanFactory这两个接口， 而这两个接口都是继承自BeanFactory接口，BeanFactory接口中有方法getBean(),返回类型为Object. http://www.cnblogs.com/Qbright/archive/2012/07/18/2597184.html beansjavaBeans,POJOs和spring bean javaBeans: 包含默认（无参数）的构造函数 允许通过访问器(getter和setter方法)来访问类的成员属性 实现java.io.Serializable接口 POJO POJO是 Plain Old Java Object（简单的Java对象）的缩写,作为一种花式的对普通Java对象的称呼. Spring beans Spring bean 表示受到Spring管理的对象。具体说来，它是被Spring框架容器初始化、配置和管理的对象 每一个Bean对应Spring容器里的一个Java实例，定义Bean时通常需要指定两个属性。 在Spring中，被Spring IoC 容器 管理的这些来自于应用主干的这些对象称作 beans 。bean是一个由Spring IoC容器进行实例化、装配和管理的对象。此外，bean只是你应用中许多对象中的一个 spring常用注解（annotation） http://www.cnblogs.com/xiaoxi/p/5935009.html 常用 @Component:@Component是所有受Spring 管理组件的通用形式，@Component注解可以放在类的头上，@Component不推荐使用。 @Controller:@Controller对应表现层的Bean，也就是Action。 @Controller注解标识UserAction之后，就表示要把UserAction交给Spring容器管理，在Spring容器中会存在一个名字为&quot;userAction&quot;的action。 这里的UserAction还使用了@Scope注解，spring 默认scope 是单例模式(scope=&quot;singleton&quot;)，这样只会创建一个Action对象，每次访问都是同一Action对象，数据不安全，struts2 是要求每次次访问都对应不同的Action，scope=&quot;prototype&quot; 可以保证当有请求的时候都创建一个Action对象。 @Service:@Service对应的是业务层Bean @Repository:@Repository对应数据访问层Bean @Autowired：自动装配，其作用是为了消除代码Java代码里面的getter/setter与bean属性中的property @Autowired 默认按类型装配，如果我们想使用按名称装配，可以结合@Qualifier注解一起使用。如下： @Autowired @Qualifier(&quot;personDaoBean&quot;) 存在多个实例配合使用 @Resource默认按名称装配，当找不到与名称匹配的bean才会按类型装配。 @Scope(&quot;prototype&quot;)：Spring默认产生的bean是单例的，&quot;prototype&quot;表示原型即每次都会new一个新的出来。 @Configuration把一个类作为一个IoC容器，它的某个方法头上如果注册了@Bean，就会作为这个Spring容器中的Bean。 一般 @Scope注解 作用域 @Lazy(true) 表示延迟初始化 @PostConstruct用于指定初始化方法（用在方法上） @PreDestory用于指定销毁方法（用在方法上） @DependsOn：定义Bean初始化及销毁时的顺序 @Primary：自动装配时当出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常 @PostConstruct 初始化注解 @PreDestroy 摧毁注解 默认 单例 启动就加载 @Async异步方法调用 sqlSessionTemplatesqlSessionFactorysqlSessionTemplateBeanNamesqlSessionFactoryBeanName SpringMVC 待续… MyBatis 待续… SSM简要概述 概述]]></content>
      <tags>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂记]]></title>
    <url>%2F2017%2F05%2F04%2F%E6%9D%82%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[鉴别iphone 鉴别iphone 机子到手后如何验机 1.新机开机后，会有一个感叹号（没有感叹号的证明机子不是未激活的），点击感叹号以后可以看到手机imei，官网查询一下是否未激活 2.电脑下载爱思助手这个软件，然后连接手机到电脑，打开设备信息，看看是否电池充电次数为0 3.官网确认未激活，电池确认没充电过，再用闪光灯检查手机的充电口和耳机口（官方售后喜欢这么检查，所以借鉴一下） 备注：未激活的意思是机子还没使用过的意思，电池充电次数是充电过几次的意思 windows创建计划任务创建定时重启任务 定时重启 windows搜索框搜索”计划任务”，(或者在控制面板（选择小图标显示）-管理工具-任务计划程序)，点击运行，结果如下图 选择创建基本任务(计划任务1.png): 选择启动程序(计划任务2.png): 选择System32\shutdown.exe(计划任务3.png): 添加参数-r,代表重启，-s代表关机(计划任务4.png): 创建定时唤醒任务 创建定时唤醒，利用定时执行程序唤醒休眠中的计算机，注意，是休眠中的计算机 填写任务名称，选择最高权限(可选)（定时唤醒1.png） 新建触发器，设定执行时间，选择执行任务时间为每天（定时唤醒2.png） 新建操作，选择要执行的程序（定时唤醒3.png） 设置条件，勾选 唤醒计算机执行此任务（定时唤醒4.png） 在设置选项勾选如图所示(可选)。（定时唤醒5.png） 远程可以选择使用teamviewer https://www.teamviewer.com/zhCN/ 注意： 为避免电脑长时间休眠等因素导致软件停止运行 首先，将电脑的电源选项改为从不休眠 然后，我的电脑-右键-管理-服务-找到teamviewer-双击，找到恢复选项，改为如下图(teamviewer.png)： 这样做是为了防止teamviewer服务停止运行后，能够重新启动服务，如果连续两次启动失败，那么重新启动计算机（前提是，已经将teamviewer设置为随计算机启动）。 PE装机U盘4G文件 首先把U盘格式化成NTFS格式(这样U盘就能复制超过4G的镜像文件了) 然后再用装机工具制作装机盘（如大白菜），制作装机盘时可选HDD-FAT32，并不会改变U盘的NTFS格式。 WPS弹窗永久关闭 找到WPS安装目录下的wtoolex目录，将其中的wpsnotify.exe替换为txt改变格式为exe的同名文件 为防止wps自动更新/自动更新wpsnotify.exe，同时也将updateself.exe，wpsupdate.exe替换为自己创建的空白exe同名文件 个人不喜欢WPS的云，所以将wpscloudsvr.exe也替换了 IDEA代码类型提示关闭 在settings&gt;Editor&gt;General&gt;Appearance下找到show Parameter取消勾选即可 DNS google DNS 8.8.8.8 8.8.4.4 OpenDNS 208.67.222.222 208.67.220.220 台湾中华电讯DNS 168.95.192.1 168.95.192.2 香港宽频DNS 203.80.96.9 203.80.96.10 查看所有进程占用端口 查看所有进程占用端口 netstat –ano 查看指定端口占用 netstat -ano|findstr &quot;8080&quot; Windows下mysql 1045错误编码 Access denied for user ‘root’@’localhost’ (using password:YES) 1.停止mysql服务 2.打开MySQL目录下的my.ini文件，在文件的最后添加一行“skip-grant-tables”，保存并关闭文件 3.启动mysql服务，cmd下登录mysql mysql -u root -p 不输密码直接回车 重置mysql的root密码，然后重启mysql服务 update user set password=PASSWORD(&quot;123456&quot;) where user=&apos;root&apos;; window下mysql启动/停止命令 启动 net start mysql 停止 net stop mysql 重启 windows下mysql没有restart命令，只能先停止再启动。]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>iphone</tag>
        <tag>计划任务</tag>
        <tag>远程</tag>
        <tag>PE装机4G大文件</tag>
        <tag>WPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础]]></title>
    <url>%2F2017%2F05%2F04%2FJava%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[JVM JVM介绍 JVM是Java Virtual Machine（Java虚拟机）的缩写， JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。 Java虚拟机包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆和一个存储方法域。 JVM屏蔽了与具体操作系统平台相关的信息，使Java程序只需生成在Java虚拟机上运行的目标代码（字节码）,就可以在多种平台上不加修改地运行。 JVM在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。 http://www.cnblogs.com/sunada2005/p/3577799.html equals与== 区别（20180401） 1）对于==，如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等； 如果作用于引用类型的变量，则比较的是所指向的对象的地址 2）对于equals方法，注意：equals方法不能作用于基本数据类型的变量 如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址； 诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。 示例： https://www.nowcoder.com/questionTerminal/04fd8ddb19024dd0acd89bbff85c0a50 String String字符串拼接方式，好处与不足 1.+号直接拼接 2.append() 3.Format》》String.format(&quot;%s和%s一起LOL&quot;, new String[]{ &quot;小明&quot;, &quot;小强&quot;}); 4.StringBuilder stringBuilder效率高，不产生新的对象 string对象操作的时候，总是产生新的对象， 然后自动回收旧的对象(如果没用的话)，效率是比stringBuilder在原对象上进行操作来的低的 参考链接: http://www.cnblogs.com/gc2013/p/4351015.html String 对象 String对象是不可变的，你可以给一个String对象加任意多的别名。因为String对象具有只读特性，所以指向它的任何引用都不可能改变它的值。 不可变性也会带来一定的效率问题。 http和https http和https 一、https协议需要到ca申请证书，一般免费证书很少，需要交费。 二、http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。 三、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 四、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、 身份认证的网络协议，比http协议安全。 Java数据类型 基本数据类型（四类八种） 整型( byte short int long ) 浮点型( float double ) 字符型( char ) 布尔型( boolean ) 引用数据类型 数组型 接口型 类类型 数据类型图示(java数据类型.png) 注意：byte,short,char都可以隐含转换为int，long不能转换为int char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中可以存储汉字(未包含在unicode编码中的特殊汉字除外).unicode编码占用两个字节，所以，char类型的变量也是占用两个字节。 堆栈区域 成员变量存在于堆内存中，默认有初始值。 局部变量存在于栈内存中，没有默认初始值。 图解1(堆栈图解1.png) 图解2(堆栈图解2.png) 集合简单总结 常用总结比较(集合总结2.png) 由此可得，HashMap可以存储一个key为null,多个value为null的键值对。 Collection和Map框架结构 比较常用的Collection子类与Map子类简图(Collection和Map框架结构.png) 泛型与容器的关系容器，即:存对象的地方，当把对象存进容器中时，就转变成了Object类型的对象，那么在取出对象元素时，就需要做类型转换(向下转换)，那么就可能发生类型转换异常(ClassCastException)，这个时候，如果有一种约束，来确保存进去的是一种具体类型，那么取出时就不用再做类型转换的工作了，那么也就可以有效防止类型转换异常的出现了，那么这种约束，就是java中的泛型，一种对容器概念的有效补充。 简单的容器分类 分类图(简单的容器分类.png) 接口类型的子类对象的意义 多态的体现(接口类型的子类对象的意义.png) LinkedList与ArrayList LinkedList LinkedList底层是由双向循环链表实现，里面的数据在逻辑上的存储是连续的，连续自然也就有顺序了 LinkedList与ArrayList的比较 LinkedList也像ArrayList一样实现了基本的List接口，但是它执行某些操作时比ArrayList更高效（在List的中间插入和移除），但在随机访问操作方面却要逊色一些。 ArrayList底层的实现是数组，所以用下标访问的速度比较快，但是插入和删除元素，会有移动元素的开销，所以速度比LinkedList差。 LikedList底层是链表实现的，所以插入和删除元素时间复杂度较LinkedList好，但是随即访问需要遍历元素，所以效率比ArrayList差 SetSet不保存重复元素 Iterator与Iterable 不同的包 java.lang.Iterable java.util.Iterator 数组增加元素 数组是定长，需要用Arrays.asList转换为List,再转换为ArrayList才能进行写操作 String[] arr = new String[2]; arr[0] = &quot;1&quot;; arr[1] = &quot;2&quot;; List&lt;String&gt; listArr = new ArrayList&lt;&gt;(Arrays.asList(arr)); listArr.add(2,&quot;5&quot;); java Native 方法 native方法 native关键字说明其修饰的方法是一个原生态方法，方法对应的实现不是在当前文件，而是在用其他语言（如C和C++）实现的文件中。Java语言本身不能对操作系统底层进行访问和操作，但是可以通过JNI接口调用其他语言来实现对底层的访问。 JNI JNI是Java本机接口（Java Native Interface），是一个本机编程接口，它是Java软件开发工具箱（Java Software Development Kit，SDK）的一部分。JNI允许Java代码使用以其他语言编写的代码和代码库。Invocation API（JNI的一部分）可以用来将Java虚拟机（JVM）嵌入到本机应用程序中，从而允许程序员从本机代码内部调用Java代码。 Object是抽象类吗？ 查看Object源码可以看到，许多方法是没有实现体的，但是Object类并不是抽象类，因为这些没有方法体的方法用Native修饰，其实现体并不是java语言写的。 引用传递与值传递 引用传递与值传递 JAVA里除了8种基本类型传参数是值传递，其他的类对象传参数都是引用传递 java中的编译时类型和运行时类型 运行时类型与编译时类型 Java中的许多对象（一般都是具有父子类关系的父类对象）在运行时都会出现两种类型：编译时类型和运行时类型，例如：Person person = new Student();这行代码将会生成一个person变量，该变量的编译时类型是Person，运行时类型是Student。 Java的引用变量有两个类型，一个是编译时类型，一个是运行时类型，编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。如果编译时类型和运行时类型不一致，会出现所谓的多态 jdk打包与解压 打包命令 jar -cvf diaowen.war diaowen 解压命令 jar xvf diaowen.war]]></content>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java源码计划]]></title>
    <url>%2F2017%2F04%2F20%2Fjava%E6%BA%90%E7%A0%81%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[JDK源码阅读计划：JDK（Java SE Development Kit） Java运行时环境(JVM) Java的基础类库 是Java的开发工具 第一部分：Java运行时环境 对于JVM，就是往死里学，往死里研究，能有多深就多深。 第二部分：Java的基础类库 第一级别：精读源码 java.io java.lang java.util Exception和Error这一类的，就不用读源码了 第二级别：深刻理解 java.lang.reflect java.net javax.net.* java.nio.* java.util.concurrent.* 第三级别：会用即可 java.lang.annotation javax.annotation.* java.lang.ref java.math java.rmi.* javax.rmi.* java.security.* javax.security.* java.sql javax.sql.* javax.transaction.* java.text javax.xml.* org.w3c.dom.* org.xml.sax.* javax.crypto.* javax.imageio.* javax.jws.* java.util.jar java.util.logging java.util.prefs java.util.regex java.util.zip 第四级别：无视它 swing awt ... 第三部分：Java的开发工具 javac jmap jconsole jstac jvisualvm JDK的bin目录find …… 可以把第一级别的那些包称作基础，第二级别的那些包称为进阶。最重要的还是那万年不变的JVM，JVM才是Java根基的根本，再牛的类，没了JVM它也就是一个无用的class文件而已。 Linux实践计划 习惯并持续ubunutu环境下编程 未来接触 高并发 分布式]]></content>
      <tags>
        <tag>&lt;font</tag>
        <tag>size=4</tag>
        <tag>color=black&gt;JavaSE&lt;/font&gt;</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL基础]]></title>
    <url>%2F2016%2F12%2F20%2FSQL%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[概念SQL: 结构化查询语言(Structured Query Language) mysql配置程序F:\mysql\server\bin\MySQLInstanceConfig.exe 数据库的删除命令drop 表索引，表的存储过程，表结构和数据 都会删除 delete 删除部分表记录(可以配合where条件) truncate 删除表的所有记录 SQL语法 SQL语句可以在单行或多行书写，以分号结尾 可使用空格和缩进来增强语句的可读性 MySQL不区别大小写，建议关键字使用大写如SELECT*FROM booktable; SQL语句分类1. DDL（Data Definition Language）：数据定义语言，用来定义数据库对象：库、表、列等； &gt; 创建、删除、修改：库、表结构！！！ DDL：数据库或表的结构操作(*****) 2. DML（Data Manipulation Language）：数据操作语言，用来定义数据库记录（数据）； &gt; 增、删、改：表记录 DML：对表的记录进行更新（增、删、改）(*****) 3. DCL（Data Control Language）：数据控制语言，用来定义访问权限和安全级别； DCL：对用户的创建，及授权！ 4. DQL*****（Data Query Language）：数据查询语言，用来查询记录（数据）。 DQL：对表的记录的查询（*****，难点） DML(对表的记录进行更新（增、删、改）)1. 插入数据* INTERT INTO 表名(列名1,列名2, ...) VALUES(列值1, 列值2, ...); &gt; 在表名后给出要插入的列名，其他没有指定的列等同与插入null值。所以插入记录总是插入一行，不可能是半行。 &gt; 在VALUES后给出列值，值的顺序和个数必须与前面指定的列对应 * INTERT INTO 表名 VALUES(列值1, 列值2) &gt; 没有给出要插入的列，那么表示插入所有列。 &gt; 值的个数必须是该表列的个数。 2. 修改数据* UPDATE 表名 SET 列名1=列值1, 列名2=列值2, ... [WHERE 条件] * 条件(条件可选的)： &gt; 条件必须是一个boolean类型的值或表达式：UPDATE t_person SET gender=&apos;男&apos;, age=age+1 WHERE sid=&apos;1&apos;; &gt; 运算符：=、!=、&lt;&gt;、&gt;、&lt;、&gt;=、&lt;=、BETWEEN...AND、IN(...)、IS NULL、NOT、OR、AND 例句： WHERE age &gt;= 18 AND age &lt;= 80 WHERE age BETWEEN 18 AND 80 WHERE name=&apos;zhangSan&apos; OR name=&apos;liSi&apos; WHERE name IN (&apos;zhangSan&apos;, &apos;liSi&apos;) WHERE age IS NULL, 不能使用等号 WHERE age IS NOT NULL DQL:数据查询语言，用来查询记录（数据）一、 基本查询1. 字段(列)控制 1) 查询所有列 SELECT * FROM 表名; SELECT * FROM emp; --&gt; 其中“*”表示查询所有列 2) 查询指定列 SELECT 列1 [, 列2, ... 列N] FROM 表名; SELECT empno, ename, sal, comm FROM 表名; 3) 完全重复的记录只一次 当查询结果中的多行记录一模一样时，只显示一行。一般查询所有列时很少会有这种情况，但只查询一列（或几列）时，这总可能就大了！ SELECT DISTINCT * | 列1 [, 列2, ... 列N] FROM 表名; SELECT DISTINCT sal FROM emp; --&gt; 保查询员工表的工资，如果存在相同的工资只显示一次！ 4) 列运算 I 数量类型的列可以做加、减、乘、除运算 SELECT sal*1.5 FROM emp; SELECT sal+comm FROM emp; II 字符串类型可以做连续运算 SELECT CONCAT(&apos;$&apos;, sal) FROM emp; III 转换NULL值 有时需要把NULL转换成其它值，例如com+1000时，如果com列存在NULL值，那么NULL+1000还是NULL，而我们这时希望把NULL当前0来运算。 SELECT IFNULL(comm, 0)+1000 FROM emp; --&gt; IFNULL(comm, 0)：如果comm中存在NULL值，那么当成0来运算。 IV 给列起别名 你也许已经注意到了，当使用列运算后，查询出的结果集中的列名称很不好看，这时我们需要给列名起个别名，这样在结果集中列名就显示别名了 SELECT IFNULL(comm, 0)+1000 AS 奖金 FROM emp; --&gt; 其中AS可以省略 例句： 查询指定列 SELECT empno,ename,sal 工资,comm FROM emp; 查询不重复记录 SELECT DISTINCT job,sal,ename FROM emp; 查询结果做运算 SELECT*,sal*2 实际工资 FROM emp; IFNULL条件转换NULL值 SELECT*,sal+IFNULL(comm,0) 实际绩效工资 FROM emp; CONCAT字符串连接 SELECT CONCAT(&quot;我是&quot;,ename) FROM emp; SELECT CONCAT(&apos;我是&apos;,ename) FROM emp; 用IS NOT NULL做NULL条件判断，不能用!=NULL或&lt;&gt;NULL SELECT*FROM emp WHERE comm IS NOT NULL; 给列起别名 SELECT ename AS 姓名,job AS 工作岗位 FROM emp; 或 SELECT ename 姓名,job 工作岗位 FROM emp; 2.条件控制 1) 条件查询 与前面介绍的UPDATE和DELETE语句一样，SELECT语句也可以使用WHERE子句来控制记录。 * SELECT empno,ename,sal,comm FROM emp WHERE sal &gt; 10000 AND comm IS NOT NULL; * SELECT empno,ename,sal FROM emp WHERE sal BETWEEN 20000 AND 30000; * SELECT empno,ename,job FROM emp WHERE job IN (&apos;经理&apos;, &apos;董事长&apos;); 2) 模糊查询 当你想查询姓张，并且姓名一共两个字的员工时，这时就可以使用模糊查询 * SELECT * FROM emp WHERE ename LIKE &apos;张_&apos;; --&gt; 模糊查询需要使用运算符：LIKE，其中_匹配一个任意字符，注意，只匹配一个字符而不是多个。 --&gt; 上面语句查询的是姓张，名字由两个字组成的员工。 * SELECT * FROM emp WHERE ename LIKE &apos;___&apos;; /*姓名由3个字组成的员工*/ 如果我们想查询姓张，名字几个字可以的员工时就要使用“%”了。 SELECT * FROM emp WHERE ename LIKE &apos;张%&apos;; --&gt; 其中%匹配0~N个任意字符，所以上面语句查询的是姓张的所有员工。 SELECT * FROM emp WHERE ename LIKE &apos;%阿%&apos;; --&gt; 千万不要认为上面语句是在查询姓名中间带有阿字的员工，因为%匹配0~N个字符，所以姓名以阿开头和结尾的员工也都会查询到。 SELECT * FROM emp WHERE ename LIKE &apos;%&apos;; --&gt; 这个条件等同与不存在，但如果姓名为NULL的查询不出来！ 例句： 条件查询 按工资范围查询 SELECT*FROM emp WHERE sal &gt;= 2000 AND sal &lt;=20000; SELECT*FROM emp WHERE sal BETWEEN 2000 AND 20000; 按职位查询 SELECT * FROM emp WHERE job IN(&apos;销售员&apos;,&apos;经理&apos;) ORDER BY job; 关键字：IN 或 NOT IN 模糊查询 姓张，且为两个字 SELECT*FROM emp WHERE ename LIKE &apos;张_&apos;; 姓张，字数不限 SELECT*FROM emp WHERE ename LIKE&apos;张%&apos;; 查询以 牛 字结尾的姓名 SELECT*FROM emp WHERE ename LIKE &apos;%牛&apos;; 查询姓名中带 牛 字的，无论是开头，中间，还是结尾带 牛 字的，都会被查询出来 SELECT*FROM emp WHERE ename LIKE&apos;%牛%&apos;; 二、 排序1) 升序 SELECT * FROM WHERE emp ORDER BY sal ASC; --&gt; 按sal排序，升序！ --&gt; 其中ASC是可以省略的 2) 降序 SELECT * FROM WHERE emp ORDER BY comm DESC; --&gt; 按comm排序，降序！ --&gt; 其中DESC不能省略 3) 使用多列作为排序条件 SELECT * FROM WHERE emp ORDER BY sal ASC, comm DESC; --&gt; 使用sal升序排，如果sal相同时，使用comm的降序排 例句： 按sal升序排列，若sal相同，按comm降序排列 SELECT*FROM emp ORDER BY sal ASC,comm DESC; 三、聚合函数(用来做某列的纵向运算的) 聚合函数用来做某列的纵向运算，在条件中不能出现聚合函数。 1) COUNT SELECT COUNT(*) FROM emp; --&gt; 计算emp表中所有列都不为NULL的记录的行数 SELECT COUNT(comm) FROM emp; --&gt; 云计算emp表中comm列不为NULL的记录的行数 2) MAX SELECT MAX(sal) FROM emp; --&gt; 查询最高工资 3) MIN SELECT MIN(sal) FROM emp; --&gt; 查询最低工资 4) SUM SELECT SUM(sal) FROM emp; --&gt; 查询工资合 5) AVG SELECT AVG(sal) FROM emp; --&gt; 查询平均工资 例句： 查询总人数(注意，下句中数字1和*的意思相同，都表示所有。不论是1还是2，3等，都一样的意思) SELECT COUNT(*) FROM emp; SELECT COUNT(1) FROM emp; 查询工资sal总额 SELECT SUM(sal) FROM emp; 查询平均工资 SELECT AVG(sal) FROM emp; 查询最高工资的员工 SELECT MAX(sal),ename FROM emp; 查询最低工资的员工 SELECT MIN(sal),ename FROM emp; 查询以上所有 SELECT COUNT(*) 总人数,COUNT(sal) 工资总和,AVG(sal) 平均工资,MAX(sal) 最高工资,MIN(sal) 最低工资 FROM emp; 三、 分组查询分组查询是把记录使用某一列进行分组，然后查询组信息。 例如：查看所有部门的记录数。 SELECT deptno, COUNT(*) FROM emp GROUP BY deptno; --&gt; 使用deptno分组，查询部门编号和每个部门的记录数 SELECT job, MAX(SAL) FROM emp GROUP BY job; --&gt; 使用job分组，查询每种工作的最高工资 组条件 以部门分组，查询每组记录数。条件为记录数大于3 SELECT deptno, COUNT(*) FROM emp GROUP BY deptno HAVING COUNT(*) &gt; 3; 关键字的先后顺序： select from where （分组前）条件关键字 group by 分组关键字 having (分组)后置条件关键字 order by 排序关键字 例句： 查询各部门人数 SELECT deptno 部门编号,COUNT(*) 总人数 FROM emp GROUP BY deptno; 查询各岗位人数 SELECT job 工作岗位,COUNT(*) 人数 FROM emp GROUP BY job; 查询各岗位中工资大于20000的人数-------------------(分组前的条件) SELECT job,COUNT(*) 人数 FROM emp WHERE sal&gt;=2000 GROUP BY job; 查询各岗位中工资大于2000，且人数不少于3---------------(分组后的条件) SELECT job 工作岗位,COUNT(*) FROM emp WHERE sal&gt;=2000 GROUP BY job HAVING COUNT(*)&gt;=3; HAVING在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与合计函数一起使用。 四、 limit子句(方言)LIMIT用来限定查询结果的起始行，以及总行数。 注意：mysql记录下标从0计数 例如：查询起始行为第5行，一共查询3行记录 SELECT * FROM emp LIMIT 4, 3; --&gt; 其中4表示从第5行开始，其中3表示一共查询3行。即第5、6、7行记录。 select * from emp limit 0, 5; 1. 一页的记录数：10行 2. 查询第3页 select * from emp limit 20, 10; (当前页-1) * 每页记录数 (3-1) * 10 查询第17页，每页8条记录 (17-1) * 8, 8 例句： 查询第3页，每页4条记录 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (3-1）*4=8,即，从第9行记录开始查询，第9行下标为8 SELECT * FROM stu LIMIT 8,4; 五、 多表查询多表查询分类： * 合并结果集(了解) * 连接查询 * 子查询 合并结果集 合并结果集 * 要求被合并的表(实际是被合并的结果集)中，列的类型和列数相同（上下合并，而不是横向合并） * UNION，去除重复行 * UNION ALL，不去除重复行 SELECT * FROM cd UNION ALL SELECT * FROM ab; 例句： 不去除重复行 SELECT deptno FROM emp UNION ALL SELECT deptno FROM dept; 去除重复行 SELECT deptno FROM emp UNION SELECT deptno FROM dept; 内链接（内连接多表查询） * 方言：SELECT * FROM 表1 别名1, 表2 别名2 WHERE 别名1.xx=别名2.xx * 标准：SELECT * FROM 表1 别名1 INNER JOIN 表2 别名2 ON 别名1.xx=别名2.xx * 自然：SELECT * FROM 表1 别名1 NATURAL JOIN 表2 别名2 * 内连接查询出的所有记录都满足条件。 内连接查询的语句逻辑可以参考下面SQL语句推导： SELECT * FROM emp,dept; 下列三种SQL语句，建议使用标准版语句，便于数据库的更换； 例句： 标准版（通用）SQL语句 查询每个员工的姓名，工资，部门名称 SELECT e.ename,e.sal,d.dname FROM emp e INNER JOIN dept d ON e.deptno=d.deptno; mysql方言版 查询每个员工的姓名，工资，部门名称 SELECT e.ename,e.sal,d.dname FROM emp e,dept d WHERE e.deptno=d.deptno; 自然版 查询每个员工的姓名，工资，部门名称 SELECT e.ename,e.sal,d.dname FROM emp e NATURAL JOIN dept d 外连接(外连接多表查询) 外连接有一主一次，左外即左表为主 如下面例子：即emp为主，那么主表中所有的记录无论满足条件与否，都会被打印出来。 当不满足条件是，右表部门使用NULL来补位。 左外连接 查询所有员工的姓名，薪水，所属部门(部门名称) SELECT e.ename,e.sal,d.dname FROM emp e LEFT OUTER JOIN dept d ON e.deptno=d.deptno; ------------用IFNULL做判断后的假名------------------ SELECT e.ename,e.sal,IFNULL(d.dname,&apos;无部门&apos;) AS dname FROM emp e LEFT OUTER JOIN dept d ON e.deptno=d.deptno; 右外连接emp 查询所有部门中员工的姓名，薪水，所属部门(部门名称) SELECT e.ename,e.sal,d.dname FROM emp e RIGHT OUTER JOIN dept d ON e.deptno=d.deptno; 全连接 查询所有部门的所有员工的姓名，薪水，所属部门(部门名称)---利用左外连接和右外连接 进行合并结果集 完成全外连接查询（因为mysql不支持全连接查询） SELECT e.ename,e.sal,d.dname FROM emp e LEFT OUTER JOIN dept d ON e.deptno=d.deptno UNION SELECT e.ename,e.sal,d.dname FROM emp e RIGHT OUTER JOIN dept d ON e.deptno=d.deptno; 子查询 子查询：一条查询语句中有多个SELECT关键字，就是子查询(也叫嵌套查询) 1. 出现的位置： select后也可以有，但是不规范，所以不用 * where后作为条件存在 * from后作为表存在(多行多列) 2. 条件 * (***)单行单列：SELECT * FROM 表1 别名1 WHERE 列1 [=、&gt;、&lt;、&gt;=、&lt;=、!=] (SELECT 列 FROM 表2 别名2 WHERE 条件) * (**)多行单列：SELECT * FROM 表1 别名1 WHERE 列1 [IN, ALL, ANY] (SELECT 列 FROM 表2 别名2 WHERE 条件) * (*)单行多列：SELECT * FROM 表1 别名1 WHERE (列1,列2) IN (SELECT 列1, 列2 FROM 表2 别名2 WHERE 条件) * (***)多行多列：SELECT * FROM 表1 别名1 , (SELECT ....) 别名2 WHERE 条件 例句： 1. 查询本公司工资最高的员工信息 select* from emp where sal= (select max(sal) from emp); 2. 查询emp表中职位和部门与殷天正一样的所有员工的姓名，部门，工作岗位 SELECT b.ename,b.deptno,b.job FROM emp b WHERE (deptno,job) IN (SELECT deptno,job FROM emp WHERE ename=&apos;殷天正&apos;) 3．查询员工中工资比30部门中所有人工资高的员工的姓名，工资 SELECT a.ename,a.sal FROM emp a WHERE sal &gt; ALL (SELECT MAX(sal) FROM emp WHERE deptno=&apos;30&apos;) 3. 查询员工中工资比任何一个30部门中工资高的员工的姓名，工作岗位，工资 SELECT a.ename,a.job,a.sal FROM emp a WHERE sal&gt; ANY (SELECT sal FROM emp WHERE deptno=&apos;30&apos;) 员工表练习 员工表建表SQL： http://op05inpyd.bkt.clouddn.com/%E5%91%98%E5%B7%A5%E8%A1%A8%E5%BB%BA%E8%A1%A8SQL.sql 员工表查询练习SQL: http://op05inpyd.bkt.clouddn.com/%E5%91%98%E5%B7%A5%E8%A1%A8SQL%E5%AD%A6%E4%B9%A0.sql 多表查询练习之学生表 参考博客： http://www.cnblogs.com/qixuejia/p/3637735.html 建表SQL http://op05inpyd.bkt.clouddn.com/%E5%AD%A6%E7%94%9F%E8%A1%A8%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%BB%BA%E8%A1%A8%E8%AF%AD%E5%8F%A5.sql 学生表多表查询练习： SQL文件链接： http://op05inpyd.bkt.clouddn.com/%E5%AD%A6%E7%94%9F%E8%A1%A8%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0%E7%AD%94%E6%A1%88%E8%AF%AD%E5%8F%A5.sql SQL语句 2017/9/22 9:54:52 (改) 1、查询“001”课程比“002”课程成绩高的所有学生的学号 --------------子查询版------------------------------- SELECT a.sid 学生编号 FROM (SELECT sid,score FROM sc WHERE cid=&apos;1&apos;)a, (SELECT sid,score FROM sc WHERE cid=&apos;2&apos;)b WHERE a.score&gt;b.score AND a.sid=b.sid -----------------非子查询版--------------------------- SELECT a.* FROM sc AS a LEFT JOIN sc AS b ON a.Sid = b.Sid AND a.Cid = &apos;1&apos; AND b.Cid=&apos;2&apos; WHERE a.score&gt;b.score 2、查询平均成绩大于60分的同学的学号和平均成绩 SELECT sid,a.score FROM (SELECT sid,AVG(score) score FROM sc GROUP BY sid)a WHERE a.score&gt;60; -----------------非子查询版--------------------------- SELECT sid,AVG(SCORE) FROM sc GROUP BY sid HAVING AVG(SCORE) &gt;60; 3、查询所有同学的学号、姓名、选课数、总成绩 SELECT a.sid,a.sname,b.num,c.sumscore FROM student a, (SELECT sid,COUNT(cid) num FROM sc GROUP BY sid) b, (SELECT sid,SUM(score) sumscore FROM sc GROUP BY sid) c WHERE a.sid=b.sid AND b.sid=c.sid; -----------------非子查询版--------------------------- SELECT a.sid,a.sname,COUNT(b.Cid),SUM(b.score) FROM student AS a LEFT JOIN sc AS b ON a.Sid = b.Sid GROUP BY a.Sid; 4、查询姓“叶”的老师的个数 SELECT COUNT(*) 个数 FROM teacher WHERE Tname LIKE &apos;叶%&apos;; -----------------或----------------------------------- SELECT COUNT(1) 个数 FROM teacher WHERE Tname LIKE &apos;叶%&apos;; 5、查询没学过“叶平”老师课的同学的学号、姓名 有误： SELECT a.sid ,b.sname FROM sc a,student b WHERE cid != (SELECT cid FROM course WHERE tid = (SELECT tid FROM teacher WHERE tname=&apos;叶平&apos;)) AND a.sid=b.sid GROUP BY sid; -------------------------改---------------------------------- SELECT Sid,Sname FROM student WHERE sid NOT IN( SELECT a.Sid FROM student AS a LEFT JOIN sc AS b ON b.Sid = a.Sid LEFT JOIN course AS c ON c.Cid = b.Cid INNER JOIN teacher AS d ON d.Tid = c.Tid AND d.Tname =&apos;叶平&apos; ) 6、查询学过“001”并且也学过编号“002”课程的同学的学号、姓名 SELECT a.sid,c.sname FROM student c, (SELECT sid FROM sc WHERE cid=1)a, (SELECT sid FROM sc WHERE cid=2)b WHERE a.sid = b.sid AND c.sid=b.sid 7、查询学过“叶平”老师所教的所有课的同学的学号、姓名 SELECT a.sid,sname FROM sc a,student b WHERE cid = (SELECT cid FROM course WHERE tid = (SELECT tid FROM teacher WHERE tname=&apos;叶平&apos;)) AND a.sid=b.sid 8、查询课程编号“002”的成绩比课程编号“001”课程低的所有同学的学号、姓名 SELECT a.sid,sname FROM student c, (SELECT sid,score FROM sc WHERE cid=&apos;1&apos;)a, (SELECT sid,score FROM sc WHERE cid=&apos;2&apos;)b WHERE a.score&gt;b.score AND a.sid = b.sid AND c.sid=b.sid 9、查询所有课程成绩小于60分的同学的学号、姓名 SELECT b.sid,a.sname FROM student a, (SELECT sid FROM sc WHERE score &lt;60)b WHERE a.sid=b.sid GROUP BY sname 10、查询没有学全所有课的同学的学号、姓名 SELECT a.sid,sname FROM student b, (SELECT sid,COUNT(cid) anum FROM sc GROUP BY sid)a WHERE a.anum&lt; (SELECT COUNT(cname)bnum FROM course) AND a.sid=b.sid MySql的备份与恢复数据库mysqldump -uroot -p123 exam&gt;C:\mydb1.sql 存储过程存储过程的优点 增强SQL语句的功能和灵活性； 实现较快的执行速度； 减少网络流量。 创建存储过程 查询中拼接字符串 拼接列与字符串 select username,password,CONCAT(username,&quot;@test.com&quot;) as email from pre_ucenter_members 未完待续…..]]></content>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git操作相关]]></title>
    <url>%2F2016%2F10%2F19%2FGit%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[加入git版本控制 基本命令 1.创建项目 2.git init 3.git add [需要加入版本控制的文件] 4.git commit -m&quot;提交信息&quot; 5.关联远程仓库 git remote add origin https://git.coding.net/uxaw/surveyDemo.git 6. 首次推动并关联远分枝 git push -u origin master 拉取或者推送时如果提示分支找不到，需要到远程仓库合并一下分支. 我们第一次推送master分支时，加上了 –u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来 7.拉取远程仓库：$ git pull [remoteName] [localBranchName] $ git pull （可省略origin master） 8. 以后推送 git push origin master 9.切换分支 git checkout -b mytagname tagname tagname：分支名称 mytagname：存到本地的重命名，建议和原分支名称一致 *.推送远程仓库：$ git push [remoteName] [localBranchName] $ git push origin master:matser 参考链接：http://blog.csdn.net/free_wind22/article/details/50967723 10.更改远程仓库链接： 如：修改远程仓库项目名将导致项目的访问 URL（包含 Git 仓库的 URL）将会改变，在此之前的 URL 地址将失效。 Git仓库地址修改命令： git remote set-url origin [NEW_URL] 忽略已跟踪文件 还没有加到版本控制中 (1)还没有Git add 在 .gitignore中添加 (2)已经git add 先git rm -r --cached 文件 在.gitignore中添加 已经加到版本控制中 先git rm -r --cached 文件名 再在.gitignore中添加 最后gti commit -m提交.gitignore&apos; git bash下创建gitignore的命令： touch .gitignore Git相关命令 查看状态： git status 远程仓库版本覆盖本地版本： $ git fetch –all //与远程同步 $ git reset --hard origin/master //将本地的状态回退到和远程的一样 git fetch 只是下载远程的库的内容，不做任何的合并git reset 把HEAD指向刚刚下载的最新的版本 查看所关联的远程仓库 $ git remote -v 创建.gitignore文件 git bash下创建gitignore的命令： touch .gitignore 设置账户 设置用户名和邮箱： git config --global user.name &quot;ux&quot; git config --global user.email &quot;ux@gmail.com&quot; 查看用户名和邮箱 $ git config user.name $ git config user.email Git里程碑 创建添加里程碑 创建本地里程碑： git tag v1.0 删除本地里程碑： git tag -d v1.0 共享推送里程碑到远成仓库： git push origin v1.0 删除远程仓库里程碑： git push origin :v1.0 Git第三方客户端SourceTree sourcetree git第三方桌面客户端： Source Tree https://www.sourcetreeapp.com/ 安装sourceTree时跳过账户登录 C:\Users\UX\AppData\Local\Atlassian\SourceTree下新建(或者替换)accounts.json （UX是我的计算机用户名,找到自己的对应即可,我的版本是2.0.19.1） accounts.json内容如下： [ { &quot;$id&quot;: &quot;1&quot;, &quot;$type&quot;: &quot;SourceTree.Api.Host.Identity.Model.IdentityAccount, SourceTree.Api.Host.Identity&quot;, &quot;IsDefault&quot;: false, &quot;Authenticate&quot;: true, &quot;HostInstance&quot;: { &quot;$id&quot;: &quot;2&quot;, &quot;$type&quot;: &quot;SourceTree.Host.Atlassianaccount.AtlassianAccountInstance, SourceTree.Host.AtlassianAccount&quot;, &quot;Host&quot;: { &quot;$id&quot;: &quot;3&quot;, &quot;$type&quot;: &quot;SourceTree.Host.Atlassianaccount.AtlassianAccountHost, SourceTree.Host.AtlassianAccount&quot;, &quot;Id&quot;: &quot;atlassian account&quot; }, &quot;BaseUrl&quot;: &quot;https://id.atlassian.com/&quot; }, &quot;Credentials&quot;: { &quot;$id&quot;: &quot;4&quot;, &quot;$type&quot;: &quot;SourceTree.Model.BasicAuthCredentials, SourceTree.Api.Account&quot;, &quot;Username&quot;: &quot; &quot;, &quot;Email&quot;: null, &quot;AvatarURL&quot;: null, &quot;AuthenticationScheme&quot;: { &quot;$type&quot;: &quot;SourceTree.Model.BasicAuthAuthenticationScheme, SourceTree.Api.Account&quot;, &quot;Value&quot;: &quot;Username/Password&quot;, &quot;Name&quot;: &quot;Basic&quot;, &quot;Description&quot;: &quot;Password&quot;, &quot;HeaderValuePrefix&quot;: &quot;Basic&quot;, &quot;UsernameIsRequired&quot;: true }, &quot;Id&quot;: &quot; &quot;, &quot;DisplayName&quot;: null } } ] 或者到此链接复制： http://op05inpyd.bkt.clouddn.com/accounts.json 多git服务使用配置(ssh key)Mac下配置多个Git账户(ssh key方式)查看用户名和邮箱 git config user.name git config user.email 1.如果之前已经使用该命令进行配置，则先使用如下命令清除git config --global --unset user.name git config --global --unset user.email 2.设置全局账户git config --global user.name &quot;ux&quot; git config --global user.email &quot;ux@gmail.com&quot; 3.对每个账户生成一对密钥1.首先进入保存秘钥的目录(mac下路径如下) cd ~/.ssh 2.然后，根据账户邮箱生成秘钥。例如我在GitHub上的邮箱是ux@gmail.com，则命令为： ssh-keygen -t rsa -C &quot;ux@gmail.com&quot; 3.输入完成后，会有如下提示 Generatingpublic/privatersa key pair.Enter fileinwhich to save the key (/Users/liugui/.ssh/id_rsa): 这里要求对秘钥进行命名，默认的文件名是id_rsa。为了方便区分，我这里命名为id_rsa_github 接下来的提示都直接进行回车，直到秘钥生成。通过ls命令，可以看到刚刚生成的密钥对id_rsa_github和id_rsa_github.pub。 其中id_rsa_github.pub是公钥 4.私钥添加到本地ssh-add ~/.ssh/id_rsa_github // 将GitHub私钥添加到本地 5.对本地秘钥进行配置由于添加了多个密钥文件，所以需要对这多个密钥进行管理。在.ssh目录下新建一个config文件： touch config config配置内容如下： #############github############### #网站的别名，随意取 Host github.com #托管网站的域名 HostName github.com #托管网站上的用户名 User uxawseny #使用的密钥文件 IdentityFile ~/.ssh/is_rsa_github ##############公司git################ #网站的别名，随意取 Host git.cp.com #托管网站的域名 HostName git.cp.com #托管网站上的用户名 User myname #使用的密钥文件 IdentityFile ~/.ssh/id_rsa_cp 这里的host name最好和git服务器的SSH下载方式上的 git@github.com:uxawseny/test.git @符号后面的一直，这样每次clone时就默认不用手动更改了， 比如github的ssh key的host name，就命名为github.com 6.公钥添加到托管网站将公钥id_rsa_github.pub中的内容复制到github 7.测试是否成功这时候，可以测试一下配置是否成功，测试命令使用别名。例如，对于GitHub，本来应该使用的测试命令是： ssh -T git@github.com 8.选择SSH协议的复制命令，如对于GitLab上代码库test，其复制命令为git clone git@github.com:ux/test.git 9.添加其他git账户依次操作即可10.做完这些后几个清除全局用户名和邮箱，否则不同仓库提交时的用户名和邮箱信息都是一样的。git config --global --unset user.name git config --global --unset user.email 用上述命令清除掉全局用户名和邮箱信息后，再在每个项目中设置用户名和邮箱信息（不使用全局参数） git config --unset user.name git config--unset user.email 或者在IDEA中提交时再填写用户名和邮箱，但是要记得取消勾选&quot;作为全局设置&quot; 参考文章 https://www.jianshu.com/p/6507ce357ad2 github项目fork之后实时同步原项目的更新1.将fork到的项目git clone拉取到本地2.进到拉取的project目录下，然后增加远程分支(fork的原始项目地址)，名为 update_new（名字任意）到本地git remote add update_new https://github.com/_original/_project.git 3.查看分支时候添加成功（会发现多了刚才添加的远程分支）git remote -v 4.然后把远程原始分支 update_new 的代码拉到本地git fetch update_new 5.合并对方远程原始分支 update_new 的代码git merge update_new/master 6.最后把最新的代码推送到你的github上git push origin master 参考文章 https://www.cnblogs.com/relucent/p/6479213.html]]></content>
      <tags>
        <tag>&lt;font</tag>
        <tag>size=5</tag>
        <tag>color=black&gt;Git&lt;/font&gt;</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo引擎及Next主题]]></title>
    <url>%2F2016%2F04%2F19%2FHexo%E5%BC%95%E6%93%8E%E5%8F%8ANext%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Hexo初始化博客框架windows/macHexo安装和搭建依赖Nodejs和Git,可自行下载，下面的命令都是在上述环境OK的情况下进行的 windows下，可以新建文件夹，然后右键运行git bash,运行各种命令。 git bash下运行如下命令： 1.安装Hexo 安装命令： npm install -g hexo-cli macos下要以管理员权限执行： sudo npm install -g hexo-cli 更新命令（hexo 3.4.3出现文章目录书签链接问题，更新3.4.4即可解决bug）： npm update hexo 如果提示文件夹写入权限不足，则： sudo npm update hexo 卸载： macos下要以管理员权限执行： sudo npm uninstall hexo-cli -g 如果卡死，则这样安装： npm install -g hexo-cli --no-optional macos下要以管理员权限执行： sudo npm install -g hexo-cli --no-optional 注意： 将Windows平台下的hexo文件直接全部拷贝到macOS下使用，可能会报下面这个错误： Cannot find module &apos;./build/Release/DTraceProviderBindings 此时只需要在另外一个文件键执行 hexo init npm install 然后将这个新文件夹中的node_modules文件夹复制并替换掉原来Windows平台下的node_modules文件夹即可。 然后又报错： ERROR Deployer not found: git 执行这个命令即可： sudo npm install hexo-deployer-git --save 20171207更 本人懒得再配置_config.yml以及主题相关配置文件，所以macOS下git,node.js,hexo-cli安装完后直接将Windows平台下的hexo整个文件夹复制到macOS下，执行时报模块找不到错误，虽然不影响正常执行结果的产生，但是看着不爽。经测试，替换node_modules可以解决报错问题。(2017-12-07) 20180825更： 安装Node.js v8.11.4后一并带的npm v5.6.0，此时直接执行sudo npm install -g hexo-cli后安装完成后并没有报任何错，直接执行hexo g -d也完全正常，下面是安装完成后的日志：（2018-08-25） This package has installed: • Node.js v8.11.4 to /usr/local/bin/node • npm v5.6.0 to /usr/local/bin/npm Make sure that /usr/local/bin is in your $PATH. sudo npm install -g hexo-cli [fsevents] Success: &quot;/usr/local/lib/node_modules/hexo-cli/node_modules/fsevents/lib/binding/Release/node-v57-darwin-x64/fse.node&quot; already installed Pass --update-binary to reinstall or --build-from-source to recompile + hexo-cli@1.1.0 2.初始化框架 $ hexo init &lt;yourFolder&gt; $ cd &lt;yourFolder&gt; $ npm install 初始化完成后的目录结构 ├── _config.yml //网站的 配置 信息，您可以在此配置大部分的参数。 ├── package.json ├── scaffolds //模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 ├── source //资源文件夹是存放用户资源的地方。 | ├── _drafts | └── _posts └── themes //主题 文件夹。Hexo 会根据主题来生成静态页面。 3.新建文章（默认在/source/_post里添加hello-world.md文件） $ hexo new &quot;Hello World&quot; 4.生成网站静态代码(将/source的.md文件生成到/public中，形成网站的静态文件) $ hexo generate 5.启动服务器 $ hexo server -p 3000 $hexo s --debug 可用于预览 6.部署网站 $ hexo deploy 7.配置你所要部署的站点 部署网站之前需要生成静态文件，即可以用$ hexo generate -d直接生成并部署。此时需要在根目录下的_config.yml中配置你所要部署的站点： ## Docs: http://hexo.io/docs/deployment.html deploy: type: git repo: git@github.com:Repos.git branch: master 注意:配置repo等的时候，要留两个空格，不然可能不起作用 hexo其它命令 创建目录 hexo new page &quot;about&quot; 创建文章 $ hexo new &quot;Hello World&quot; 使用Next主题1.获取next主题 $ cd your-hexo-site $ git clone https://github.com/iissnan/hexo-theme-next themes/next 2.启用next主题(修改根目录下的_config.yml中的theme属性) # Extensions ## Plugins: http://hexo.io/plugins/ ## Themes: http://hexo.io/themes/ theme: next 3.验证是否启用 $ hexo s --debug 4.关于Next主题更多参考Next官网 http://theme-next.iissnan.com/ 文章分类categories和tags设置1.创建分类文件夹下面两行命令会在source目录下创建名为categories和tags的文件夹 $ hexo new page &quot;categories&quot; $ hexo new page &quot;tags&quot; 2.配置文件开启 在themes\next\_config.yml搜索menu,将categories和tags前对应的#号注释去掉即可 3.md文件头标明分类 使用$ hexo new &quot;文件名&quot;创建文章后，打开对应的文件，在题头添加分类和标签，例如： --- title: 文章名 date: 2016-11-19 22:20:53 categories: &quot;分组名&quot; tags: 标签名 --- 文章侧栏开关themes\next\_config.yml下搜索sidebar，display改选为hide即可。 重装操作系统后，需要安装node js和Hexo重新安装操作系统后，操作以下两步即可再次使用原有hexo文件： 安装nodejs 下载node js for windows并安装 dos下输入node -v查看nodejs版本 安装hexo $ npm install -g hexo-cli 更改tags标签默认字体颜色找到hexo\themes\next\source\css\_custom\custom.styl 添加如下内容： // Custom styles. .tag-cloud-tags a { color: black !important; //font-weight: bold font-size: medium } 搜索功能暂时选择启用local search: 安装 $ npm install hexo-generator-searchdb --save 配置 根目录配置文件中添加 search: path: search.xml field: post format: html limit: 10000 开启 主题配置文件中搜索local search,将false改为true # Local search local_search: enable: true 修改导航栏高度 找到对用css配置文件并修改为3px(原来为25px 0 20px) themes\next\source\css\_schemes\Mist\)header.styl .header-inner padding:3px 0 3px 修改页面宽度 hexo下next主题修改页面宽度 Pisces Scheme 直接在thems/next/source/css/_variables/custom.styl文件中添加： $main-desktop = 1350px $content-desktop = 1100px 改进（20180106）： $main-desktop = 95% $content-desktop = calc(100% - 252px) https://github.com/iissnan/hexo-theme-next/issues/759#issuecomment-202242848 http://theme-next.iissnan.com/faqs.html 引入评论功能 更新next主题到v6 注册leancloud.cn https://leancloud.cn/dashboard/login.html#/signin 进入控制台后点击左下角创建应用复制appid和appkey到next主题配置文件_config.yml下对应位置 配置文件中开启 valine: enable: true appid: irtttvMVkwwwwwxYtsavbj0-gzGeeeesz # your leancloud application appid appkey: swsshwwwwgjANceeeeeKl # your leancloud application appkey notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: 嗨，欢迎你在这里留言~ # comment box placeholder avatar: wavatar # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size visitor: false 参考链接 https://valine.js.org/quickstart.htmlhttps://www.jianshu.com/p/6bc6a8977c36 去除powered by valine 文件位置 /hexo/themes/next-v6/layout/_third-party/comments/valine.swig 在new Valine方法下添加代码： new Valine({ ...... }); //去除powered by valine var infoEle = document.querySelector(&apos;#comments .info&apos;); if (infoEle &amp;&amp; infoEle.childNodes &amp;&amp; infoEle.childNodes.length &gt; 0){ infoEle.childNodes.forEach(function(item) { item.parentNode.removeChild(item); }); } 当有新评论时邮件通知博主 部署Valine-Admin添加邮件通知功能 https://github.com/zhaojun1998/Valine-Admin 配置如下： 新建文章时，在相同目录下创建同名文件夹（便于图片管理） 新建文章时，在相同目录下创建同名文件夹（便于图片管理） 打开站点配置文件_config.yml，搜索post_asset_folder字段，设置其值为true 安装hexo-asset-image：npm install hexo-asset-image --save 此时hexo new &quot;fileName&quot;会在/source/_posts目录下创建同名的文件夹 只需在 md 文件里使用 ![title](图片名.jpg) ，无需路径名就可以插入图片。 参考文章： https://blog.csdn.net/weixin_39345384/article/details/80785373]]></content>
      <tags>
        <tag>&lt;font</tag>
        <tag>size=1&gt;Hexo&lt;/font&gt;</tag>
      </tags>
  </entry>
</search>
