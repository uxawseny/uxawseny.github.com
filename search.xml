<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>EJB相关</title>
    <url>/2017/04/20/EJB%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h2 id="EJB的三种bean"><a href="#EJB的三种bean" class="headerlink" title="EJB的三种bean"></a>EJB的三种bean</h2><p><strong>1.会话bean(session bean)</strong></p>
<pre><code>负责与客户端交互，是编写业务逻辑的地方，在会话bean中科院通过jdbc直接操作数据库，
但是大多情况下都是通过实体bean来完成对数据库的操作。
</code></pre>
<p><strong>2.实体bean(entity bean)</strong></p>
<pre><code>它实际上属于java持久化规范(JPA)里的技术，JPA的出现主要是为了简化现有的持久化开发工作和整合ORM技术，
结束现在Hibernate、TopLink等ORM框架各自为营的局面。
</code></pre>
<p><strong>3.消息驱动bean(message-driven bean)</strong></p>
<pre><code>它是专门用于异步处理java消息的组建，具有处理大量病发消息的能力。
</code></pre>
<h2 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h2>]]></content>
      <tags>
        <tag>EJB</tag>
      </tags>
  </entry>
  <entry>
    <title>12306</title>
    <url>/2017/07/24/12306/</url>
    <content><![CDATA[<p>12306铺位选择代码</p>
<ul>
<li>12306铺位选择：<pre><code>  &lt;select name=&quot;passenger_1_seat_detail_select&quot; style=&quot;display: 
  block&quot; id=&quot;passenger_1_seat_detail_select&quot; onchange=&quot;setSeatDetail(&#39;1&#39;)&quot;&gt; 
        &lt;option value=&quot;0&quot;&gt;随机&lt;/option&gt; 
        &lt;option value=&quot;3&quot;&gt;上铺&lt;/option&gt; 
        &lt;option value=&quot;2&quot;&gt;中铺&lt;/option&gt; 
        &lt;option value=&quot;1&quot;&gt;下铺&lt;/option&gt;
   &lt;/select&gt;
</code></pre>
</li>
</ul>
<p><strong>注意：</strong> 点击edit as html 后，在对应的下敲回车留一行空格。</p>
<p>图示：</p>
<p>在图中红框圈住的地方，右键&gt;&gt;&gt;&gt;审查元素,出现图二内容</p>
<p><img src="/2017/07/24/12306/12306_1.png" alt="12306"></p>
<p>右键箭头指向的地方&gt;&gt;&gt;edit as html</p>
<p><img src="/2017/07/24/12306/12306_2.png" alt="12306"></p>
<p>在出现的代码最下方，敲一下回车(留一行空格)，<br>复制下面的代码：</p>
<pre><code>&lt;select name=&quot;passenger_1_seat_detail_select&quot; style=&quot;display: 
block&quot; id=&quot;passenger_1_seat_detail_select&quot; onchange=&quot;setSeatDetail(&#39;1&#39;)&quot;&gt; 
      &lt;option value=&quot;0&quot;&gt;随机&lt;/option&gt; 
      &lt;option value=&quot;3&quot;&gt;上铺&lt;/option&gt; 
      &lt;option value=&quot;2&quot;&gt;中铺&lt;/option&gt; 
      &lt;option value=&quot;1&quot;&gt;下铺&lt;/option&gt;&lt;/select&gt;
</code></pre>
<p>然后就可以继续订票了。</p>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>12306</tag>
      </tags>
  </entry>
  <entry>
    <title>Eclipse</title>
    <url>/2017/05/23/Eclipse/</url>
    <content><![CDATA[<h2 id="Eclipse快捷键"><a href="#Eclipse快捷键" class="headerlink" title="Eclipse快捷键"></a>Eclipse快捷键</h2><ul>
<li><p>常用快捷键</p>
<pre><code>  Ctrl+1 快速修复(最经典的快捷键,就不用多说了)  
  Ctrl+D: 删除当前行   
  Ctrl+Alt+↓ 复制当前行到下一行(复制增加)  
  Ctrl+Alt+↑ 复制当前行到上一行(复制增加)  
  Alt+↓ 当前行和下面一行交互位置(特别实用,可以省去先剪切,再粘贴了)  
  Alt+↑ 当前行和上面一行交互位置(同上)  
  Alt+← 前一个编辑的页面  
  Alt+→ 下一个编辑的页面(当然是针对上面那条来说了)  
  Alt+Enter 显示当前选择资源(工程,or 文件)的属性  
  Shift+Enter 在当前行的下一行插入空行(这时鼠标可以在当前行的任一位置,不一定是最后)  
  Shift+Ctrl+Enter 在当前行插入空行(原理同上条)  
  Ctrl+Q 定位到最后编辑的地方  
  Ctrl+L 定位在某行(按下快捷键提示输入行数)  
  Ctrl+M 最大化当前的Edit或View (再按则反之)  
  Ctrl+/ 注释当前行,再按则取消注释  
  Ctrl+O 快速显示 OutLine  
  Ctrl+T 快速显示当前类的继承结构  
  Ctrl+W 关闭当前Editer  
  Ctrl+K 参照选中的Word快速定位到下一个  
  Ctrl+E 快速显示当前Editer的下拉列表(如果当前页面没有显示的用黑体表示)  
  Ctrl+/(小键盘) 折叠当前类中的所有代码  
  Ctrl+×(小键盘) 展开当前类中的所有代码  
  Ctrl+Space 代码助手完成一些代码的插入(但一般和输入法有冲突,可以修改输入法的热键,也可以暂用Alt+/来代替)  
  Ctrl+Shift+E 显示管理当前打开的所有的View的管理器(可以选择关闭,激活等操作)  
  Ctrl+J 正向增量查找(按下Ctrl+J后,你所输入的每个字母编辑器都提供快速匹配定位到某个单词,如果没有,则在stutes line中显示没有找到了,查一个单词时,特别实用,这个功能Idea两年前就有了)  
  Ctrl+Shift+J 反向增量查找(和上条相同,只不过是从后往前查)  
  Ctrl+Shift+F4 关闭所有打开的Editer  
  Ctrl+Shift+X 把当前选中的文本全部变味小写  
  Ctrl+Shift+Y 把当前选中的文本全部变为小写  
  Ctrl+Shift+F 格式化当前代码  
  Ctrl+Shift+P 定位(跳转)到对应的匹配符(譬如&#123;&#125;) (从前面定位后面时,光标要在匹配符里面,后面到前面,则反之) 

  Ctrl+shift+上/下：在各个方法间跳
  Ctrl+shift+左/右：从光标所在位置开始选择内容
</code></pre>
</li>
<li><p>Eclipse中重构常用快捷键</p>
<pre><code>  (注:一般重构的快捷键都是Alt+Shift开头的了)  
  Alt+Shift+R 重命名 (是我自己最爱用的一个了,尤其是变量和类的Rename,比手工方法能节省很多劳动力)  
  Alt+Shift+M 抽取方法 (这是重构里面最常用的方法之一了,尤其是对一大堆泥团代码有用)  
  Alt+Shift+C 修改函数结构(比较实用,有N个函数调用了这个方法,修改一次搞定)  
  Alt+Shift+L 抽取本地变量( 可以直接把一些魔法数字和字符串抽取成一个变量,尤其是多处调用的时候)  
  Alt+Shift+F 把Class中的local变量变为field变量 (比较实用的功能)  
  Alt+Shift+I 合并变量(可能这样说有点不妥Inline)  
  Alt+Shift+V 移动函数和变量(不怎么常用)  
  Alt+Shift+Z 重构的后悔药(Undo)  
</code></pre>
</li>
</ul>
<h2 id="让eclipse与Myeclipse统一"><a href="#让eclipse与Myeclipse统一" class="headerlink" title="让eclipse与Myeclipse统一"></a>让eclipse与Myeclipse统一</h2><ul>
<li><p>重建clipse工程时做以下改变可让工程同时运行在MyEclipse和Eclipse下</p>
<pre><code>  build\classes改为：WebRoot\WEB-INF\classes
  WebContent改为：WebRoot
</code></pre>
</li>
</ul>
]]></content>
      <tags>
        <tag>Eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title>EL表达式</title>
    <url>/2017/12/05/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="EL表达式概念"><a href="#EL表达式概念" class="headerlink" title="EL表达式概念"></a>EL表达式概念</h2><ul>
<li>EL表达式概念  JSTL一般要配合EL表达式一起使用,来实现在jsp中不出现java代码段。所以我们先来学习EL表达式<br>  EL（Expression Language）表达式语言：用于计算和输出存储在标志位置（page、request、session、application）的java对象的值,然后对它们执行简单操作；EL是JSP2.0规范的一部分，只要容器支持Servlet2.4/JSP2.0，就可以在JSP2.0网页中直接使用EL。通常与 JSTL 标记一起作用，能用简单而又方便的符号来表示复杂的行为。</li>
</ul>
<h2 id="EL表达式使用"><a href="#EL表达式使用" class="headerlink" title="EL表达式使用"></a>EL表达式使用</h2><ul>
<li><p>开启和关闭EL表达式</p>
<ul>
<li><p>开启</p>
<p>  在servlet2.4之后默认方法为false，即可以不写或写成</p>
<pre><code>  &lt;%@ page isELIgnored=&quot;false&quot; %&gt;
  
</code></pre>
</li>
<li><p>关闭</p>
<pre><code>  &lt;%@ page isELIgnored=&quot;true&quot; %&gt;
  
</code></pre>
</li>
<li><p>还有一种批量禁用EL的方法，可以在WEB-INF/web.xml中使用jsp-property-group标签批量禁用el，web.xml中进行如下配置</p>
<pre><code>  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
  &lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd&quot;
      version=&quot;2.4&quot;&gt;
      &lt;jsp-config&gt;
          &lt;jsp-property-group&gt;
              &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;
              &lt;el-ignored&gt;true&lt;/el-ignored&gt;
          &lt;/jsp-property-group&gt;
      &lt;/jsp-config&gt;
  &lt;/web-app&gt;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>EL基本格式</strong></p>
<pre><code>  EL表达式的格式：用美元符号（$）定界,内容包括在花括号（&#123;&#125;）中;
  $&#123;&#125; 用法：这是一个EL表达式取值的方法.
  
  例如: 
  点号记法：$&#123;BeanName.beanProperty&#125;
  数组记法：$&#123;BeanName[“beanProperty”]&#125;
  
  此外，您可以将多个表达式与静态文本组合在一起以通过字符串并置来构造动态属性值;
  例如:
  Hello &#123;loginInfoBean.suser&#125; $&#123;loginInfoBean.spwd&#125;
      
</code></pre>
</li>
<li><p><strong>EL作用域的默认顺序</strong></p>
<pre><code>  使用EL的时候，默认会以一定顺序（page、request、session、application）搜索四个作用域，将最先找到的变量值显示出来
  
  名称             作用域
  page            在当前页面有效
  request         在当前请求中有效
  session         在当前会话中有效
  application     在所有应用程序中有效
</code></pre>
<blockquote>
<p><a href="http://blog.csdn.net/zycgod/article/details/44408459">http://blog.csdn.net/zycgod/article/details/44408459</a></p>
</blockquote>
</li>
<li><p>EL存取器</p>
<pre><code>  存取器用来检索对象的特性或集合的元素。存取器: 通过 “[]” 或 “.” 符号获取相关数据
  例:
  //获取输出bean中的suser属性值;
  $&#123;userBean.suser&#125;  或  $&#123;userBean[“suser”]&#125;
  //获取map中key为id对应的值;
  $&#123;mcType[“id”]&#125; 
      
</code></pre>
</li>
<li><p>EL运算符 和 EL隐藏对象</p>
<p>  参考本文末尾处的链接</p>
</li>
<li><p>参考链接：</p>
<blockquote>
<p><a href="http://blog.csdn.net/u010168160/article/details/49182867">http://blog.csdn.net/u010168160/article/details/49182867</a></p>
</blockquote>
</li>
</ul>
]]></content>
      <tags>
        <tag>EL表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>Git操作相关</title>
    <url>/2016/10/19/Git%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h2 id="加入git版本控制"><a href="#加入git版本控制" class="headerlink" title="加入git版本控制"></a>加入git版本控制</h2><ul>
<li><p>基本命令</p>
<pre><code>  1.创建项目
  2.git init
  3.git add [需要加入版本控制的文件]
  4.git commit -m&quot;提交信息&quot;
  5.关联远程仓库
      git remote add origin https://git.coding.net/uxaw/surveyDemo.git
  6. 首次推动并关联远分枝
      git push -u origin master
   
      拉取或者推送时如果提示分支找不到，需要到远程仓库合并一下分支.
      我们第一次推送master分支时，加上了 –u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来
  
  7.拉取远程仓库：$ git pull [remoteName] [localBranchName]
      $ git pull （可省略origin master）
  
  8. 以后推送
      git push origin master 
      
  9.切换分支
  
      git checkout -b mytagname tagname 
      
      tagname：分支名称  
      mytagname：存到本地的重命名，建议和原分支名称一致   
  
  *.推送远程仓库：$ git push [remoteName] [localBranchName]
      $ git push origin master:matser
      
      参考链接：http://blog.csdn.net/free_wind22/article/details/50967723
      
  10.更改远程仓库链接：

      如：修改远程仓库项目名将导致项目的访问 URL（包含 Git 仓库的 URL）将会改变，在此之前的 URL 地址将失效。
      
      Git仓库地址修改命令：
       git remote set-url origin [NEW_URL]
</code></pre>
</li>
</ul>
<h2 id="忽略已跟踪文件"><a href="#忽略已跟踪文件" class="headerlink" title="忽略已跟踪文件"></a>忽略已跟踪文件</h2><ul>
<li><p><strong>还没有加到版本控制中</strong></p>
<pre><code>  (1)还没有Git add
       在 .gitignore中添加
  (2)已经git add
       先git rm -r --cached 文件
       在.gitignore中添加
</code></pre>
</li>
<li><p><strong>已经加到版本控制中</strong></p>
<pre><code>   先git rm -r --cached 文件名  
   再在.gitignore中添加
   最后gti commit -m提交.gitignore&#39;

   git bash下创建gitignore的命令：
   touch .gitignore
</code></pre>
</li>
</ul>
<hr>
<h2 id="Git相关命令"><a href="#Git相关命令" class="headerlink" title="Git相关命令"></a>Git相关命令</h2><ul>
<li><p><strong>查看状态</strong>：</p>
<pre><code>  git status
</code></pre>
</li>
<li><p><strong>远程仓库版本覆盖本地版本：</strong></p>
<pre><code>  $ git fetch –all      //与远程同步
  $ git reset --hard origin/master      //将本地的状态回退到和远程的一样 
  git fetch 只是下载远程的库的内容，不做任何的合并git reset 把HEAD指向刚刚下载的最新的版本
</code></pre>
</li>
<li><p><strong>查看所关联的远程仓库</strong></p>
<pre><code>  $ git remote -v
</code></pre>
</li>
<li><p><strong>创建.gitignore文件</strong></p>
<pre><code>  git bash下创建gitignore的命令：
  touch .gitignore
</code></pre>
</li>
<li><p>设置账户</p>
<pre><code>  设置用户名和邮箱：
  git config --global user.name &quot;ux&quot;
  git config --global user.email &quot;ux@gmail.com&quot;

  查看用户名和邮箱
  $ git config user.name
  $ git config user.email
</code></pre>
</li>
</ul>
<h2 id="Git里程碑"><a href="#Git里程碑" class="headerlink" title="Git里程碑"></a>Git里程碑</h2><ul>
<li><p>创建添加里程碑</p>
<pre><code>  创建本地里程碑：
  git tag v1.0
  删除本地里程碑：
  git tag -d v1.0
  共享推送里程碑到远成仓库：
  git push origin v1.0
  删除远程仓库里程碑：
  git push origin :v1.0
</code></pre>
</li>
</ul>
<h2 id="Git第三方客户端SourceTree"><a href="#Git第三方客户端SourceTree" class="headerlink" title="Git第三方客户端SourceTree"></a>Git第三方客户端SourceTree</h2><ul>
<li><p>sourcetree</p>
<pre><code>  git第三方桌面客户端：
  Source Tree
  https://www.sourcetreeapp.com/
</code></pre>
</li>
<li><p>安装sourceTree时跳过账户登录</p>
<pre><code>  C:\Users\UX\AppData\Local\Atlassian\SourceTree下新建(或者替换)accounts.json
  （UX是我的计算机用户名,找到自己的对应即可,我的版本是2.0.19.1）
</code></pre>
</li>
<li><p>accounts.json内容如下：</p>
<pre><code>  [
    &#123;
      &quot;$id&quot;: &quot;1&quot;,
      &quot;$type&quot;: &quot;SourceTree.Api.Host.Identity.Model.IdentityAccount, SourceTree.Api.Host.Identity&quot;,
      &quot;IsDefault&quot;: false,
      &quot;Authenticate&quot;: true,
      &quot;HostInstance&quot;: &#123;
        &quot;$id&quot;: &quot;2&quot;,
        &quot;$type&quot;: &quot;SourceTree.Host.Atlassianaccount.AtlassianAccountInstance, SourceTree.Host.AtlassianAccount&quot;,
        &quot;Host&quot;: &#123;
          &quot;$id&quot;: &quot;3&quot;,
          &quot;$type&quot;: &quot;SourceTree.Host.Atlassianaccount.AtlassianAccountHost, SourceTree.Host.AtlassianAccount&quot;,
          &quot;Id&quot;: &quot;atlassian account&quot;
        &#125;,
        &quot;BaseUrl&quot;: &quot;https://id.atlassian.com/&quot;
      &#125;,
      &quot;Credentials&quot;: &#123;
        &quot;$id&quot;: &quot;4&quot;,
        &quot;$type&quot;: &quot;SourceTree.Model.BasicAuthCredentials, SourceTree.Api.Account&quot;,
        &quot;Username&quot;: &quot; &quot;,
        &quot;Email&quot;: null,
        &quot;AvatarURL&quot;: null,
        &quot;AuthenticationScheme&quot;: &#123;
          &quot;$type&quot;: &quot;SourceTree.Model.BasicAuthAuthenticationScheme, SourceTree.Api.Account&quot;,
          &quot;Value&quot;: &quot;Username/Password&quot;,
          &quot;Name&quot;: &quot;Basic&quot;,
          &quot;Description&quot;: &quot;Password&quot;,
          &quot;HeaderValuePrefix&quot;: &quot;Basic&quot;,
          &quot;UsernameIsRequired&quot;: true
        &#125;,
        &quot;Id&quot;: &quot; &quot;,
        &quot;DisplayName&quot;: null
      &#125;
    &#125;
  ]
</code></pre>
</li>
<li><p><strong>或者到此链接复制：</strong></p>
<blockquote>
<p><a href="http://op05inpyd.bkt.clouddn.com/accounts.json">http://op05inpyd.bkt.clouddn.com/accounts.json</a></p>
</blockquote>
</li>
</ul>
<h2 id="多git服务使用配置-ssh-key"><a href="#多git服务使用配置-ssh-key" class="headerlink" title="多git服务使用配置(ssh key)"></a>多git服务使用配置(ssh key)</h2><h3 id="Mac下配置多个Git账户-ssh-key方式"><a href="#Mac下配置多个Git账户-ssh-key方式" class="headerlink" title="Mac下配置多个Git账户(ssh key方式)"></a>Mac下配置多个Git账户(ssh key方式)</h3><h4 id="查看用户名和邮箱"><a href="#查看用户名和邮箱" class="headerlink" title="查看用户名和邮箱"></a>查看用户名和邮箱</h4><pre><code>　　git config user.name
　　git config user.email
</code></pre>
<p>　　</p>
<h4 id="1-如果之前已经使用该命令进行配置，则先使用如下命令清除"><a href="#1-如果之前已经使用该命令进行配置，则先使用如下命令清除" class="headerlink" title="1.如果之前已经使用该命令进行配置，则先使用如下命令清除"></a>1.如果之前已经使用该命令进行配置，则先使用如下命令清除</h4><pre><code>    git config --global --unset user.name
    git config --global --unset user.email    
</code></pre>
<h4 id="2-设置全局账户"><a href="#2-设置全局账户" class="headerlink" title="2.设置全局账户"></a>2.设置全局账户</h4><pre><code>    git config --global user.name &quot;ux&quot;
    git config --global user.email &quot;ux@gmail.com&quot;
    
</code></pre>
<h4 id="3-对每个账户生成一对密钥"><a href="#3-对每个账户生成一对密钥" class="headerlink" title="3.对每个账户生成一对密钥"></a>3.对每个账户生成一对密钥</h4><pre><code>    1.首先进入保存秘钥的目录(mac下路径如下)
    cd ~/.ssh
    
    2.然后，根据账户邮箱生成秘钥。例如我在GitHub上的邮箱是ux@gmail.com，则命令为：
    ssh-keygen -t rsa -C &quot;ux@gmail.com&quot;
    
    3.输入完成后，会有如下提示
    
    Generatingpublic/privatersa key pair.Enter fileinwhich to save the key (/Users/liugui/.ssh/id_rsa):
    
    这里要求对秘钥进行命名，默认的文件名是id_rsa。为了方便区分，我这里命名为id_rsa_github
    
    接下来的提示都直接进行回车，直到秘钥生成。通过ls命令，可以看到刚刚生成的密钥对id_rsa_github和id_rsa_github.pub。
    其中id_rsa_github.pub是公钥
</code></pre>
<h4 id="4-私钥添加到本地"><a href="#4-私钥添加到本地" class="headerlink" title="4.私钥添加到本地"></a>4.私钥添加到本地</h4><pre><code>    ssh-add ~/.ssh/id_rsa_github // 将GitHub私钥添加到本地
    
</code></pre>
<h4 id="5-对本地秘钥进行配置"><a href="#5-对本地秘钥进行配置" class="headerlink" title="5.对本地秘钥进行配置"></a>5.对本地秘钥进行配置</h4><pre><code>由于添加了多个密钥文件，所以需要对这多个密钥进行管理。在.ssh目录下新建一个config文件：

touch config

config配置内容如下：

    #############github###############
    #网站的别名，随意取
    Host github.com
    #托管网站的域名
    HostName github.com 
    #托管网站上的用户名
    User uxawseny 
    #使用的密钥文件
    IdentityFile ~/.ssh/is_rsa_github 
    
    ##############公司git################
    
    #网站的别名，随意取
    Host git.cp.com
    #托管网站的域名
    HostName git.cp.com
    #托管网站上的用户名
    User myname 
    #使用的密钥文件
    IdentityFile ~/.ssh/id_rsa_cp
    
    这里的host name最好和git服务器的SSH下载方式上的
    git@github.com:uxawseny/test.git  
    @符号后面的一直，这样每次clone时就默认不用手动更改了，
    比如github的ssh key的host name，就命名为github.com
        
</code></pre>
<h4 id="6-公钥添加到托管网站"><a href="#6-公钥添加到托管网站" class="headerlink" title="6.公钥添加到托管网站"></a>6.公钥添加到托管网站</h4><pre><code>    将公钥id_rsa_github.pub中的内容复制到github
    
</code></pre>
<h4 id="7-测试是否成功"><a href="#7-测试是否成功" class="headerlink" title="7.测试是否成功"></a>7.测试是否成功</h4><pre><code>这时候，可以测试一下配置是否成功，测试命令使用别名。例如，对于GitHub，本来应该使用的测试命令是：

    ssh -T git@github.com
    
</code></pre>
<h4 id="8-选择SSH协议的复制命令，如对于GitLab上代码库test，其复制命令为"><a href="#8-选择SSH协议的复制命令，如对于GitLab上代码库test，其复制命令为" class="headerlink" title="8.选择SSH协议的复制命令，如对于GitLab上代码库test，其复制命令为"></a>8.选择SSH协议的复制命令，如对于GitLab上代码库test，其复制命令为</h4><pre><code>    git clone git@github.com:ux/test.git
    
</code></pre>
<h4 id="9-添加其他git账户依次操作即可"><a href="#9-添加其他git账户依次操作即可" class="headerlink" title="9.添加其他git账户依次操作即可"></a>9.添加其他git账户依次操作即可</h4><h4 id="10-做完这些后几个清除全局用户名和邮箱，否则不同仓库提交时的用户名和邮箱信息都是一样的。"><a href="#10-做完这些后几个清除全局用户名和邮箱，否则不同仓库提交时的用户名和邮箱信息都是一样的。" class="headerlink" title="10.做完这些后几个清除全局用户名和邮箱，否则不同仓库提交时的用户名和邮箱信息都是一样的。"></a>10.做完这些后几个清除全局用户名和邮箱，否则不同仓库提交时的用户名和邮箱信息都是一样的。</h4><pre><code>    git config --global --unset user.name
    git config --global --unset user.email
    
    用上述命令清除掉全局用户名和邮箱信息后，再在每个项目中设置用户名和邮箱信息（不使用全局参数）
    git config --unset user.name
    git config--unset user.email
    
    或者在IDEA中提交时再填写用户名和邮箱，但是要记得取消勾选&quot;作为全局设置&quot;
</code></pre>
<ul>
<li>参考文章</li>
</ul>
<blockquote>
<p><a href="https://www.jianshu.com/p/6507ce357ad2">https://www.jianshu.com/p/6507ce357ad2</a></p>
</blockquote>
<h2 id="github项目fork之后实时同步原项目的更新"><a href="#github项目fork之后实时同步原项目的更新" class="headerlink" title="github项目fork之后实时同步原项目的更新"></a>github项目fork之后实时同步原项目的更新</h2><h3 id="1-将fork到的项目git-clone拉取到本地"><a href="#1-将fork到的项目git-clone拉取到本地" class="headerlink" title="1.将fork到的项目git clone拉取到本地"></a>1.将fork到的项目git clone拉取到本地</h3><h3 id="2-进到拉取的project目录下，然后增加远程分支-fork的原始项目地址-，名为-update-new（名字任意）到本地"><a href="#2-进到拉取的project目录下，然后增加远程分支-fork的原始项目地址-，名为-update-new（名字任意）到本地" class="headerlink" title="2.进到拉取的project目录下，然后增加远程分支(fork的原始项目地址)，名为 update_new（名字任意）到本地"></a>2.进到拉取的project目录下，然后增加远程分支(fork的原始项目地址)，名为 update_new（名字任意）到本地</h3><pre><code>git remote add update_new https://github.com/_original/_project.git
    
</code></pre>
<h3 id="3-查看分支时候添加成功（会发现多了刚才添加的远程分支）"><a href="#3-查看分支时候添加成功（会发现多了刚才添加的远程分支）" class="headerlink" title="3.查看分支时候添加成功（会发现多了刚才添加的远程分支）"></a>3.查看分支时候添加成功（会发现多了刚才添加的远程分支）</h3><pre><code>git remote -v
   
</code></pre>
<h3 id="4-然后把远程原始分支-update-new-的代码拉到本地"><a href="#4-然后把远程原始分支-update-new-的代码拉到本地" class="headerlink" title="4.然后把远程原始分支 update_new 的代码拉到本地"></a>4.然后把远程原始分支 update_new 的代码拉到本地</h3><pre><code>git fetch update_new
 
</code></pre>
<h3 id="5-合并对方远程原始分支-update-new-的代码"><a href="#5-合并对方远程原始分支-update-new-的代码" class="headerlink" title="5.合并对方远程原始分支 update_new 的代码"></a>5.合并对方远程原始分支 update_new 的代码</h3><pre><code>git merge update_new/master    
</code></pre>
<h3 id="6-最后把最新的代码推送到你的github上"><a href="#6-最后把最新的代码推送到你的github上" class="headerlink" title="6.最后把最新的代码推送到你的github上"></a>6.最后把最新的代码推送到你的github上</h3><pre><code>git push origin master
</code></pre>
<ul>
<li><p>参考文章</p>
<blockquote>
<p><a href="https://www.cnblogs.com/relucent/p/6479213.html">https://www.cnblogs.com/relucent/p/6479213.html</a> </p>
</blockquote>
</li>
</ul>
<h3 id="修改远程仓库地址"><a href="#修改远程仓库地址" class="headerlink" title="修改远程仓库地址"></a>修改远程仓库地址</h3><ul>
<li><p>1、直接修改远程仓库地址【推荐】</p>
<pre><code>  git remote set-url origin url
  
  修改完后，如果是master分支，第一次推送，可以直接：git push -u origin master
  其他分支，在主分支推送后，修改完地址后，可以直接push
</code></pre>
</li>
<li><p>2、删除本地远程仓库地址，然后添加新的仓库地址</p>
<pre><code>  git remote rm origin
  git remote add origin url
</code></pre>
</li>
<li><p>3、修改配置文件</p>
<pre><code>  每个仓库在初始化时，都会有一个 .git 的隐藏目录，修改其中的 config 文件中的 url


 
</code></pre>
</li>
</ul>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo引擎及Next主题</title>
    <url>/2016/04/19/Hexo%E5%BC%95%E6%93%8E%E5%8F%8ANext%E4%B8%BB%E9%A2%98/</url>
    <content><![CDATA[<h2 id="Hexo初始化博客框架windows-mac"><a href="#Hexo初始化博客框架windows-mac" class="headerlink" title="Hexo初始化博客框架windows/mac"></a>Hexo初始化博客框架windows/mac</h2><p><strong>Hexo安装和搭建依赖Nodejs和Git,可自行下载，下面的命令都是在上述环境OK的情况下进行的</strong></p>
<p><strong>windows下，可以新建文件夹，然后右键运行git bash,运行各种命令。</strong></p>
<p>git bash下运行如下命令：</p>
<p>1.安装Hexo</p>
<pre><code>安装命令：
npm install -g hexo-cli

macos下要以管理员权限执行：
sudo npm install -g hexo-cli

更新命令（hexo 3.4.3出现文章目录书签链接问题，更新3.4.4即可解决bug）：
npm update hexo
如果提示文件夹写入权限不足，则：
sudo npm update hexo

卸载：
macos下要以管理员权限执行：
sudo npm uninstall hexo-cli -g
    
如果卡死，则这样安装：
npm install -g hexo-cli --no-optional
 
macos下要以管理员权限执行：
sudo npm install -g hexo-cli --no-optional
</code></pre>
<p> <strong>注意：</strong></p>
<pre><code>将Windows平台下的hexo文件直接全部拷贝到macOS下使用，可能会报下面这个错误：
Cannot find module &#39;./build/Release/DTraceProviderBindings

此时只需要在另外一个文件键执行
hexo init 
npm install
然后将这个新文件夹中的node_modules文件夹复制并替换掉原来Windows平台下的node_modules文件夹即可。

然后又报错：
ERROR Deployer not found: git
执行这个命令即可：
sudo npm install hexo-deployer-git --save
</code></pre>
<ul>
<li><p>20171207更</p>
<p>  本人懒得再配置_config.yml以及主题相关配置文件，所以macOS下git,node.js,hexo-cli安装完后直接将Windows平台下的hexo整个文件夹复制到macOS下，执行时报模块找不到错误，虽然不影响正常执行结果的产生，但是看着不爽。经测试，替换node_modules可以解决报错问题。(2017-12-07)</p>
</li>
<li><p>20180825更：</p>
<p>  安装Node.js v8.11.4后一并带的npm v5.6.0，此时直接执行sudo npm install -g hexo-cli后安装完成后并没有报任何错，直接执行hexo g -d也完全正常，下面是安装完成后的日志：（2018-08-25）</p>
<pre><code>  This package has installed:
      •    Node.js v8.11.4 to /usr/local/bin/node
      •    npm v5.6.0 to /usr/local/bin/npm
  Make sure that /usr/local/bin is in your $PATH.

   sudo npm install -g hexo-cli
  [fsevents] Success: &quot;/usr/local/lib/node_modules/hexo-cli/node_modules/fsevents/lib/binding/Release/node-v57-darwin-x64/fse.node&quot; already installed
  Pass --update-binary to reinstall or --build-from-source to recompile
  + hexo-cli@1.1.0
</code></pre>
</li>
</ul>
<p>2.初始化框架</p>
<pre><code>$ hexo init &lt;yourFolder&gt;
$ cd &lt;yourFolder&gt;
$ npm install
</code></pre>
<p>初始化完成后的目录结构</p>
<pre><code>├── _config.yml //网站的 配置 信息，您可以在此配置大部分的参数。
├── package.json
├── scaffolds     //模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。
├── source     //资源文件夹是存放用户资源的地方。
|   ├── _drafts
|   └── _posts
└── themes     //主题 文件夹。Hexo 会根据主题来生成静态页面。
</code></pre>
<p>3.新建文章（默认在/source/_post里添加hello-world.md文件）</p>
<pre><code>$ hexo new &quot;Hello World&quot;
</code></pre>
<p>4.生成网站静态代码(将/source的.md文件生成到/public中，形成网站的静态文件)</p>
<pre><code>$ hexo generate
</code></pre>
<p>5.启动服务器</p>
<pre><code>$ hexo server -p 3000

$hexo s --debug   可用于预览
</code></pre>
<p>6.部署网站</p>
<pre><code>$ hexo deploy
</code></pre>
<p><strong>7.配置你所要部署的站点</strong></p>
<p>部署网站之前需要生成静态文件，即可以用$ hexo generate -d直接生成并部署。此时需要在根目录下的_config.yml中配置你所要部署的站点：</p>
<pre><code>## Docs: http://hexo.io/docs/deployment.html
 deploy:
   type:  git
   repo:  git@github.com:Repos.git
   branch:  master
</code></pre>
<p><strong>注意:配置repo等的时候，要留两个空格，不然可能不起作用</strong></p>
<p><strong>hexo其它命令</strong></p>
<pre><code>创建目录
hexo new page &quot;about&quot;

创建文章
$ hexo new &quot;Hello World&quot;
</code></pre>
<h2 id="使用Next主题"><a href="#使用Next主题" class="headerlink" title="使用Next主题"></a>使用Next主题</h2><p>1.获取next主题</p>
<pre><code>$ cd your-hexo-site
$ git clone https://github.com/iissnan/hexo-theme-next themes/next
</code></pre>
<p>2.启用next主题(修改根目录下的_config.yml中的theme属性)</p>
<pre><code># Extensions
## Plugins: http://hexo.io/plugins/
## Themes: http://hexo.io/themes/
theme: next
</code></pre>
<p>3.验证是否启用</p>
<pre><code>$ hexo s --debug
</code></pre>
<p>4.关于Next主题更多参考Next官网</p>
<pre><code>http://theme-next.iissnan.com/
</code></pre>
<h2 id="文章分类categories和tags设置"><a href="#文章分类categories和tags设置" class="headerlink" title="文章分类categories和tags设置"></a>文章分类categories和tags设置</h2><p><strong>1.创建分类文件夹</strong><br>下面两行命令会在source目录下创建名为categories和tags的文件夹</p>
<pre><code>$ hexo new page &quot;categories&quot;
$ hexo new page &quot;tags&quot;
</code></pre>
<p><strong>2.配置文件开启</strong></p>
<pre><code>在themes\next\_config.yml搜索menu,将categories和tags前对应的#号注释去掉即可
</code></pre>
<p><strong>3.md文件头标明分类</strong></p>
<pre><code>使用$ hexo new &quot;文件名&quot;创建文章后，打开对应的文件，在题头添加分类和标签，例如：
---
title: 文章名
date: 2016-11-19 22:20:53
categories: &quot;分组名&quot;
tags: 标签名

---
</code></pre>
<h2 id="文章侧栏开关"><a href="#文章侧栏开关" class="headerlink" title="文章侧栏开关"></a>文章侧栏开关</h2><pre><code>themes\next\_config.yml下搜索sidebar，display改选为hide即可。
</code></pre>
<h2 id="重装操作系统后，需要安装node-js和Hexo"><a href="#重装操作系统后，需要安装node-js和Hexo" class="headerlink" title="重装操作系统后，需要安装node js和Hexo"></a>重装操作系统后，需要安装node js和Hexo</h2><p>重新安装操作系统后，操作以下两步即可再次使用原有hexo文件：</p>
<ol>
<li><p>安装nodejs</p>
<p> 下载node js for windows并安装<br> dos下输入node -v查看nodejs版本</p>
</li>
<li><p>安装hexo</p>
<p> $ npm install -g hexo-cli</p>
</li>
</ol>
<h2 id="更改tags标签默认字体颜色"><a href="#更改tags标签默认字体颜色" class="headerlink" title="更改tags标签默认字体颜色"></a>更改tags标签默认字体颜色</h2><pre><code>找到hexo\themes\next\source\css\_custom\custom.styl
添加如下内容：

// Custom styles.
.tag-cloud-tags a &#123;
    color: black !important;
    //font-weight: bold
    font-size: medium
&#125;
</code></pre>
<h2 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h2><p><strong>暂时选择启用local search:</strong></p>
<ul>
<li><p>安装 </p>
<pre><code>  $ npm install hexo-generator-searchdb --save
</code></pre>
</li>
<li><p>配置</p>
<p>  根目录配置文件中添加</p>
<pre><code>  search:
    path: search.xml
    field: post
    format: html
    limit: 10000
</code></pre>
</li>
<li><p>开启</p>
<p>  主题配置文件中搜索local search,将false改为true</p>
<pre><code>  # Local search
  local_search:
      enable: true
</code></pre>
</li>
</ul>
<h2 id="修改导航栏高度"><a href="#修改导航栏高度" class="headerlink" title="修改导航栏高度"></a>修改导航栏高度</h2><ul>
<li><p>找到对用css配置文件并修改为3px(原来为25px 0 20px)</p>
<pre><code>  themes\next\source\css\_schemes\Mist\)header.styl
  .header-inner
  padding:3px 0 3px
</code></pre>
</li>
</ul>
<h2 id="修改页面宽度"><a href="#修改页面宽度" class="headerlink" title="修改页面宽度"></a>修改页面宽度</h2><ul>
<li><p>hexo下next主题修改页面宽度</p>
<p>  Pisces Scheme 直接在thems/next/source/css/_variables/custom.styl文件中添加：</p>
<pre><code>  $main-desktop                   = 1350px
  $content-desktop                = 1100px
  
</code></pre>
<p>  改进（20180106）：</p>
<pre><code>  $main-desktop                   = 95%
  $content-desktop                = calc(100% - 252px)
  
</code></pre>
<blockquote>
<p><a href="https://github.com/iissnan/hexo-theme-next/issues/759#issuecomment-202242848">https://github.com/iissnan/hexo-theme-next/issues/759#issuecomment-202242848</a></p>
</blockquote>
<blockquote>
<p><a href="http://theme-next.iissnan.com/faqs.html">http://theme-next.iissnan.com/faqs.html</a></p>
</blockquote>
</li>
</ul>
<h2 id="引入评论功能"><a href="#引入评论功能" class="headerlink" title="引入评论功能"></a>引入评论功能</h2><ul>
<li><p>更新next主题到v6</p>
</li>
<li><p>注册leancloud.cn</p>
<blockquote>
<p><a href="https://leancloud.cn/dashboard/login.html#/signin">https://leancloud.cn/dashboard/login.html#/signin</a></p>
</blockquote>
<p>  进入控制台后点击左下角创建应用复制appid和appkey到next主题配置文件_config.yml下对应位置</p>
</li>
<li><p>配置文件中开启</p>
<pre><code>  valine:
    enable: true
    appid:  irtttvMVkwwwwwxYtsavbj0-gzGeeeesz # your leancloud application appid
    appkey:  swsshwwwwgjANceeeeeKl # your leancloud application appkey
    notify: false # mail notifier , https://github.com/xCss/Valine/wiki
    verify: false # Verification code
    placeholder: 嗨，欢迎你在这里留言~  # comment box placeholder
    avatar: wavatar # gravatar style
    guest_info: nick,mail,link # custom comment header
    pageSize: 10 # pagination size
    visitor: false
    
</code></pre>
</li>
<li><p>参考链接</p>
<blockquote>
<p><a href="https://valine.js.org/quickstart.html">https://valine.js.org/quickstart.html</a><br><a href="https://www.jianshu.com/p/6bc6a8977c36">https://www.jianshu.com/p/6bc6a8977c36</a> </p>
</blockquote>
</li>
</ul>
<h3 id="去除powered-by-valine"><a href="#去除powered-by-valine" class="headerlink" title="去除powered by valine"></a>去除powered by valine</h3><ul>
<li><p>文件位置</p>
<pre><code>  /hexo/themes/next-v6/layout/_third-party/comments/valine.swig 
</code></pre>
</li>
<li><p>在new Valine方法下添加代码：</p>
<pre><code>  new Valine(&#123;
      ......
  &#125;);
  
  //去除powered by valine
  var infoEle = document.querySelector(&#39;#comments .info&#39;);
  if (infoEle &amp;&amp; infoEle.childNodes &amp;&amp; infoEle.childNodes.length &gt; 0)&#123;
     infoEle.childNodes.forEach(function(item) &#123;
         item.parentNode.removeChild(item);
     &#125;);
  &#125;
</code></pre>
</li>
</ul>
<h3 id="当有新评论时邮件通知博主"><a href="#当有新评论时邮件通知博主" class="headerlink" title="当有新评论时邮件通知博主"></a>当有新评论时邮件通知博主</h3><ul>
<li><p>部署Valine-Admin添加邮件通知功能</p>
<blockquote>
<p><a href="https://github.com/zhaojun1998/Valine-Admin">https://github.com/zhaojun1998/Valine-Admin</a></p>
</blockquote>
<p>  配置如下：</p>
<p>  <img src="https://ws1.sinaimg.cn/large/e41482d9ly1fxtlvmgkorj21ne0r477x.jpg"></p>
</li>
</ul>
<h3 id="新建文章时，在相同目录下创建同名文件夹（便于图片管理）"><a href="#新建文章时，在相同目录下创建同名文件夹（便于图片管理）" class="headerlink" title="新建文章时，在相同目录下创建同名文件夹（便于图片管理）"></a>新建文章时，在相同目录下创建同名文件夹（便于图片管理）</h3><ul>
<li><p>本地图片文件引用以及发布到github后显示</p>
<pre><code>  需要安装hexo-asset-image插件：
  sudo npm install https://github.com/CodeFalling/hexo-asset-image --save
  插件安装完后，新建文章时，在相同目录下创建同名文件夹。
  hexo clean后，再重新hexo g -d发布，即可显示引用图片。
</code></pre>
</li>
<li><p>新建文章时，在相同目录下创建同名文件夹（便于图片管理）</p>
<pre><code>  打开站点配置文件_config.yml，搜索post_asset_folder字段，设置其值为true
  安装hexo-asset-image：npm install hexo-asset-image --save
  此时hexo new &quot;fileName&quot;会在/source/_posts目录下创建同名的文件夹
  只需在 md 文件里使用 ![title](图片名.jpg) ，无需路径名就可以插入图片。
</code></pre>
</li>
</ul>
<p>参考文章：</p>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_39345384/article/details/80785373">https://blog.csdn.net/weixin_39345384/article/details/80785373</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo新版与新版本next安装配置完整流程(持续更新)</title>
    <url>/2021/07/25/Hexo%E6%96%B0%E7%89%88%E6%9C%AC%E4%B8%8E%E6%96%B0%E7%89%88%E6%9C%ACnext%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B(%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0)%20/</url>
    <content><![CDATA[<h3 id="1-安装git"><a href="#1-安装git" class="headerlink" title="1.安装git"></a>1.安装git</h3><ul>
<li>直接下载git.exe(windows)或者通过brew安装git即可(mac)</li>
</ul>
<h3 id="2-安装node12"><a href="#2-安装node12" class="headerlink" title="2.安装node12"></a>2.安装node12</h3><ul>
<li>直接官网下载node.msi(windows)或者dmg文件即可(mac)</li>
</ul>
<h3 id="3-安装新版hexo"><a href="#3-安装新版hexo" class="headerlink" title="3.安装新版hexo"></a>3.安装新版hexo</h3><ul>
<li>参考链接</li>
</ul>
<blockquote>
<p><a href="https://hexo.io/zh-cn/docs/setup">https://hexo.io/zh-cn/docs/setup</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">hexo -v</span><br><span class="line">hexo init hexo</span><br><span class="line">cd hexo</span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line">不是到github需要安装git</span><br><span class="line">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>

<h3 id="4-下载next"><a href="#4-下载next" class="headerlink" title="4.下载next"></a>4.下载next</h3><h4 id="hexo配置文件修改："><a href="#hexo配置文件修改：" class="headerlink" title="hexo配置文件修改："></a>hexo配置文件修改：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd hexo</span><br><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br><span class="line">hexo下的hexo配置文件，</span><br><span class="line">_config.yml</span><br><span class="line"></span><br><span class="line">1.配置主题:</span><br><span class="line"> theme: next</span><br><span class="line"> </span><br><span class="line">2.配置语言:</span><br><span class="line"> language: zh-Hans</span><br><span class="line"> </span><br><span class="line">3.站点描述等:</span><br><span class="line">  # Site</span><br><span class="line">  title: Hexo</span><br><span class="line">  subtitle: &#x27;&#x27;</span><br><span class="line">  description: &#x27;&#x27;</span><br><span class="line">  keywords:</span><br><span class="line">  author: John Doe</span><br><span class="line">  #language: en</span><br><span class="line">  timezone: &#x27;&#x27;</span><br><span class="line">  </span><br><span class="line">  改为：</span><br><span class="line">  # Site</span><br><span class="line">  title: uxawseny</span><br><span class="line">  subtitle:</span><br><span class="line">  description: uxawseny@gmail.com</span><br><span class="line">  author: uxawseny</span><br><span class="line">  language: zh-CN</span><br><span class="line">  #language: zh-Hans</span><br><span class="line">  timezone:</span><br><span class="line">  </span><br><span class="line">4.hexo new时同步创建对应文件夹</span><br><span class="line">	###sudo npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br><span class="line">	###安装hexo-asset-image：npm install hexo-asset-image --save</span><br><span class="line">	</span><br><span class="line">  post_asset_folder: false</span><br><span class="line">	改为:</span><br><span class="line">  ##新建文章时，在相同目录下创建同名文件夹</span><br><span class="line">  post_asset_folder: true</span><br><span class="line">  </span><br><span class="line">5.github部署设置</span><br><span class="line">  deploy:</span><br><span class="line">    type: &#x27;&#x27;</span><br><span class="line">    </span><br><span class="line">  改为：</span><br><span class="line">  deploy:</span><br><span class="line">    type:  git</span><br><span class="line">    repo:  git@github.com:uxawseny/uxawseny.github.io.git</span><br><span class="line">    branch:  master</span><br><span class="line">  ## repo:  https://git.coding.net/uxaw/uxaw.coding.me.git</span><br><span class="line">  ## https://github.com/uxawseny/uxawseny.github.io.git</span><br><span class="line">  </span><br><span class="line">  6.文章摘要(新版next主题移除了auto_excerpt)</span><br><span class="line">    excerpt_description:true（next主题里的配置）</span><br><span class="line"></span><br><span class="line"> 		新版next主题移除了auto_excerpt功能，需要单独安装，安装完增加上面的配置即可：</span><br><span class="line"> 		https://github.com/ashisherc/hexo-auto-excerpt</span><br><span class="line"> 		</span><br><span class="line"> 		npm install --save hexo-auto-excerpt</span><br><span class="line"> 		hexo的配置文件增加：</span><br><span class="line"> 		excerpt_length: 400</span><br><span class="line"> 		</span><br><span class="line">  7.hexo-neat 静态资源压缩</span><br><span class="line">		npm install hexo-neat --save</span><br><span class="line">		</span><br><span class="line">    # 博文压缩</span><br><span class="line">    neat_enable: true</span><br><span class="line">    # 压缩html</span><br><span class="line">    neat_html:</span><br><span class="line">      enable: true</span><br><span class="line">      exclude:</span><br><span class="line">    # 压缩css  </span><br><span class="line">    neat_css:</span><br><span class="line">      enable: true</span><br><span class="line">      exclude:</span><br><span class="line">        - &#x27;**/*.min.css&#x27;</span><br><span class="line">    # 压缩js</span><br><span class="line">    neat_js:</span><br><span class="line">      enable: true</span><br><span class="line">      mangle: true</span><br><span class="line">      output:</span><br><span class="line">      compress:</span><br><span class="line">      exclude:</span><br><span class="line">        - &#x27;**/*.min.js&#x27;</span><br><span class="line">        - &#x27;**/jquery.fancybox.pack.js&#x27;</span><br><span class="line">        - &#x27;**/index.js&#x27; </span><br><span class="line"> 		</span><br></pre></td></tr></table></figure>

<h4 id="next配置"><a href="#next配置" class="headerlink" title="next配置"></a>next配置</h4><p><a href="https://github.com/next-theme/hexo-theme-next/issues/4">【必读】更新说明及常见问题 · Issue #4 · next-theme/hexo-theme-next (github.com)</a></p>
<ul>
<li>配置参考</li>
</ul>
<blockquote>
<p><a href="https://blog.csdn.net/sinat_33381791/article/details/82767481">https://blog.csdn.net/sinat_33381791/article/details/82767481</a></p>
</blockquote>
<blockquote>
<p><a href="http://theme-next.iissnan.com/getting-started.html">http://theme-next.iissnan.com/getting-started.html</a></p>
</blockquote>
<ul>
<li>next自定义配置文件_config.next.yml(hexo配置文件统计目录下)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">############################## 1.主题模式</span><br><span class="line">scheme: Gemini</span><br><span class="line"></span><br><span class="line">############################## 2.底部时间</span><br><span class="line">footer:</span><br><span class="line">  powered: false</span><br><span class="line">  since: 2016</span><br><span class="line">  # color: &quot;#808080&quot;</span><br><span class="line"></span><br><span class="line"># footer:</span><br><span class="line">#   # Specify the date when the site was setup. If not defined, current year will be used.</span><br><span class="line">#   #since: 2016</span><br><span class="line">#   # Icon between year and copyright info.</span><br><span class="line">#   icon:</span><br><span class="line">#     # Icon name in Font Awesome. See: https://fontawesome.com/icons</span><br><span class="line">#     name: heart</span><br><span class="line">#     # If you want to animate the icon, set it to true.</span><br><span class="line">#     animated: false</span><br><span class="line">#     # Change the color of icon, using Hex Code.</span><br><span class="line">#     color: &quot;#808080&quot;</span><br><span class="line"></span><br><span class="line">############################## 3.语言切换按钮</span><br><span class="line">language_switcher: true</span><br><span class="line"></span><br><span class="line">############################## 4.本地搜索</span><br><span class="line">##############################npm install hexo-generator-searchdb --save</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # If auto, trigger search by changing input.</span><br><span class="line">  # If manual, trigger search by pressing enter key or search button.</span><br><span class="line">  trigger: auto</span><br><span class="line">  # Show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br><span class="line">  # Unescape html strings to the readable one.</span><br><span class="line">  unescape: false</span><br><span class="line">  # Preload the search data when the page loads.</span><br><span class="line">  preload: false</span><br><span class="line"></span><br><span class="line">############################## 5.ico图标</span><br><span class="line"># favicon:</span><br><span class="line">#   small: /img/favicon.ico</span><br><span class="line">#   medium: /img/favicon.ico</span><br><span class="line">#   apple_touch_icon: //img/favicon.ico</span><br><span class="line">#   safari_pinned_tab: /img/favicon.ico</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">############################## 6.右上角github地址</span><br><span class="line">github_banner:</span><br><span class="line">  enable: true</span><br><span class="line">  permalink: https://github.com/uxawseny</span><br><span class="line">  title: Follow me on GitHub</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">############################## 7.边栏目录</span><br><span class="line">toc:</span><br><span class="line">  enable: true</span><br><span class="line">  # Automatically add list number to toc.</span><br><span class="line">  number: true</span><br><span class="line">  # If true, all words will placed on next lines if header width longer then sidebar width.</span><br><span class="line">  wrap: false</span><br><span class="line">  # If true, all level of TOC in a post will be displayed, rather than the activated part of it.</span><br><span class="line">  expand_all: false</span><br><span class="line">  # Maximum heading depth of generated toc.</span><br><span class="line">  max_depth: 6</span><br><span class="line"></span><br><span class="line">############################## 8.代码拷贝和高亮</span><br><span class="line">############################## npm i hexo-renderer-swig</span><br><span class="line">codeblock:</span><br><span class="line">  # Code Highlight theme</span><br><span class="line">  # Available values: normal | night | night eighties | night blue | night bright | solarized | solarized dark | galactic</span><br><span class="line">  # See: https://github.com/chriskempson/tomorrow-theme</span><br><span class="line">  highlight_theme: normal</span><br><span class="line">  # Add copy button on codeblock</span><br><span class="line">  copy_button:</span><br><span class="line">    enable: true</span><br><span class="line">    # Show text copy result.</span><br><span class="line">    show_result: true</span><br><span class="line">    # Available values: default | flat | mac</span><br><span class="line">    style:</span><br><span class="line"></span><br><span class="line">############################## 9.栏目分类</span><br><span class="line">menu:</span><br><span class="line">  home: / || fa fa-home</span><br><span class="line">  about: /about/ || fa fa-user</span><br><span class="line">  #tags: /tags/ || fa fa-tags</span><br><span class="line">  categories: /categories/ || fa fa-th</span><br><span class="line">  archives: /archives/ || fa fa-archive</span><br><span class="line">  #schedule: /schedule/ || fa fa-calendar</span><br><span class="line">  #sitemap: /sitemap.xml || fa fa-sitemap</span><br><span class="line">  #commonweal: /404/ || fa fa-heartbeat</span><br><span class="line"></span><br><span class="line">############################################7.头像</span><br><span class="line">avatar:</span><br><span class="line">  # In theme directory (source/images): /images/avatar.gif</span><br><span class="line">  # In site directory (source/uploads): /uploads/avatar.gif</span><br><span class="line">  # You can also use other linking images.</span><br><span class="line">  url: /img/avatar.jpg</span><br><span class="line">  # If true, the avatar would be dispalyed in circle.</span><br><span class="line">  rounded: false</span><br><span class="line">  # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar.</span><br><span class="line">  opacity: 1</span><br><span class="line">  # If true, the avatar would be rotated with the cursor.</span><br><span class="line">  rotated: false</span><br><span class="line"></span><br><span class="line">############################################8.头像下方的github图标</span><br><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/uxawseny || github</span><br><span class="line">  # E-Mail: mailto:uxawseny@gmail.com || envelope</span><br><span class="line">  # Weibo: https://weibo.com/3826549465 || weibo</span><br><span class="line">  #Google: https://plus.google.com/yourname || google</span><br><span class="line">  # Twitter: https://twitter.com/yourname || twitter</span><br><span class="line">  #FB Page: https://www.facebook.com/yourname || facebook</span><br><span class="line">  #VK Group: https://vk.com/yourname || vk</span><br><span class="line">  #StackOverflow: https://stackoverflow.com/yourname || stack-overflow</span><br><span class="line">  #YouTube: https://youtube.com/yourname || youtube</span><br><span class="line">  #Instagram: https://instagram.com/yourname || instagram</span><br><span class="line">  #Skype: skype:yourname?call|chat || skype</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">############################################9.侧边栏位置</span><br><span class="line">sidebar:</span><br><span class="line">  # Sidebar Position.</span><br><span class="line">  position: left</span><br><span class="line">  #position: right</span><br><span class="line"></span><br><span class="line">  # Manual define the sidebar width. If commented, will be default for:</span><br><span class="line">  # Muse | Mist: 320</span><br><span class="line">  # Pisces | Gemini: 240</span><br><span class="line">  #width: 300</span><br><span class="line"></span><br><span class="line">  # Sidebar Display (only for Muse | Mist), available values:</span><br><span class="line">  #  - post    expand on posts automatically. Default.</span><br><span class="line">  #  - always  expand for all pages automatically.</span><br><span class="line">  #  - hide    expand only when click on the sidebar toggle icon.</span><br><span class="line">  #  - remove  totally remove sidebar including sidebar toggle.</span><br><span class="line">  display: post</span><br><span class="line"></span><br><span class="line">  # Sidebar padding in pixels.</span><br><span class="line">  padding: 18</span><br><span class="line">  # Sidebar offset from top menubar in pixels (only for Pisces | Gemini).</span><br><span class="line">  offset: 12</span><br><span class="line">  # Enable sidebar on narrow view (only for Muse | Mist).</span><br><span class="line">  onmobile: false</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="安装最新版hexo-5-x和next-v8后，所有需要另外安装的npm模块整理"><a href="#安装最新版hexo-5-x和next-v8后，所有需要另外安装的npm模块整理" class="headerlink" title="安装最新版hexo 5.x和next-v8后，所有需要另外安装的npm模块整理"></a>安装最新版hexo 5.x和next-v8后，所有需要另外安装的npm模块整理</h3><ul>
<li><p>模块清单</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.安装hexo与卸载：</span><br><span class="line">sudo npm uninstall hexo-cli -g</span><br><span class="line">sudo npm install -g hexo-cli</span><br><span class="line"></span><br><span class="line">2.额外模块：</span><br><span class="line">##git</span><br><span class="line">npm install --save hexo-deployer-git</span><br><span class="line">##静态资源压缩</span><br><span class="line">npm install hexo-neat --save</span><br><span class="line">##本地搜索</span><br><span class="line">npm install hexo-generator-searchdb --save </span><br><span class="line">##文章摘要</span><br><span class="line">npm install --save hexo-auto-excerpt</span><br><span class="line">##本地图片</span><br><span class="line">npm install hexo-asset-image --save</span><br><span class="line">sudo npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br><span class="line">##代码拷贝按钮</span><br><span class="line">npm i hexo-renderer-swig</span><br><span class="line"></span><br><span class="line">##安装hexo时的warning信息：</span><br><span class="line">warning hexo-renderer-stylus &gt; stylus &gt; css-parse &gt; css &gt; urix@0.1.0: Please see https://github.com/lydell/urix#deprecated</span><br><span class="line">warning hexo-renderer-stylus &gt; stylus &gt; css-parse &gt; css &gt; source-map-resolve &gt; urix@0.1.0: Please see https://github.com/lydell/urix#deprecated</span><br><span class="line">warning hexo-renderer-stylus &gt; stylus &gt; css-parse &gt; css &gt; source-map-resolve &gt; resolve-url@0.2.1: https://github.com/lydell/resolve-url#deprecated</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA</title>
    <url>/2017/05/23/IDEA/</url>
    <content><![CDATA[<h2 id="IDEA常用快捷键"><a href="#IDEA常用快捷键" class="headerlink" title="IDEA常用快捷键"></a>IDEA常用快捷键</h2><ul>
<li><p>常用快捷键：</p>
<pre><code>  Ctrl+Alt+L:自动格式化代码
  Ctrl+Enter:另起一行
  Alt+Insert:Generate-getter/setter等(macos下是control+N)

  Alt+Enter:各种错误解决方案提示
  Ctrl+Alt+Shift+S:Project Structure即 Artifacts、Modules、Facets等设置
  Shift+F6：重命名你的类、方法、变量等，可以选择替换掉注释中的内容
  ctrl+d：复制当前行
  ctrl+y：删除当前行
  sout：system.out.print快捷方式
  psvm：main放大快捷方式
  Ctrl+shift +/- :展开/折叠全部代码
  command+7:显示该类下的所有方法
  command+\:生成属性，类注释
  command+contro\：生成类文档
</code></pre>
</li>
</ul>
<h2 id="错误提示"><a href="#错误提示" class="headerlink" title="错误提示"></a>错误提示</h2><p>1099：tomcat和jdk版本不匹配</p>
<h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><pre><code>find action(command + shift +a)下搜索快捷键：
如recent file 提示快捷键为 command + e

搜索文件:
command+n
最近文件：
command+e
书签标记
command+f11
书签跳转
control+书签数字
收藏代码
alt+shift+f
展现收藏列表
command+2
展现project导航栏
command+1

左边栏与代码编辑框的互相跳转
command+1跳转到左边栏，esc恢复到代码编辑框
</code></pre>
<h2 id="IDEA常用插件"><a href="#IDEA常用插件" class="headerlink" title="IDEA常用插件"></a>IDEA常用插件</h2><ul>
<li><p>lombok</p>
<pre><code>  实体类不写getter/setter;
  Slf4j等；
  详见笔记《Lombok参考手册》
</code></pre>
</li>
<li><p>iBATIS/MyBatis mini-plugin</p>
<pre><code>  方便接口到实现的跳转；dao接口到xml SQL语句的跳转
</code></pre>
</li>
<li><p>IDEA maven helper</p>
<pre><code>  pom.xml文件中方便查看maven依赖冲突，依赖列表，依赖树
</code></pre>
<blockquote>
<p><a href="https://my.oschina.net/u/136229/blog/678918">https://my.oschina.net/u/136229/blog/678918</a></p>
</blockquote>
</li>
<li><p>JRebel</p>
<pre><code>  实现IDEA下应用的热部署热编译，修改静态文件，java文件，无需重启即可自动编译部署，使之生效；
  收费插件；
  详见笔记《jrebel》
</code></pre>
</li>
<li><p>EasyCode</p>
</li>
</ul>
<blockquote>
<p><a href="https://juejin.im/entry/5b6a61a1f265da0f7e62b1b0?utm_source=gold_browser_extension">https://juejin.im/entry/5b6a61a1f265da0f7e62b1b0?utm_source=gold_browser_extension</a></p>
</blockquote>
<h2 id="IDEA常用设置"><a href="#IDEA常用设置" class="headerlink" title="IDEA常用设置"></a>IDEA常用设置</h2><ul>
<li><p>参考</p>
<blockquote>
<p><a href="https://blog.csdn.net/qq_27093465/article/details/77449117">https://blog.csdn.net/qq_27093465/article/details/77449117</a></p>
</blockquote>
</li>
<li><p>设置显示项目内存占用</p>
<pre><code>  preference&gt;appearence&amp;Behavior&gt;appearence&gt;window options下勾选show mwmory indicator
</code></pre>
</li>
</ul>
]]></content>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA下mapper.xml颜色</title>
    <url>/2017/12/05/IDEA%E4%B8%8Bmapper-xml%E9%A2%9C%E8%89%B2/</url>
    <content><![CDATA[<h2 id="解决在Intellij-IDEA下使用ssm框架时，mapper-xml文件显示黄色色块问题"><a href="#解决在Intellij-IDEA下使用ssm框架时，mapper-xml文件显示黄色色块问题" class="headerlink" title="解决在Intellij IDEA下使用ssm框架时，mapper.xml文件显示黄色色块问题"></a>解决在Intellij IDEA下使用ssm框架时，mapper.xml文件显示黄色色块问题</h2><ul>
<li>解决方法<pre><code>  将文件头的
  &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
  
  改为：
  &quot;http://Mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
  
  或者：
  &quot;http://mybatis.org/dtd/mybatis-3-Mapper.dtd&quot;&gt;
  
</code></pre>
  这样改不会影响项目正常运行，而且会消除mapper.xml文件色块问题。</li>
</ul>
]]></content>
      <tags>
        <tag>IDEA</tag>
        <tag>mapper.xml颜色问题</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC</title>
    <url>/2016/03/01/JDBC/</url>
    <content><![CDATA[<h2 id="JDBC概述"><a href="#JDBC概述" class="headerlink" title="JDBC概述"></a>JDBC概述</h2><ul>
<li><p>jdbc概述</p>
<p>   JDBC从物理结构上说就是Java语言访问数据库的一套接口集合。<br>从本质上来说就是调用者(程序员)和实现者(数据库厂商)之间的协议。</p>
<p>  JDBC API 使得开发人员可以使用纯Java的方式来连接数据库，并进行操作。<br>  ODBC：基于C语言的数据库访问接口。<br>  JDBC：是Java版的ODBC。<br>  JDBC 特性：高度的一致性、简单性(常用的接口只有4、5个)。</p>
</li>
</ul>
<h2 id="JDBC-编程的步骤"><a href="#JDBC-编程的步骤" class="headerlink" title="JDBC 编程的步骤"></a>JDBC 编程的步骤</h2><ul>
<li><p>基本步骤：</p>
<p>  1.加载和注册数据库驱动<br>  2.连接数据库<br>  3.创建Statement对象 //为了类型安全和批量更新的效率，改用PreparedStatement<br>  4.操作数据库，执行SQL语句<br>  5.处理数据(游标)<br>  6.释放资源，断开与数据库的连接</p>
</li>
<li><p>代码示例</p>
<pre><code>  public class ConnTest2 &#123;
      private static final String URL = &quot;jdbc:mysql://localhost:3306/jdbc_test&quot;;
      private static final String USER = &quot;root&quot;;
      private static final String PASSWORD = &quot;123&quot;;
  
      public static void main(String[] args) throws ClassNotFoundException, SQLException &#123;
          //加载驱动
          Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
          //获取数据库连接
          Connection conn = DriverManager.getConnection(URL,USER,PASSWORD);
          Statement stmt = conn.createStatement();
          //通过数据库的连接操作数据库，实现对数据库的增删改查
          ResultSet rs = stmt.executeQuery(&quot;SELECT user_name,age FROM person&quot;);
          while(rs.next())&#123;
              System.out.println(rs.getString(&quot;user_name&quot;)+&quot;,&quot;+rs.getInt(&quot;age&quot;));
          &#125;
      &#125;
  &#125;
</code></pre>
</li>
<li><p>但是通常情况下，为了代码复用，都会将连接语句封装成一个工具类DBUtils</p>
<pre><code>  package com.jdbc.utils;
  
  import java.sql.Connection;
  import java.sql.DriverManager;
  import java.sql.SQLException;
  
  /**
   * 数据库连接工具类 供其他类使用
   */
  public class DBUtils &#123;
      private static final String URL = &quot;jdbc:mysql://localhost:3306/jdbc_test&quot;;
      private static final String USER = &quot;root&quot;;
      private static final String PASSWORD = &quot;123&quot;;
      private static Connection conn = null;
  
      public static Connection getConnection() throws ClassNotFoundException, SQLException &#123;
          //加载数据库驱动
          Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
          //获取数据库连接信息
          conn = DriverManager.getConnection(URL, USER, PASSWORD);
          //Statement stmt = conn.createStatement();
          //返回数据库连接信息对外提供使用
          return conn;
      &#125;
  
  &#125;
</code></pre>
</li>
</ul>
<ul>
<li><p>Dao层方法调用DBUtils</p>
<pre><code>  //删除
  public void del(Person person) throws SQLException, ClassNotFoundException &#123;
      Connection conn = DBUtils.getConnection();
      String sql;
      sql = &quot;DELETE FROM person WHERE id=?&quot;;
      PreparedStatement ptmt = conn.prepareStatement(sql);
      ptmt.setInt(1, person.getId());
      ptmt.execute();

  &#125;
</code></pre>
</li>
</ul>
<h2 id="JDBC几个重要接口"><a href="#JDBC几个重要接口" class="headerlink" title="JDBC几个重要接口"></a>JDBC几个重要接口</h2><ul>
<li><p>参考博客：</p>
<blockquote>
<p><a href="http://blog.csdn.net/gotohbu/article/details/4501811">http://blog.csdn.net/gotohbu/article/details/4501811</a></p>
</blockquote>
</li>
<li><p><strong>JDBC中包括了两个包：java.sql和javax.sql</strong></p>
<pre><code>  java.sql  基本功能。
  javax.sql  扩展功能。
</code></pre>
</li>
<li><p>java.sql</p>
<p>  这个包中的类和接口主要针对基本的数据库编程服务，如生成连接、执行语句以及准备语句和运行批处理查询等。同时也有一些高级的处理，比如批处理更新、事务隔离和可滚动结果集等</p>
</li>
<li><p>javax.sql</p>
<p>  它主要为数据库方面的高级操作提供了接口和类。</p>
<p>  如为连接管理、分布式事务和旧有的连接提供了更好的抽象，它引入了容器管理的连接池、分布式事务和行集等。</p>
</li>
<li><p><strong>Statement与PreparedStatement</strong></p>
</li>
<li><p>Statement</p>
<p>  SQL语句执行接口，代表了一个数据库的状态，在向数据库发送相应的SQL语句时，都需要创建Statement接口或PreparedStatement接口。</p>
<p>  在具体应用中，Statement主要用于操作不带参数(可以直接运行)的SQL语句，比如删除语句、添加或更新</p>
</li>
<li><p>PreparedStatement</p>
</li>
</ul>
<h2 id="Statement、PreparedStatement、CallableStatement"><a href="#Statement、PreparedStatement、CallableStatement" class="headerlink" title="Statement、PreparedStatement、CallableStatement"></a>Statement、PreparedStatement、CallableStatement</h2><ul>
<li><p>三种方式分析比较</p>
<p>  1.JDBC提供了Statement、PreparedStatement 和 CallableStatement三种方式来执行查询语句，</p>
<pre><code>  其中 Statement 用于通用查询， 
  PreparedStatement 用于执行参数化查询，
  而 CallableStatement则是用于存储过程
  
</code></pre>
<p>  2.对于PreparedStatement来说，数据库可以使用已经编译过及定义好的执行计划，<br>  由于PreparedStatement对象已预编译过，所以其执行速度要快于Statement对象。</p>
<p>  3.PreparedStatement：</p>
<pre><code>  可变参数的SQL,编译一次,执行多次,效率高;
  支持批量更新,批量删除;  
  可以阻止常见的SQL注入式攻击。
  PreparedStatement中，“?” 叫做占位符，一个占位符必定只能对应一个值
</code></pre>
</li>
</ul>
<h2 id="JDBC中Transaction编程-事务编程"><a href="#JDBC中Transaction编程-事务编程" class="headerlink" title="JDBC中Transaction编程(事务编程)"></a>JDBC中Transaction编程(事务编程)</h2><ul>
<li><p>事务的特点</p>
<ol>
<li>原子性(Atomicity)：事务是一个完整的操作</li>
<li>一致性(Consistency):当事务完成时，数据必须处于一致状态</li>
<li>隔离性(Isolation):对数据进行修改的所有并发事务是彼此隔离的</li>
<li>永久性(Durability):事务完成时，它对数据库的修改被永久保持</li>
</ol>
</li>
</ul>
<h2 id="JDBC替代品"><a href="#JDBC替代品" class="headerlink" title="JDBC替代品"></a>JDBC替代品</h2><ul>
<li><p>主要有一下替代品</p>
<ul>
<li>commons-dbutils</li>
<li>hibernate</li>
<li>mybatis</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>JQuery</title>
    <url>/2018/03/02/JQuery/</url>
    <content><![CDATA[<h2 id="JQuery基础"><a href="#JQuery基础" class="headerlink" title="JQuery基础"></a>JQuery基础</h2><h3 id="jquery优点"><a href="#jquery优点" class="headerlink" title="jquery优点"></a>jquery优点</h3><ul>
<li>强大的选择器</li>
<li>解决浏览器的兼容</li>
<li>完善的时间机制</li>
<li>出色的ajax封装</li>
<li>丰富的UI</li>
</ul>
<h3 id="特性与工具方法"><a href="#特性与工具方法" class="headerlink" title="特性与工具方法"></a>特性与工具方法</h3><ul>
<li>链式操作</li>
<li>回调函数</li>
<li>迭代器 </li>
<li>延迟对象</li>
<li>队列</li>
</ul>
<h3 id="JQuery基础归类"><a href="#JQuery基础归类" class="headerlink" title="JQuery基础归类"></a>JQuery基础归类</h3><ul>
<li>样式</li>
<li>DOM</li>
<li>事件</li>
<li>动画</li>
</ul>
<h2 id="JQuery高级"><a href="#JQuery高级" class="headerlink" title="JQuery高级"></a>JQuery高级</h2><h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><ul>
<li><p>data包含中文时乱码</p>
<p>  提交方式由GET改为POST</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM思维导图</title>
    <url>/2018/04/12/JVM/</url>
    <content><![CDATA[<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><p><img src="http://ogy57hyu6.bkt.clouddn.com/JVM.png"></p>
<ul>
<li>启动流程图<br>  <img src="http://ogy57hyu6.bkt.clouddn.com/JVM%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B1.png"></li>
</ul>
]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JS总结</title>
    <url>/2017/05/18/JS%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="生成4位随机数"><a href="#生成4位随机数" class="headerlink" title="生成4位随机数"></a>生成4位随机数</h2><ul>
<li><p>生成4位随机数</p>
<blockquote>
<p><a href="http://op05inpyd.bkt.clouddn.com/%E9%9A%8F%E6%9C%BA%E6%95%B0.txt">http://op05inpyd.bkt.clouddn.com/%E9%9A%8F%E6%9C%BA%E6%95%B0.txt</a></p>
</blockquote>
<pre><code>  &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
  &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
  &lt;head&gt;
      &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gb2312&quot; /&gt;
      &lt;title&gt;随机数&lt;/title&gt;
      &lt;style type=&quot;text/css&quot;&gt;
          .textbox
          &#123;
              margin-right: 5px;
              margin-top: 10px;
              width: 70px;
              font-family: 微软雅黑;
              text-align: center;
              font-weight: bold;
              font-size: 16px;
              color: Blue;
          &#125;
      &lt;/style&gt;
      &lt;script type=&quot;text/javascript&quot;&gt;
          //增加文本框
          function CreateTextBox() &#123;
              var count = GetTextBoxCount();
              if (count &lt; 10) &#123;
                  var textBox = document.createElement(&quot;input&quot;);
                  textBox.setAttribute(&quot;type&quot;, &quot;text&quot;);
                  textBox.setAttribute(&quot;name&quot;, &quot;myname&quot;);
                  textBox.className = &quot;textbox&quot;;
                  document.body.appendChild(textBox);
              &#125; else &#123;
                  alert(&quot;最多生成10个随机数&quot;);
              &#125;
          &#125;
          //减少文本框
          function RemoveTextBox() &#123;
              var count = GetTextBoxCount();
              if (count &gt; 1) &#123;
                  document.body.removeChild(document.body.lastChild);
              &#125;
              else &#123;
                  alert(&quot;请最少保留1个&quot;);
              &#125;
          &#125;
          //计算文本框的个数
          function GetTextBoxCount() &#123;
              var elements = document.getElementsByName(&quot;myname&quot;);
              return elements.length;
          &#125;
          Array.prototype.Contains = function (num) &#123;
              var flag = false;
              if (this.length &lt;= 0) &#123;
                  return flag;
              &#125;
              for (var i = 0; i &lt; this.length; i++) &#123;
                  if (this[i] == num) &#123;
                      flag = true;
                      break;
                  &#125;
              &#125;
              return flag;
          &#125;
          //生成4位随机数并放到数组中
          function CreateRandomNumber(array, count) &#123;
              while (array.length &lt; count) &#123;
                  var num = Math.floor((Math.random()) * 9000+1000);
                  if (!array.Contains(num)) &#123;
                      array.push(num);
                  &#125;
              &#125;
          &#125;
          //将数组中的随机数赋值到界面的文本框中
          function SetTextBoxValue() &#123;
              var array = new Array();
              var count = GetTextBoxCount();
              CreateRandomNumber(array, count);
              var elements = document.getElementsByName(&quot;myname&quot;);
              for (var i = 0; i &lt; elements.length; i++) &#123;
                  elements[i].value = array[i];
              &#125;
          &#125;
      &lt;/script&gt;
  &lt;/head&gt;
  &lt;body onload=&quot;CreateTextBox()&quot;&gt;
      &lt;input type=&quot;button&quot; value=&quot;增加&quot; onclick=&quot;CreateTextBox()&quot; /&gt;
      &lt;input type=&quot;button&quot; value=&quot;减少&quot; onclick=&quot;RemoveTextBox()&quot; /&gt;
      &lt;input type=&quot;button&quot; value=&quot;生成随机数&quot; onclick=&quot;SetTextBoxValue()&quot; /&gt;&lt;br /&gt;
  &lt;/body&gt;
  &lt;/html&gt;
</code></pre>
</li>
</ul>
<h2 id="生成不重复的4位随机数"><a href="#生成不重复的4位随机数" class="headerlink" title="生成不重复的4位随机数"></a>生成不重复的4位随机数</h2><ul>
<li><p>生成不重复的4位随机数</p>
<blockquote>
<p><a href="http://op05inpyd.bkt.clouddn.com/%E7%94%9F%E6%88%90%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%844%E4%BD%8D%E9%9A%8F%E6%9C%BA%E6%95%B0.txt">http://op05inpyd.bkt.clouddn.com/%E7%94%9F%E6%88%90%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%844%E4%BD%8D%E9%9A%8F%E6%9C%BA%E6%95%B0.txt</a></p>
</blockquote>
<pre><code>  /**
   * 生成4位随机数并赋值,已经有随机数的输入框，不再赋值
   */
   function GetTextBoxCount() &#123;
       var elements = document.getElementsByName(&quot;ConfirmationCode&quot;);
       //TODO 只取空值的个数
       var nums=0;
       for(var j = 0; j &lt; elements.length; j++)&#123;
           if(elements[j].value == null || elements[j].value ==&quot;&quot;)&#123;
               nums++;
           &#125;
       &#125;
       return elements.length;
   &#125;
  
   Array.prototype.Contains = function (num) &#123;
       var flag = false;
       if (this.length &lt;= 0) &#123;
           return flag;
       &#125;
       for (var i = 0; i &lt; this.length; i++) &#123;
           if (this[i] == num) &#123;
               flag = true;
               break;
           &#125;
       &#125;
       return flag;
   &#125;
   function CreateRandomNumber(array,array2,count) &#123;
       while (array.length &lt; count) &#123;
           var num = Math.floor((Math.random()) * 9000+1000);
           //将随机生成的数字与页面原有随机数比较，保证不重复
           if (!array.Contains(num) &amp;&amp; !array2.Contains(num)) &#123;
               array.push(num);
           &#125;
       &#125;
   &#125;
   function SetTextBoxValue() &#123;
       var array = new Array();
       var array2 = new Array();
       var elements = document.getElementsByName(&quot;ConfirmationCode&quot;);
          //将已经存在的随机码存进array
          for (var i = 0; i &lt; elements.length; i++) &#123;
              array2.push(elements[i]);
          &#125;
       var count = GetTextBoxCount();
       CreateRandomNumber(array,array2,count);
       
       for (var i = 0; i &lt; elements.length; i++) &#123;
           //非空不赋值
           if(elements[i].value == null || elements[i].value ==&quot;&quot;)&#123;
               elements[i].value = array[i]; 
           &#125;
       &#125;
   &#125;
  /**
  * 检查用户手动输入确认码是否重复
  */
  function IsCodeExists(data)&#123;
      //获取页面数据并存进数组中
      var elements = document.getElementsByName(&quot;ConfirmationCode&quot;);
      var array4 = new Array();
         for (var i = 0; i &lt; elements.length; i++) &#123;
              array4.push(elements[i].value);
          &#125;
        //对数组中的数据进行重复比较
         var ary = array4; 
         var nary=ary.sort(); 
         for(var i=0;i&lt;ary.length;i++)&#123; 
             if (nary[i]==nary[i+1] &amp;&amp; nary[i] !=&quot;&quot;)&#123; 
             alert(&quot;确认码 &quot;+nary[i]+&quot; 重复，请重新输入！&quot;); 
             &#125;
         &#125;
  &#125;

  /**
  * 提交前再做一次重复判断，若重复，则弹窗提醒并且不提交
  */
  function btnsave_clicked()&#123;
      var flag=false;
      //获取页面数据并存进数组中
      var elements = document.getElementsByName(&quot;ConfirmationCode&quot;);
      var array4 = new Array();
        for (var i = 0; i &lt; elements.length; i++) &#123;
             array4.push(elements[i].value);
         &#125;
        //对数组中的数据进行重复比较
         var ary = array4; 
         var nary=ary.sort(); 
         for(var i=0;i&lt;ary.length;i++)&#123; 
             if (nary[i]==nary[i+1] &amp;&amp; nary[i] !=&quot;&quot;)&#123; 
                 flag=false;
                 alert(&quot;确认码 &quot;+nary[i]+&quot; 重复，请重新输入！&quot;); 
                return false;
             &#125;else&#123;
                 flag=true;
             &#125;
         &#125;
      if(flag)&#123;
          //将要返回的数据打包封装
          document.all.formdetail.value = getDetail2();
          document.all.lg_sh_deliveryconfirmationcodform.action=&lt;select:link page=&quot;/lg_sh_deliveryconfirmationcodaction.do?method=save&quot;&gt;&lt;/select:link&gt;;
          document.all.lg_sh_deliveryconfirmationcodform.submit();
          
      &#125;
  
  &#125;
</code></pre>
</li>
</ul>
<h2 id="给查询结果集计算行数并赋值行数"><a href="#给查询结果集计算行数并赋值行数" class="headerlink" title="给查询结果集计算行数并赋值行数"></a>给查询结果集计算行数并赋值行数</h2><ul>
<li><p>给查询结果集计算行数并赋值行数</p>
<pre><code>  //计算行数
  function init()&#123;
      for(var i=1; i&lt;=intTotalRow; i++)&#123;
          document.all.seq[i].value = i;
      &#125;
  &#125;

  ------
  对应的文本框属性
  &lt;grid:text style=&quot;width:40px;&quot; readonly=&quot;true&quot; isReturn=&quot;true&quot; capital=&quot;序号&quot; property=&quot;seq&quot; tabindex=&quot;-1&quot;/&gt; 
</code></pre>
</li>
</ul>
<h2 id="div显示切换"><a href="#div显示切换" class="headerlink" title="div显示切换"></a>div显示切换</h2><ul>
<li><p>点击按钮，让两个div切换显示，只显示一个</p>
<pre><code>  &lt;!DOCTYPE html&gt;
  &lt;script&gt;
      function btn1()&#123;
          document.getElementById(&#39;div1&#39;).style.display=&#39;none&#39;;
          document.getElementById(&#39;div2&#39;).style.display=&#39;block&#39;;
      &#125;
      function btn2()&#123;
          document.getElementById(&#39;div1&#39;).style.display=&#39;block&#39;;
          document.getElementById(&#39;div2&#39;).style.display=&#39;none&#39;;
      &#125; 
  &lt;/script&gt;
  
  &lt;body&gt;
      &lt;div id=&quot;div1&quot; style=&quot;background:green;height:200px&quot;&gt;
      第一个div高200px
      &lt;/div&gt;
      &lt;div id=&quot;div2&quot; style=&quot;background:gray; display:none;height:400px&quot;&gt;
      第二个div高400px
      &lt;/div&gt;
      &lt;button id=&quot;btn1&quot; onclick=&quot;btn1()&quot;&gt;显示第二个&lt;/button&gt;
      &lt;button id=&quot;btn1&quot; onclick=&quot;btn2()&quot;&gt;显示第一个&lt;/button&gt;
      &lt;/body&gt;
  &lt;/html&gt;
</code></pre>
</li>
</ul>
<h2 id="js过滤空格"><a href="#js过滤空格" class="headerlink" title="js过滤空格"></a>js过滤空格</h2><ul>
<li><p>过滤获取值的空格</p>
<pre><code>  1、过滤字符串两边的空格
     str = $.trim(str)
  
  2、过滤所有空格
     str = str.replace(/ /g,&#39;&#39;)

  例如：
  var num = document.getElementById(&#39;truckNumInput&#39;).value.replace(/ /g,&#39;&#39;);
</code></pre>
</li>
</ul>
<h2 id="输入框获取焦点"><a href="#输入框获取焦点" class="headerlink" title="输入框获取焦点"></a>输入框获取焦点</h2><ul>
<li><p>加载页面时输入框获取焦点</p>
<pre><code>  &lt;script&gt;
      window.onload = function()&#123;
          document.getElementById(&quot;name&quot;).focus();
      &#125;
  &lt;/script&gt;
</code></pre>
</li>
</ul>
<h2 id="JS代码收集"><a href="#JS代码收集" class="headerlink" title="JS代码收集"></a>JS代码收集</h2><ul>
<li>代码位置(私有)</li>
</ul>
<blockquote>
<p><a href="https://git.coding.net/uxaw/keyboard.git">https://git.coding.net/uxaw/keyboard.git</a></p>
</blockquote>
<h3 id="包含内容："><a href="#包含内容：" class="headerlink" title="包含内容："></a>包含内容：</h3><ul>
<li>网页键盘</li>
<li>table点击变色</li>
</ul>
<h2 id="span标签内容居中"><a href="#span标签内容居中" class="headerlink" title="span标签内容居中"></a>span标签内容居中</h2><ul>
<li><p>span标签内容居中</p>
<pre><code>  &lt;body&gt;
  &lt;div style=&quot;width:160px;height:100px;border:1px dashed #FFFFFF;margin:0 auto&quot; &gt;
      &lt;span style=&quot;height:100px;display:block;background:gray;margin:1px 1px;text-align:center;line-height:100px;&quot;&gt;
      内容内容内容
      &lt;/span&gt;
  &lt;/div&gt;
  &lt;/body&gt;
</code></pre>
</li>
</ul>
<h2 id="JQuery格式"><a href="#JQuery格式" class="headerlink" title="JQuery格式"></a>JQuery格式</h2><ul>
<li><p>JQuery</p>
<pre><code>  $.post(&quot;login.tushu&quot;,-------------------url
      &#123;
          &quot;userName&quot;: userName,
          &quot;passWord&quot;: passWord
      &#125;,               ---------------------data
      function (respnum) &#123;
          var obj = eval(&quot;(&quot; + respnum + &quot;)&quot;);
          var num = obj.num;
          if (0 == num) &#123;
              loginNo.css(&quot;display&quot;, &quot;block&quot;);
          &#125; else &#123;
              //跳转页面
              location.href = &quot;jsp/index.jsp&quot;;
          &#125;
      &#125;)               -------------------callback
                  
                  
      
  格式：    
  jQuery.post( url, [data], [callback], [type]
</code></pre>
</li>
</ul>
<h3 id="JSP中java代码获取路径"><a href="#JSP中java代码获取路径" class="headerlink" title="JSP中java代码获取路径"></a>JSP中java代码获取路径</h3><ul>
<li><p>获取路径</p>
<pre><code>  &lt;%
      String path = request.getContextPath();
      String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + path + &quot;/&quot;;
  %&gt;
  
  得到结果：
  http://localhost:8090/
</code></pre>
</li>
</ul>
<h2 id="自动跳转链接（定时）"><a href="#自动跳转链接（定时）" class="headerlink" title="自动跳转链接（定时）"></a>自动跳转链接（定时）</h2><ul>
<li><p>自动跳转</p>
<pre><code>  &lt;!DOCTYPE html&gt;  
  &lt;html&gt;  
  &lt;head&gt;  
      &lt;meta charset=&quot;utf-8&quot;&gt;  
  &lt;/head&gt;  
  &lt;script type=&quot;text/javascript&quot;&gt;   
    
  function toDiscuz()&#123;  
      document.getElementById(&quot;sp&quot;).click();  
  &#125;  
  &lt;/script&gt;   
  &lt;body onload=&quot;toDiscuz()&quot;&gt;  
      &lt;a href=&quot;https://www.baidu.com&quot;&gt;&lt;span id=&quot;sp&quot;&gt;自动点击&lt;/span&gt;&lt;/a&gt;  
  &lt;/body&gt;  
  &lt;/html&gt;
  
</code></pre>
</li>
<li><p>定时3秒后自动跳转</p>
<pre><code>  将&lt;body onload=&quot;toDiscuz()&quot;&gt; 
  改为：
  &lt;body onload=setTimeout(&quot;toDiscuz(&#39;run&#39;,&#39;1&#39;)&quot;,3000)&gt;
  
</code></pre>
</li>
<li><p>bootstrap小窗口弹窗变灰无法操作</p>
<p>  更改bootstrap.js源码：</p>
<pre><code>  在 .appendTo(this.$body 添加后 .find(&#39;.contentIndex&#39;)
  改成：
  .appendTo(this.$body.find(&#39;.contentIndex&#39;))
</code></pre>
</li>
</ul>
<h2 id="根据身份号码计算年龄"><a href="#根据身份号码计算年龄" class="headerlink" title="根据身份号码计算年龄"></a>根据身份号码计算年龄</h2><ul>
<li><p>年龄</p>
<pre><code>  //计算年龄函数
  function GetAge(identityCard) &#123;
      var len = (identityCard + &quot;&quot;).length;
      if (len == 0) &#123;
          return 0;
      &#125; else &#123;
          if ((len != 15) &amp;&amp; (len != 18))//身份证号码只能为15位或18位其它不合法
          &#123;
              return 0;
          &#125;
      &#125;
      var strBirthday = &quot;&quot;;
      if (len == 18)//处理18位的身份证号码从号码中得到生日和性别代码
      &#123;
          strBirthday = identityCard.substr(6, 4) + &quot;/&quot; + identityCard.substr(10, 2) + &quot;/&quot; + identityCard.substr(12, 2);
      &#125;
      if (len == 15) &#123;
          strBirthday = &quot;19&quot; + identityCard.substr(6, 2) + &quot;/&quot; + identityCard.substr(8, 2) + &quot;/&quot; + identityCard.substr(10, 2);
      &#125;
      //时间字符串里，必须是“/”
      var birthDate = new Date(strBirthday);
      var nowDateTime = new Date();
      var age = nowDateTime.getFullYear() - birthDate.getFullYear();
      //再考虑月、天的因素;.getMonth()获取的是从0开始的，这里进行比较，不需要加1
      if (nowDateTime.getMonth() &lt; birthDate.getMonth() || (nowDateTime.getMonth() == birthDate.getMonth() &amp;&amp; nowDateTime.getDate() &lt; birthDate.getDate())) &#123;
          age--;
      &#125;
      return age;
  &#125;
  
  //赋值
  document.getElementById(&#39;realAge&#39;).innerText=age;    
</code></pre>
</li>
</ul>
<h2 id="待续…"><a href="#待续…" class="headerlink" title="待续…"></a>待续…</h2>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>随机数</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础 </title>
    <url>/2017/05/04/Java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><ul>
<li><p>JVM介绍</p>
<p>  JVM是Java Virtual Machine（Java虚拟机）的缩写，</p>
<p>  JVM是一种用于<strong>计算设备的规范</strong>，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。</p>
<p>  Java虚拟机包括<strong>一套字节码指令集</strong>、<strong>一组寄存器</strong>、<strong>一个栈</strong>、<strong>一个垃圾回收堆</strong>和<strong>一个存储方法域</strong>。 </p>
<p>  JVM屏蔽了与具体操作系统平台相关的信息，使Java程序只需生成在Java虚拟机上运行的目标代码（字节码）,就可以在多种平台上不加修改地运行。</p>
<p>  JVM在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。</p>
<blockquote>
<p><a href="http://www.cnblogs.com/sunada2005/p/3577799.html">http://www.cnblogs.com/sunada2005/p/3577799.html</a></p>
</blockquote>
</li>
</ul>
<h2 id="equals与"><a href="#equals与" class="headerlink" title="equals与=="></a>equals与==</h2><ul>
<li><p>区别（20180401）</p>
<pre><code>  1）对于==，如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等； 
  如果作用于引用类型的变量，则比较的是所指向的对象的地址 

  2）对于equals方法，注意：equals方法不能作用于基本数据类型的变量 如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址； 
  诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。
  
</code></pre>
</li>
<li><p>示例：</p>
<blockquote>
<p><a href="https://www.nowcoder.com/questionTerminal/04fd8ddb19024dd0acd89bbff85c0a50">https://www.nowcoder.com/questionTerminal/04fd8ddb19024dd0acd89bbff85c0a50</a> </p>
</blockquote>
</li>
</ul>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><ul>
<li><p><strong>String字符串拼接方式，好处与不足</strong></p>
<pre><code>  1.+号直接拼接
  2.append()
  3.Format》》String.format(&quot;%s和%s一起LOL&quot;, new String[]&#123; &quot;小明&quot;, &quot;小强&quot;&#125;);
  4.StringBuilder

  stringBuilder效率高，不产生新的对象
  string对象操作的时候，总是产生新的对象，
  然后自动回收旧的对象(如果没用的话)，效率是比stringBuilder在原对象上进行操作来的低的
</code></pre>
<p>  参考链接:</p>
<blockquote>
<p><a href="http://www.cnblogs.com/gc2013/p/4351015.html">http://www.cnblogs.com/gc2013/p/4351015.html</a></p>
</blockquote>
</li>
<li><p><strong>String 对象</strong></p>
<p>  String对象是不可变的，你可以给一个String对象加任意多的别名。因为String对象具有只读特性，所以指向它的任何引用都不可能改变它的值。<br>  不可变性也会带来一定的效率问题。</p>
</li>
</ul>
<h2 id="http和https"><a href="#http和https" class="headerlink" title="http和https"></a>http和https</h2><ul>
<li><p><strong>http和https</strong></p>
<pre><code>  一、https协议需要到ca申请证书，一般免费证书很少，需要交费。 
  二、http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。 
  三、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 
  四、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、
  身份认证的网络协议，比http协议安全。
</code></pre>
</li>
</ul>
<h2 id="Java数据类型"><a href="#Java数据类型" class="headerlink" title="Java数据类型"></a>Java数据类型</h2><ul>
<li><p>基本数据类型（四类八种）</p>
<pre><code>  整型( byte short int long )
  浮点型( float double )
  字符型( char )
  布尔型( boolean )
</code></pre>
</li>
<li><p>引用数据类型</p>
<pre><code>  数组型 
  接口型 
  类类型
</code></pre>
</li>
<li><p><strong>数据类型图示</strong>(java数据类型.png)</p>
<p>  <img src="https://ws1.sinaimg.cn/large/e41482d9ly1fxtnqwui80j20f406xdhi.jpg"></p>
</li>
</ul>
<p>注意：byte,short,char都可以隐含转换为int，long不能转换为int</p>
<p>char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中可以存储汉字(未包含在unicode编码中的特殊汉字除外).<br>unicode编码占用两个字节，所以，char类型的变量也是占用两个字节。</p>
<h2 id="堆栈区域"><a href="#堆栈区域" class="headerlink" title="堆栈区域"></a>堆栈区域</h2><ul>
<li><p>成员变量存在于堆内存中，默认有初始值。</p>
</li>
<li><p>局部变量存在于栈内存中，没有默认初始值。</p>
</li>
<li><p>图解1(堆栈图解1.png)</p>
<p>  <img src="http://ogy57hyu6.bkt.clouddn.com/%E5%A0%86%E6%A0%88%E5%9B%BE%E8%A7%A31.png"></p>
</li>
<li><p>图解2(堆栈图解2.png)</p>
<p>  <img src="http://ogy57hyu6.bkt.clouddn.com/%E5%A0%86%E6%A0%88%E5%9B%BE%E8%A7%A32.png"></p>
</li>
</ul>
<h2 id="集合简单总结"><a href="#集合简单总结" class="headerlink" title="集合简单总结"></a>集合简单总结</h2><ul>
<li>常用总结比较(集合总结2.png)</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/e41482d9ly1fxtnx6rf3oj21je0qoacj.jpg"></p>
<p><strong>由此可得，HashMap可以存储一个key为null,多个value为null的键值对。</strong></p>
<h2 id="Collection和Map框架结构"><a href="#Collection和Map框架结构" class="headerlink" title="Collection和Map框架结构"></a>Collection和Map框架结构</h2><ul>
<li>比较常用的Collection子类与Map子类简图(Collection和Map框架结构.png)</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/e41482d9ly1fxtnyfxfafj20l308mglr.jpg"></p>
<h2 id="泛型与容器的关系"><a href="#泛型与容器的关系" class="headerlink" title="泛型与容器的关系"></a>泛型与容器的关系</h2><p><strong>容器</strong>，即:存对象的地方，当把对象存进容器中时，就转变成了Object类型的对象，那么在取出对象元素时，就需要做类型转换(向下转换)，那么就可能发生类型转换异常(ClassCastException)，这个时候，如果有一种约束，来确保存进去的是一种具体类型，那么取出时就不用再做类型转换的工作了，那么也就可以有效防止类型转换异常的出现了，那么这种约束，就是java中的泛型，一种对容器概念的有效补充。</p>
<h2 id="简单的容器分类"><a href="#简单的容器分类" class="headerlink" title="简单的容器分类"></a>简单的容器分类</h2><ul>
<li><p>分类图(简单的容器分类.png)</p>
<p>  <img src="https://ws1.sinaimg.cn/large/e41482d9ly1fxtnz6zcvtj20he08ymxo.jpg"></p>
</li>
</ul>
<hr>
<h2 id="接口类型的子类对象的意义"><a href="#接口类型的子类对象的意义" class="headerlink" title="接口类型的子类对象的意义"></a>接口类型的子类对象的意义</h2><ul>
<li><p>多态的体现(接口类型的子类对象的意义.png)</p>
<p>  <img src="https://ws1.sinaimg.cn/large/e41482d9ly1fxto0atkzgj20mc051t9c.jpg"></p>
</li>
</ul>
<h2 id="LinkedList与ArrayList"><a href="#LinkedList与ArrayList" class="headerlink" title="LinkedList与ArrayList"></a>LinkedList与ArrayList</h2><ul>
<li><p><strong>LinkedList</strong></p>
<p>  LinkedList底层是由双向循环链表实现，里面的数据在逻辑上的存储是连续的，连续自然也就有顺序了</p>
</li>
<li><p><strong>LinkedList与ArrayList的比较</strong></p>
<p>  LinkedList也像ArrayList一样实现了基本的List接口，但是它执行某些操作时比ArrayList更高效（在List的中间插入和移除），但在随机访问操作方面却要逊色一些。</p>
<p>  ArrayList底层的实现是数组，所以用下标访问的速度比较快，但是插入和删除元素，会有移动元素的开销，所以速度比LinkedList差。<br>  LikedList底层是链表实现的，所以插入和删除元素时间复杂度较LinkedList好，但是随即访问需要遍历元素，所以效率比ArrayList差</p>
</li>
</ul>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set不保存重复元素</p>
<h2 id="Iterator与Iterable"><a href="#Iterator与Iterable" class="headerlink" title="Iterator与Iterable"></a>Iterator与Iterable</h2><ul>
<li><p>不同的包</p>
<p>  java.lang.Iterable </p>
<p>  java.util.Iterator </p>
</li>
</ul>
<h2 id="数组增加元素"><a href="#数组增加元素" class="headerlink" title="数组增加元素"></a>数组增加元素</h2><ul>
<li><p>数组是定长，需要用Arrays.asList转换为List,再转换为ArrayList才能进行写操作</p>
<pre><code>  String[] arr = new String[2];
  arr[0] = &quot;1&quot;;
  arr[1] = &quot;2&quot;;
  List&lt;String&gt; listArr = new ArrayList&lt;&gt;(Arrays.asList(arr));
  listArr.add(2,&quot;5&quot;);
</code></pre>
</li>
</ul>
<h2 id="java-Native-方法"><a href="#java-Native-方法" class="headerlink" title="java Native 方法"></a>java Native 方法</h2><ul>
<li><p><strong>native方法</strong></p>
<p>  native关键字说明其修饰的方法是一个原生态方法，方法对应的实现不是在当前文件，而是在用其他语言（如C和C++）实现的文件中。Java语言本身不能对操作系统底层进行访问和操作，但是可以通过JNI接口调用其他语言来实现对底层的访问。</p>
</li>
<li><p><strong>JNI</strong></p>
<p>  JNI是Java本机接口（Java Native Interface），是一个本机编程接口，它是Java软件开发工具箱（Java Software Development Kit，SDK）的一部分。JNI允许Java代码使用以其他语言编写的代码和代码库。Invocation API（JNI的一部分）可以用来将Java虚拟机（JVM）嵌入到本机应用程序中，从而允许程序员从本机代码内部调用Java代码。</p>
</li>
<li><p><strong>Object是抽象类吗？</strong></p>
<p>  查看Object源码可以看到，许多方法是没有实现体的，但是Object类并不是抽象类，因为这些没有方法体的方法用Native修饰，其实现体并不是java语言写的。</p>
</li>
</ul>
<h2 id="引用传递与值传递"><a href="#引用传递与值传递" class="headerlink" title="引用传递与值传递"></a>引用传递与值传递</h2><ul>
<li><p>引用传递与值传递</p>
<p>  JAVA里除了8种基本类型传参数是值传递，其他的类对象传参数都是引用传递</p>
</li>
</ul>
<h2 id="java中的编译时类型和运行时类型"><a href="#java中的编译时类型和运行时类型" class="headerlink" title="java中的编译时类型和运行时类型"></a>java中的编译时类型和运行时类型</h2><ul>
<li><p>运行时类型与编译时类型</p>
<p>  Java中的许多对象（一般都是具有父子类关系的父类对象）在运行时都会出现两种类型：编译时类型和运行时类型，例如：Person person = new Student();这行代码将会生成一个person变量，该变量的编译时类型是Person，运行时类型是Student。</p>
<p>   Java的引用变量有两个类型，一个是编译时类型，一个是运行时类型，编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。如果编译时类型和运行时类型不一致，会出现所谓的多态</p>
</li>
</ul>
<h2 id="jdk打包与解压"><a href="#jdk打包与解压" class="headerlink" title="jdk打包与解压"></a>jdk打包与解压</h2><ul>
<li><p>打包命令</p>
<pre><code>  jar -cvf diaowen.war diaowen
</code></pre>
</li>
<li><p>解压命令</p>
<pre><code>  jar xvf diaowen.war
</code></pre>
</li>
</ul>
<h2 id="多个数组-lit遍历分别赋值到实体类的属性"><a href="#多个数组-lit遍历分别赋值到实体类的属性" class="headerlink" title="多个数组/lit遍历分别赋值到实体类的属性"></a>多个数组/lit遍历分别赋值到实体类的属性</h2><ul>
<li><p>数组操作(List一样原理)</p>
<pre><code>  String[] opinionUserList = opinionUser.split(&quot;###&quot;);
  String[] opinionContentList = opinionContent.split(&quot;###&quot;);
  String[] deptList = dept.split(&quot;###&quot;);
  if (opinionUserList != null &amp;&amp; opinionUserList.length &gt; 1) &#123;
      for (int i = 0; i &lt; opinionUserList.length; i++) &#123;
          DocOpinion des = new DocOpinion();
          //属性拷贝
          BeanUtils.copyProperties(docOpinion, des);
          
          des.setOpinionUser(opinionUserList[i]);
          des.setOpinionContent(opinionContentList[i]);
          des.setOpinionDept(deptList[i]);
          
          //其他值(在if外层已经获取到值了)
          des.setOpinionCode(code);
          des.setOpinionCodeName(codeName);

          des.setStatus(&quot;0&quot;);
          des.setSystemNo(&quot;ROOT&quot;);
         
          //数据插入
          docOpinionMng.insertDocOpinion(des);
  &#125;
</code></pre>
</li>
</ul>
]]></content>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java进阶</title>
    <url>/2017/05/15/Java%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><ul>
<li>spring3和spring4的架构图对比</li>
</ul>
<p><strong>spring3结构图：</strong></p>
<blockquote>
<p><img src="http://op05inpyd.bkt.clouddn.com/spring3%E6%9E%B6%E6%9E%84%E5%9B%BE.png"></p>
</blockquote>
<p><strong>spring4架构图：</strong></p>
<blockquote>
<p><img src="http://op05inpyd.bkt.clouddn.com/spring4%E6%9E%B6%E6%9E%84%E5%9B%BE.png"></p>
</blockquote>
<ul>
<li>Spring4架构解析</li>
</ul>
<p>Spring4的5层架构</p>
<pre><code>1.core
2.aop
3.data access
4.web
5.test
</code></pre>
<p>下载spring4的jar包将其归类：</p>
<ul>
<li><p>1.core Container部分包含4个模块（spring核心容器）</p>
<pre><code>  spring-core：依赖注入IoC与DI的最基本实现
  spring-beans：Bean工厂与bean的装配
  spring-context：spring的context上下文即IoC容器
  spring-context-support：spring额外支持包，比如邮件服务、视图解析等
  spring-expression：spring表达式语言
</code></pre>
</li>
</ul>
<ul>
<li><p>2.aop部分包含5个模块(AOP &amp; Instrumentation &amp; Messaging)</p>
<pre><code>  spring-aop：面向切面编程
  spring-aspects：集成AspectJ
  spring-instrument：提供一些类级的工具支持和ClassLoader级的实现，用于服务器
  spring-instrument-tomcat：针对tomcat的instrument实现
  spring-messaging：用于构建基于消息的应用程序
</code></pre>
</li>
</ul>
<ul>
<li><p>3.data access部分包含5个模块</p>
<pre><code>  spring-jdbc：jdbc的支持
  spring-tx：事务控制
  spring-orm：对象关系映射，集成orm框架
  spring-oxm：对象xml映射
  spring-jms：java消息服务
</code></pre>
</li>
<li><p>4.web部分包含4个模块</p>
<pre><code>  spring-web：基础web功能，如文件上传
  spring-webmvc：mvc实现
  spring-webmvc-portlet：基于portlet的mvc实现
  spring-websocket：为web应用提供的高效通信工具
</code></pre>
</li>
<li><p>5.test部分只有一个模块，将spring-context-support也放在这吧</p>
<p>  spring-test：spring测试，提供junit与mock测试功能</p>
</li>
<li><p><strong>注：</strong></p>
<p>  org.springframework.beans和org.springframework.context包是Spring框架IoC容器的基础</p>
</li>
</ul>
<p>注：摘自以下地址&gt; </p>
<p>1.博客</p>
<blockquote>
<p><a href="http://www.cnblogs.com/ywlaker/p/6136625.html">http://www.cnblogs.com/ywlaker/p/6136625.html</a></p>
</blockquote>
<p>2.spring官方文档</p>
<blockquote>
<p><a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/index.html">http://docs.spring.io/spring/docs/current/spring-framework-reference/html/index.html</a></p>
</blockquote>
<p>查看各个jar的以来关系，请访问上述地址。</p>
<h2 id="Maven的BOM清单统一管理spring版本"><a href="#Maven的BOM清单统一管理spring版本" class="headerlink" title="Maven的BOM清单统一管理spring版本"></a>Maven的BOM清单统一管理spring版本</h2><pre><code>&lt;!--统一spring各组件的版本--&gt;
&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-framework-bom&lt;/artifactId&gt;
            &lt;version&gt;4.3.10.RELEASE&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
             &lt;!--继承一个父模块，然后再引入相应的依赖--&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;

&lt;dependencies&gt;
    &lt;!--junit--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;3.8.1&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;

    &lt;!--spring-context(IOC容器)--&gt;
    &lt;!--由于上面统一管理了spring的版本，因此此处不必指定context的版本--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
    &lt;/dependency&gt;

&lt;/dependencies&gt;
</code></pre>
<h2 id="剔除commons-logging使用log4j"><a href="#剔除commons-logging使用log4j" class="headerlink" title="剔除commons-logging使用log4j"></a>剔除commons-logging使用log4j</h2><pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
        &lt;version&gt;4.1.3.RELEASE&lt;/version&gt;
        &lt;exclusions&gt;
            &lt;!--排除commons-logging--&gt;
            &lt;exclusion&gt;
                &lt;groupId&gt;commons-logging&lt;/groupId&gt;
                &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;
            &lt;/exclusion&gt;
        &lt;/exclusions&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
        &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;
        &lt;version&gt;1.5.8&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
        &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
        &lt;version&gt;1.5.8&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
        &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
        &lt;version&gt;1.5.8&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;log4j&lt;/groupId&gt;
        &lt;artifactId&gt;log4j&lt;/artifactId&gt;
        &lt;version&gt;1.2.14&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><pre><code>该接口org.springframework.context.ApplicationContext代表Spring IoC容器,并负责实例化，配置和组装上述bean
</code></pre>
<h2 id="ApplicationContext，BeanFactory，-IOC-的关系"><a href="#ApplicationContext，BeanFactory，-IOC-的关系" class="headerlink" title="ApplicationContext，BeanFactory， IOC 的关系"></a>ApplicationContext，BeanFactory， IOC 的关系</h2><ul>
<li><p><strong>关系</strong></p>
<p>  ApplicationContext是比Beanfactory更加先进的IOC容器的一种实现</p>
</li>
<li><p><strong>ApplicationContext类型容器提供的集中实现</strong></p>
<p>  FileSystemXmlApplicationContext：从文件中加载bean定义以及相关资源的ApplicationContext实现。</p>
<p>  ClassPathXmlApplicatonContext：从Classpath加载bean定义以及相关资源的Applicationcontext的实现。</p>
<p>  XmlWebApplicationContext：用于web应用程序的ApplicationContext的实现。</p>
</li>
<li><p><strong>ApplicationContext与BeanFactory的联系</strong></p>
<p>  接口ApplicationContext继承了ListableBeanFactory和HierarchicalBeanFactory这两个接口，<br>  而这两个接口都是继承自BeanFactory接口，BeanFactory接口中有方法getBean(),返回类型为Object.</p>
</li>
</ul>
<blockquote>
<p><a href="http://www.cnblogs.com/Qbright/archive/2012/07/18/2597184.html">http://www.cnblogs.com/Qbright/archive/2012/07/18/2597184.html</a></p>
</blockquote>
<h2 id="beans"><a href="#beans" class="headerlink" title="beans"></a>beans</h2><p>javaBeans,POJOs和spring bean</p>
<ul>
<li><p>javaBeans:</p>
<p>  包含默认（无参数）的构造函数<br>  允许通过访问器(getter和setter方法)来访问类的成员属性<br>  实现java.io.Serializable接口</p>
</li>
<li><p>POJO</p>
<p>  POJO是 Plain Old Java Object（简单的Java对象）的缩写,作为一种花式的对普通Java对象的称呼.</p>
</li>
<li><p>Spring beans</p>
<p>  Spring bean 表示受到Spring管理的对象。具体说来，它是被Spring框架容器初始化、配置和管理的对象</p>
<p>  每一个Bean对应Spring容器里的一个Java实例，定义Bean时通常需要指定两个属性。</p>
<p>  在Spring中，被Spring IoC 容器 管理的这些来自于应用主干的这些对象称作 beans 。bean是一个由Spring IoC容器进行实例化、装配和管理的对象。此外，bean只是你应用中许多对象中的一个</p>
</li>
</ul>
<h2 id="spring常用注解（annotation）"><a href="#spring常用注解（annotation）" class="headerlink" title="spring常用注解（annotation）"></a>spring常用注解（annotation）</h2><blockquote>
<p><a href="http://www.cnblogs.com/xiaoxi/p/5935009.html">http://www.cnblogs.com/xiaoxi/p/5935009.html</a></p>
</blockquote>
<ul>
<li><p>常用</p>
<pre><code>  @Component:@Component是所有受Spring 管理组件的通用形式，@Component注解可以放在类的头上，@Component不推荐使用。
  @Controller:@Controller对应表现层的Bean，也就是Action。
      @Controller注解标识UserAction之后，就表示要把UserAction交给Spring容器管理，在Spring容器中会存在一个名字为&quot;userAction&quot;的action。
      这里的UserAction还使用了@Scope注解，spring 默认scope 是单例模式(scope=&quot;singleton&quot;)，这样只会创建一个Action对象，每次访问都是同一Action对象，数据不安全，struts2 是要求每次次访问都对应不同的Action，scope=&quot;prototype&quot; 可以保证当有请求的时候都创建一个Action对象。
  @Service:@Service对应的是业务层Bean
  @Repository:@Repository对应数据访问层Bean
  @Autowired：自动装配，其作用是为了消除代码Java代码里面的getter/setter与bean属性中的property
      @Autowired 默认按类型装配，如果我们想使用按名称装配，可以结合@Qualifier注解一起使用。如下：
      @Autowired @Qualifier(&quot;personDaoBean&quot;) 存在多个实例配合使用
  @Resource默认按名称装配，当找不到与名称匹配的bean才会按类型装配。
  @Scope(&quot;prototype&quot;)：Spring默认产生的bean是单例的，&quot;prototype&quot;表示原型即每次都会new一个新的出来。
  @Configuration把一个类作为一个IoC容器，它的某个方法头上如果注册了@Bean，就会作为这个Spring容器中的Bean。
</code></pre>
</li>
<li><p>一般</p>
<pre><code>  @Scope注解 作用域
  @Lazy(true) 表示延迟初始化
  @PostConstruct用于指定初始化方法（用在方法上）
  @PreDestory用于指定销毁方法（用在方法上）
  @DependsOn：定义Bean初始化及销毁时的顺序
  @Primary：自动装配时当出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常
  @PostConstruct 初始化注解
  @PreDestroy 摧毁注解 默认 单例  启动就加载
  @Async异步方法调用
</code></pre>
</li>
</ul>
<p>sqlSessionTemplate<br>sqlSessionFactory<br>sqlSessionTemplateBeanName<br>sqlSessionFactoryBeanName</p>
<h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><ul>
<li>待续…</li>
</ul>
<h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><ul>
<li>待续…</li>
</ul>
<h2 id="SSM简要概述"><a href="#SSM简要概述" class="headerlink" title="SSM简要概述"></a>SSM简要概述</h2><ul>
<li>概述<br><img src="http://op05inpyd.bkt.clouddn.com/SSM%E6%A6%82%E8%BF%B0.png"></li>
</ul>
]]></content>
      <tags>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title>Lombok参考手册</title>
    <url>/2018/05/23/Lombok%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h1 id="Lombok参考手册"><a href="#Lombok参考手册" class="headerlink" title="Lombok参考手册"></a>Lombok参考手册</h1><p><a href="https://projectlombok.org/">Lombok</a>是一个可以通过简单的注解形式来帮助我们简化消除一些必须有但显得臃肿的Java代码的工具，通过使用对应的注解，可以在编译源码的时候生成对应的方法。官方地址：<a href="https://projectlombok.org/">https://projectlombok.org/</a>，github项目地址：<a href="https://github.com/rzwitserloot/lombok">https://github.com/rzwitserloot/lombok</a>。</p>
<h2 id="lombok常用注解"><a href="#lombok常用注解" class="headerlink" title="lombok常用注解"></a>lombok常用注解</h2><p>使用lombok注解需要在项目中引用<code>lombok</code> jar包。</p>
<ul>
<li><code>@Data</code>：注解在类上；提供类所有属性的<code>getting</code>和<code>setting</code>方法，此外还提供了<code>equals</code>、<code>canEqual</code>、<code>hashCode</code> 、<code>toString</code> 方法</li>
<li><code>@Setter</code>：注解在属性上；为属性提供setting方法</li>
<li><code>@Getter</code>：注解在属性上；为属性提供getting方法</li>
<li><code>@Slf4j</code>：注解在类上；为类提供一个属性名为<code>log</code> 的<code>slf4j</code>日志对象</li>
<li><code>@NoArgsConstructor</code>：注解在类上：为类提供一个无参的构造方法</li>
<li><code>@AllArgsConstructor</code> ：注解在类上；为类提供一个全参的构造方法</li>
<li><code>@NonNull</code>：注解在参数上；如果该参数为null 会throw new NullPointerException(参数名);</li>
<li><code>@Cleanup</code>：注释在引用变量前，自动回收资源 默认调用close方法</li>
<li><code>@SneakyThrows</code> ：注解在方法上，为方法抛出指定异常</li>
</ul>
<p>样例如下：</p>
<p>使用lombok注解的java代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.*;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String country;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lockObj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="meta">@NonNull</span> String target)</span> </span>&#123;</span><br><span class="line">        String content = String.format(<span class="string">&quot;hello,%s&quot;</span>, target);</span><br><span class="line">        System.out.println(content);</span><br><span class="line">        log.info(content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBalabala</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        val list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows(IOException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeBalabala</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Cleanup</span> InputStream is = <span class="keyword">new</span> ByteArrayInputStream(<span class="string">&quot;hello world&quot;</span>.getBytes());</span><br><span class="line">        System.out.println(is.available());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等效于下面的这段java代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.beans.ConstructorProperties;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> lombok.NonNull;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(Something.class);</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String country;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lockObj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="meta">@NonNull</span> String target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;target&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String content = String.format(<span class="string">&quot;hello,%s&quot;</span>, <span class="keyword">new</span> Object[]&#123;target&#125;);</span><br><span class="line">            System.out.println(content);</span><br><span class="line">            log.info(content);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBalabala</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeBalabala</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(<span class="string">&quot;hello world&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(bis.available());</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(Collections.singletonList(bis).get(<span class="number">0</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    bis.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCountry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.country;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getLockObj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.lockObj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">canEqual</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> other <span class="keyword">instanceof</span> Something;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@ConstructorProperties(&#123;&quot;name&quot;, &quot;country&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Something</span><span class="params">(String name, String country)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.country = country;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="与IDE集成"><a href="#与IDE集成" class="headerlink" title="与IDE集成"></a>与IDE集成</h2><h3 id="与Eclipse集成"><a href="#与Eclipse集成" class="headerlink" title="与Eclipse集成"></a>与Eclipse集成</h3><p>第一步：下载<code>lombok.jar</code> 安装包</p>
<p> 下载地址：<a href="http://projectlombok.org/">http://projectlombok.org/</a></p>
<p>第二步： 与Eclipse集成</p>
<p>1、 将 lombok.jar 复制到<code>eclipse.ini</code>所在的文件夹目录下<br>2、 打开 <code>eclipse.ini</code> ，在最后面插入以下两行并保存：<br>           -Xbootclasspath/a:lombok.jar<br>           -javaagent:lombok.jar<br>3、 重启<code>eclipse</code> 。</p>
<h3 id="与IntelliJ-IDEA集成"><a href="#与IntelliJ-IDEA集成" class="headerlink" title="与IntelliJ IDEA集成"></a>与IntelliJ IDEA集成</h3><p>第一步：安装lombok插件</p>
<p>方式一，通过Plugins安装</p>
<p>打开IDEA，<code>Settings</code>  -&gt;  <code>Plugin</code>，在搜索框中输入<code>lombok plugin</code> ，根据提示安装，安装后重启即可。</p>
<p>方式二，下载安装包安装</p>
<p>下载lombok插件，下载地址为：<a href="https://github.com/mplushnikov/lombok-intellij-plugin/releases">https://github.com/mplushnikov/lombok-intellij-plugin/releases</a> ;</p>
<p><code>Plugin</code> -&gt; <code>Install plugin from disk...</code> ，选择下载的zip包安装，安装后重启即可;</p>
<p>第二步：<code>Enable annotation processing</code></p>
<p><code>Settings -&gt; Build,Exectution,Deployment</code> -&gt; <code>Compiler</code> -&gt; <code>Annotation Processors</code> ，勾选<code>Enable annotation processing</code> ，点击<code>apply</code> 保存，重启后即可使用<code>lombok</code> 注解编码了。</p>
]]></content>
      <tags>
        <tag>lombok</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven相关</title>
    <url>/2016/11/19/Maven%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h2 id="maven简介"><a href="#maven简介" class="headerlink" title="maven简介"></a>maven简介</h2><pre><code>1.maven可以很方便的管理项目依赖关系。
2.maven可以伴随整个项目生命周期，关于这一点，下面Maven命令中可窥见一斑。
</code></pre>
<h2 id="maven安装配置"><a href="#maven安装配置" class="headerlink" title="maven安装配置"></a>maven安装配置</h2><p><strong>1.windows下配置环境变量：</strong></p>
<pre><code>M2_HOME
F:\apache-maven-3.5.0

在path下追加：
%M2_HOME%\bin;

查看maven版本以及验证环境变量是否配置成功：
cmd下  mvn -version

maven默认依赖包下载存放位置：
C:\Users\UX\.m2
</code></pre>
<p><strong>2.自定义修改：</strong></p>
<pre><code>将F:\apache-maven-3.5.0\conf下的settings.xml复制到C:\Users\UX\.m2的.m2文件夹下
做出下列两项修改：
</code></pre>
<p>1.修改为官方推荐的仓库中心：</p>
<p>配置文件：</p>
<blockquote>
<p><a href="http://op05inpyd.bkt.clouddn.com/settings.xml">http://op05inpyd.bkt.clouddn.com/settings.xml</a></p>
</blockquote>
<pre><code>&lt;mirror&gt;
  &lt;id&gt;UK&lt;/id&gt;
  &lt;name&gt;UK Central&lt;/name&gt;
  &lt;url&gt;http://uk.maven.org/maven2&lt;/url&gt;
  &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;
&lt;/mirror&gt;

或者改为阿里的：

&lt;mirror&gt;
  &lt;id&gt;alimaven&lt;/id&gt;
  &lt;name&gt;aliyun maven&lt;/name&gt;
  &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;
  &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;        
&lt;/mirror&gt;
</code></pre>
<p>2.自定义依赖包下载到本地的存放位置：</p>
<pre><code>&lt;localRepository&gt;F:\MavenRepository\repository
&lt;/localRepository&gt;
</code></pre>
<hr>
<h2 id="Maven命令"><a href="#Maven命令" class="headerlink" title="Maven命令"></a>Maven命令</h2><p><strong>1.maven基本命令：</strong></p>
<pre><code>mvn -v    查看maven版本信息
mvn compile  编译项目
mvn test 测试
mvn package  打包项目
mvn clean 删除target
mvn install 将本项目安装到本地仓库中
</code></pre>
<p><strong>2.名词解释：</strong><br>     groupId：   组织名，一般是公司网站的反写+项目名<br>     artifactId：  项目名-模块名<br>     version：  版本号<br>     -Dpackage： 代码所在的包名</p>
<p><strong>3.使用maven创建模板项目：</strong></p>
<pre><code>例如：
mvn archetype:generate -DgroupId=com.ux.mavenproject -DartifactId=mavenproject-demo -Dversion=1.0.0SNAPSHOT -Dpackage=com.ux.mavenproject.demo -DarchetypeCatalog=internal

回车
回车
Y
</code></pre>
<h2 id="创建maven项目时的参数"><a href="#创建maven项目时的参数" class="headerlink" title="创建maven项目时的参数"></a>创建maven项目时的参数</h2><ul>
<li>添加此参数可快速创建maven项目，避免下载缓慢问题<pre><code>  archetypeCatalog=internal
</code></pre>
</li>
</ul>
<h2 id="mac下安装maven"><a href="#mac下安装maven" class="headerlink" title="mac下安装maven"></a>mac下安装maven</h2><ul>
<li><p>mac下安装maven</p>
<pre><code>  export M2_HOME=/Users/ux/Applications/apache-maven-3.5.2
  export PATH=$PATH:$M2_HOME/bin
  
  source ~/.bash_profile
</code></pre>
</li>
</ul>
<h2 id="Maven-依赖搜索顺序"><a href="#Maven-依赖搜索顺序" class="headerlink" title="Maven 依赖搜索顺序"></a>Maven 依赖搜索顺序</h2><ul>
<li><p>当我们执行 Maven 构建命令时，Maven 开始按照以下顺序查找依赖的库：</p>
<ul>
<li><p>步骤 1 － 在本地仓库中搜索，如果找不到，执行步骤 2，如果找到了则执行其他操作。</p>
</li>
<li><p>步骤 2 － 在中央仓库中搜索，如果找不到，并且有一个或多个远程仓库已经设置，则执行步骤 4，如果找到了则下载到本地仓库中已被将来引用。</p>
</li>
<li><p>步骤 3 － 如果远程仓库没有被设置，Maven 将简单的停滞处理并抛出错误（无法找到依赖的文件）。</p>
</li>
<li><p>步骤 4 － 在一个或多个远程仓库中搜索依赖的文件，如果找到则下载到本地仓库已被将来引用，否则 Maven 将停止处理并抛出错误（无法找到依赖的文件）。    </p>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>NoSQL相关</title>
    <url>/2018/02/13/NoSQL%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h2 id="NoSQL概念"><a href="#NoSQL概念" class="headerlink" title="NoSQL概念"></a>NoSQL概念</h2><ul>
<li>概念</li>
</ul>
<p>NoSQL即 Not Only SQL,泛指 非关系型数据库。</p>
<h2 id="NoSQL存在的条件"><a href="#NoSQL存在的条件" class="headerlink" title="NoSQL存在的条件"></a>NoSQL存在的条件</h2><ul>
<li><p>为什么需要NoSQL</p>
<ul>
<li>High Performance 高并发读写</li>
<li>Huge Storage 海量数据的高效存储和访问</li>
<li>High Scalability &amp;&amp; High Availability 高可扩展性和高可用性</li>
</ul>
<p>  这些对于关系型数据库都是比较有很大的局限性的，但是对于非关系型数据库而言却是其优点。</p>
</li>
</ul>
<h2 id="NoSQL的特点总结"><a href="#NoSQL的特点总结" class="headerlink" title="NoSQL的特点总结"></a>NoSQL的特点总结</h2><ul>
<li><p>主要特点</p>
<ul>
<li>易扩展（数据之间没有关系，容易扩展）</li>
<li>灵活的数据模型（不需要像关系型数据库那样事先建立要存储的字段）</li>
<li>大数据量，高性能（读写性能很高）</li>
<li>高可用（在不影响性能的情况下实现高可用的框架）</li>
</ul>
</li>
</ul>
<h2 id="NoSQL主流产品"><a href="#NoSQL主流产品" class="headerlink" title="NoSQL主流产品"></a>NoSQL主流产品</h2><ul>
<li><p>主流产品</p>
<ul>
<li>Redis</li>
<li>mongoDB</li>
<li>membase</li>
<li>CouchDB</li>
<li>Cassandra</li>
</ul>
</li>
</ul>
<p> 其中Redis和mongoDB比较常见</p>
<h2 id="NoSQL分类"><a href="#NoSQL分类" class="headerlink" title="NoSQL分类"></a>NoSQL分类</h2><ul>
<li><p>分类</p>
<ul>
<li>键值(Key-Value)存储(如：Redis，优势是快速查询；劣势是存储的数据缺少结构化)</li>
<li>列存储（优势是快速查询、扩展性也比较强；劣势是功能相对局限）</li>
<li>文档数据库（如：mongoDB，优势是数据结构要求不是很严格；劣势是查询性能不是很好，而且缺少统一的查询语法）</li>
<li>图形数据库（典型的应用是社交网络，优势是利用图结构相关算法；劣势是需要对整个图做计算才能得出结果，不容易做分布式的集群方案）</li>
</ul>
</li>
</ul>
<h2 id="Redis相关"><a href="#Redis相关" class="headerlink" title="Redis相关"></a>Redis相关</h2><h3 id="Redis概述"><a href="#Redis概述" class="headerlink" title="Redis概述"></a>Redis概述</h3><ul>
<li><p>Redis概述</p>
<ul>
<li>Redis是开源的，知乎、新浪微博、Github都在使用Redis</li>
<li>C语言开发的</li>
<li>高性能的键值对数据库</li>
<li>官方测试读写性能：读,11w次/s ; 写,8w次/s</li>
</ul>
</li>
<li><p><strong>Redis支持的键值数据类型</strong></p>
<ul>
<li>字符串类型</li>
<li>列表类型</li>
<li>有序集合类型</li>
<li>散列类型</li>
<li>集合类型</li>
</ul>
</li>
<li><p><strong>Redis应用场景</strong></p>
<ul>
<li><strong>缓存</strong>（最主要的应用场景，比如数据的查询：新闻，商品的内容放入到缓存当中）</li>
<li>任务队列（秒杀，抢购）</li>
<li>网站访问统计</li>
<li>数据过期处理（可以精确到毫秒）</li>
<li>分布式集群架构中的session分离</li>
</ul>
</li>
<li><p>查看redis服务是否已经启动命令</p>
<p>  ps -ef | grep -i redis</p>
<pre><code>  ps   将某个进程显示出来
  -A 　显示所有程序。 
  -e 　此参数的效果和指定&quot;A&quot;参数相同。
  -f 　显示UID,PPIP,C与STIME栏位。 
  grep命令是查找
  中间的|是管道命令 是指ps命令与grep同时执行
  这条命令的意思是显示有关redis有关的进程
</code></pre>
</li>
</ul>
<p>UID  PID  PPID  C  STIME  TTY  TIME  CMD</p>
<p>各相关信息的意义</p>
<pre><code>daemonize：守护进程
</code></pre>
<ul>
<li>redis服务启动/关闭命令<br>  进入redis安装目录：<br>  cd redisLocation<br>  启动服务：<br>  ./bin/redis-server ./redis.config<br>  关闭服务：<br>  ./bin/redis-cli shutdowm</li>
</ul>
<h3 id="jedis"><a href="#jedis" class="headerlink" title="jedis"></a>jedis</h3><ul>
<li><p>jedis概念</p>
<p>  jedis是redis官方首选的java客户端开发包</p>
<blockquote>
<p><a href="https://github.com/xetorthio/jedis">https://github.com/xetorthio/jedis</a>    </p>
</blockquote>
</li>
<li><p>linux下设置redis防火墙端口</p>
</li>
</ul>
<p>vim /etc/sysconfig/iptables<br>加6389端口</p>
<h2 id="简单罗列"><a href="#简单罗列" class="headerlink" title="简单罗列"></a>简单罗列</h2><p>NoSQL(非关系型数据库):</p>
<p>redis：key/value键值对存储数据库</p>
<p>mongodb:文档型数据库</p>
<p>hbase：列式数据库</p>
<p>neo4j：图式数据库，存储的是图关系而非行或列。主要用于社交网络的存储。</p>
<p>redis数据结构: String Hash Set SortedSet List </p>
<p>redis事务:multi exec discard</p>
<p>redis 持久化: rdb内存快照 aof命令日志</p>
]]></content>
      <tags>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis</title>
    <url>/2018/01/08/MyBatis/</url>
    <content><![CDATA[<h2 id="mybatis使用过程中问题集"><a href="#mybatis使用过程中问题集" class="headerlink" title="mybatis使用过程中问题集"></a>mybatis使用过程中问题集</h2><h3 id="多个参数时需要参数绑定"><a href="#多个参数时需要参数绑定" class="headerlink" title="多个参数时需要参数绑定"></a>多个参数时需要参数绑定</h3><ul>
<li><p>Dao接口进行参数绑定</p>
<p>  异常信息：</p>
<pre><code>  HTTP Status 500 - Request processing failed; nested exception is 
  org.mybatis.spring.MyBatisSystemException: nested exception is 
  org.apache.ibatis.binding.BindingException: Parameter 
  &#39;acceptPersonId&#39; not found. Available parameters are [1, 0, param1, param2]
  
</code></pre>
<p>  解决方案：</p>
<pre><code>  DAO层中传递参数时加@Param(&quot;acceptPersonId&quot;)，如下：
  
  List&lt;Message&gt; selectByUser(@Param(&quot;acceptPersonId&quot;) String acceptPersonId, @Param(&quot;status&quot;) String status);
  
  多个参数时加@Param(&quot;acceptPersonId&quot;)，单个参数可以直接selectByUser(String acceptPersonId);
</code></pre>
</li>
</ul>
<h3 id="mybatis与in查询"><a href="#mybatis与in查询" class="headerlink" title="mybatis与in查询"></a>mybatis与in查询</h3><ul>
<li>mybatis中如何使用in查询<pre><code>    &lt;!--String[] getddUserIds(Integer[] userId);  --&gt;  
    &lt;select id=&quot;getddUserIds&quot; parameterType=&quot;integer&quot; resultType=&quot;string&quot;&gt;  
          select ddUserId from user where userId in  
          &lt;foreach collection=&quot;array&quot;   
              open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot; item=&quot;userId&quot; index=&quot;index&quot;&gt;  
              #&#123;userId&#125;  
          &lt;/foreach&gt;  
    &lt;/select&gt;  
</code></pre>
</li>
</ul>
<h3 id="mybatis查询结果与SQL查询字段不一致"><a href="#mybatis查询结果与SQL查询字段不一致" class="headerlink" title="mybatis查询结果与SQL查询字段不一致"></a>mybatis查询结果与SQL查询字段不一致</h3><ul>
<li><p>SQL中查询的字段在经过mybatis处理后的查询结果中没有</p>
<p>  例如属性名为pId，但是编辑器生成getter/setter方法时生成的是setpId和setpId<br>  这就导致在某些版本（比如3.1.0版本）的mybatis中无法将pId的值与SQL中的值匹配，将getter/setter改为setPId和setPId即可：</p>
<pre><code>  private String pId;
   
  public String getPId() &#123;
      return pId;
  &#125;

  public void setPId(String pId) &#123;
      this.pId = pId;
  &#125;

  &lt;!--查询组织机构数据--&gt;
  &lt;select id=&quot;selectOrg&quot; resultType=&quot;com.union.Management.bean.Org&quot;&gt;
      select a.DepartID as id,IFNULL(a.ParentID,0) as pid,a.DepartName as name
      from sys_domain as a
      order by a.ruleid
  &lt;/select&gt;
</code></pre>
</li>
</ul>
<h3 id="字段为空时不更新该字段"><a href="#字段为空时不更新该字段" class="headerlink" title="字段为空时不更新该字段"></a>字段为空时不更新该字段</h3><ul>
<li><p>使用条件判断</p>
<pre><code>  &lt;!--基本信息-更新--&gt;
  &lt;update id=&quot;updateBasicInfoById&quot; parameterType=&quot;com.union.Management.bean.PersonInfoDetailBasic&quot;&gt;
      UPDATE user_info AS a
      SET a.PersonName = #&#123;personName&#125;, a.Gender = #&#123;gender&#125;,a.DepartID=#&#123;departID&#125;
      ,a.Weight=#&#123;weight&#125;,a.IdentityCard=#&#123;identityCard&#125;,a.Nation=#&#123;nation&#125;,a.MobileNo=#&#123;mobileNo&#125;
      ,a.LastModifyUserID=#&#123;lastModifyUserID&#125;
      &lt;if test=&quot;height != null and height != &#39;&#39;&quot; &gt;
          &lt;!--SAMPLE_BATCH_NO = #&#123;sampleBatchNo,jdbcType=VARCHAR&#125;,--&gt;
          ,a.Height=#&#123;height&#125;
      &lt;/if&gt;
      WHERE a.PersonSID =#&#123;personSID&#125;
  &lt;/update&gt;
</code></pre>
</li>
</ul>
<h3 id="用c标签遍历实现select下拉框"><a href="#用c标签遍历实现select下拉框" class="headerlink" title="用c标签遍历实现select下拉框"></a>用c标签遍历实现select下拉框</h3><ul>
<li><p>jsp</p>
<pre><code>  jsp需要引入jstl：
  &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
  和开启EL表达式：
  &lt;%@ page isELIgnored=&quot;false&quot; %&gt;&lt;%--开启EL表达式--%&gt;

  &lt;select class=&quot;form-control&quot; id = &quot;nationType&quot; &gt;
      &lt;c:forEach items=&quot;$&#123;nations&#125;&quot; var=&quot;data&quot;&gt;
          &lt;option value=&quot;$&#123;data.nationName&#125;&quot;&gt;$&#123;data.nationName&#125;&lt;/option&gt;
      &lt;/c:forEach&gt;
  &lt;/select&gt; 
  
</code></pre>
</li>
<li><p>下拉框数据反写</p>
<pre><code>   //民族下拉框值反写
      var selectCode2 = document.getElementById(&quot;nationType&quot;);
      for (var i = 0; i &lt; selectCode2.options.length; i++) &#123;
          if (selectCode2.options[i].value == &quot;$&#123;BasicInfo.nation&#125;&quot;) &#123;
              selectCode2.options[i].selected = true;
              break;
          &#125;
      &#125;
</code></pre>
<p>   参考链接：</p>
<blockquote>
<p><a href="https://zhidao.baidu.com/question/713376095728011125.html">https://zhidao.baidu.com/question/713376095728011125.html</a>    </p>
</blockquote>
</li>
<li><p>nations在Java代码中设置</p>
<pre><code>  List&lt;Nation&gt; nations = this.personInfoDetailBasicService.queryNations();
  req.setAttribute(&quot;nations&quot;, nations);
</code></pre>
</li>
</ul>
<h3 id="数据库中日期-0000-00-00-异常处理方式"><a href="#数据库中日期-0000-00-00-异常处理方式" class="headerlink" title="数据库中日期 0000-00-00 异常处理方式"></a>数据库中日期 0000-00-00 异常处理方式</h3><ul>
<li><p>在jdbc连接中添加参数解决</p>
<pre><code>  jdbc.url=jdbc:mysql://192.168.1.1:3306/mydb222?useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&amp;transformedBitIsBoolean=true
  
  zeroDateTimeBehavior=round是为了指定MySql中的DateTime字段默认值查询时的处理方式；默认是抛出异常，

  对于值为0000-00-00   00:00:00（默认值）的纪录，如下两种配置，会返回不同的结果：
  zeroDateTimeBehavior=round            0001-01-01 00:00:00.0
  zeroDateTimeBehavior=convertToNull    null 
</code></pre>
</li>
</ul>
<h2 id="SSM"><a href="#SSM" class="headerlink" title="SSM"></a>SSM</h2><h2 id="controller中接收参数的另一种形式"><a href="#controller中接收参数的另一种形式" class="headerlink" title="controller中接收参数的另一种形式"></a>controller中接收参数的另一种形式</h2><ul>
<li><p>接收参数的另一种方式</p>
<pre><code>  @RequestMapping(&quot;/readMessage/&#123;id&#125;&quot;)
  public String ReadMessage(@PathVariable Integer id, Message message, HttpServletRequest request) &#123;
</code></pre>
</li>
</ul>
<h2 id="mybatis-分页"><a href="#mybatis-分页" class="headerlink" title="mybatis 分页"></a>mybatis 分页</h2><ul>
<li><p>mybatis-config.xml文件中配置插件：</p>
<pre><code>  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
          &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
  
  &lt;configuration&gt;
  
  //配置PageInterceptor位置 以及数据库类型
  &lt;plugins&gt;
      &lt;plugin interceptor=&quot;com.xjd.mybatis.page.PageInterceptor&quot;&gt;
          &lt;property name=&quot;databaseType&quot; value=&quot;mysql&quot;/&gt;
      &lt;/plugin&gt;
  &lt;/plugins&gt;
  
  &lt;/configuration&gt;
  
</code></pre>
</li>
<li><pre><code>Dao中的修改
</code></pre>
</li>
</ul>
<pre><code>由原来的单参数变为多参数，要用@Param绑定

    原：
    List&lt;Message&gt; selectAll(Integer loginId);
    修改后：
    List&lt;Message&gt; selectAll(@Param(&quot;loginId&quot;) Integer loginId, @Param(&quot;page&quot;) Pagination page);
    
</code></pre>
<ul>
<li><p>controller中对应的修改</p>
<pre><code>    //分页
  Page&lt;Message&gt; page = new Page&lt;Message&gt;(pageIndex, 6); // 第1页取20条

  List&lt;Message&gt; message = null;
  try &#123;
      //传入page对象
      message = this.messageService.queryAll(loginId, page);
      page.setResultList(message); // 将结果集传入
      //总记录条数
     Integer totalCount = page.getTotalCount();
     //总页数-totalPage需要在Page实体中加入getter/setter方法
     Integer totalPage = page.getTotalPage();
     
  &#125; catch (Exception e) &#123;
      e.printStackTrace();
  &#125;
  
</code></pre>
<p>  原理；</p>
<pre><code>  MyBatis3.2 使用Interceptor进行分页原理：
  当Mybatis查询数据的时候，利用Mybatis提供的Interceptor对查询方法进行拦截，动态修改SQL，把不带分页的SQL改造成带分页的SQL
  比如在MySql数据库下面 正常查询的SQL 为 selelct id, name from user where name = ?  那么改造后的SQL 为 selelct id, name from user where name = ? limit 5 , 10
</code></pre>
</li>
</ul>
<h2 id="参考示例代码以及插件包"><a href="#参考示例代码以及插件包" class="headerlink" title="参考示例代码以及插件包"></a>参考示例代码以及插件包</h2><ul>
<li><p>百度云</p>
<pre><code>  链接:https://pan.baidu.com/s/1IK_gf85Sz_x851n2hNJewA  密码:v78x        
  
</code></pre>
<p>  参考源：</p>
<blockquote>
<p><a href="https://www.cnblogs.com/daxin/p/3236861.html">https://www.cnblogs.com/daxin/p/3236861.html</a></p>
</blockquote>
<blockquote>
<p><a href="https://github.com/bleast/mybatis-page-plugin">https://github.com/bleast/mybatis-page-plugin</a></p>
</blockquote>
</li>
</ul>
<h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础</title>
    <url>/2017/12/14/Python%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h2><ul>
<li><p>脚本第一行</p>
<pre><code>   #!/usr/bin/env python与#!/usr/bin/python的区别

  脚本语言的第一行，目的就是指出，你想要你的这个文件中的代码用什么可执行程序去运行它。

  #!/usr/bin/python是告诉操作系统执行这个脚本的时候，调用/usr/bin下的python解释器；
  #!/usr/bin/env python这种用法是为了防止操作系统用户没有将python装在默认的/usr/bin路径里。
  当系统看到这一行的时候，首先会到env设置里查找python的安装路径，再调用对应路径下的解释器程序完成操作。
  #!/usr/bin/python相当于写死了python路径;
  #!/usr/bin/env python会去环境设置寻找python目录,推荐这种写法
  
</code></pre>
<blockquote>
<p><a href="http://blog.csdn.net/wh_19910525/article/details/8040494">http://blog.csdn.net/wh_19910525/article/details/8040494</a>    </p>
</blockquote>
</li>
</ul>
]]></content>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL优化</title>
    <url>/2021/05/01/SQL%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="sql慢日志"><a href="#sql慢日志" class="headerlink" title="sql慢日志"></a>sql慢日志</h2><ul>
<li><p>查询与开启慢日志</p>
<pre><code>  查询慢日志是否开启：
  show VARIABLES like &#39;%quer%&#39;
  
  查询慢日志记录：
  show status like &#39;%Slow_queries%&#39;
  
  开启慢日志：
  set global slow_query_log=on;
  set global long_query_time=1;
  
  explain工具分析sql：
  explain select TITLE from t_oa_dispatch_auto where title like &#39;d5%&#39;
</code></pre>
</li>
</ul>
]]></content>
      <tags>
        <tag>SQL优化</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL进阶</title>
    <url>/2017/06/02/SQL%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h2 id="简单表的拆分思路"><a href="#简单表的拆分思路" class="headerlink" title="简单表的拆分思路"></a>简单表的拆分思路</h2><ul>
<li><p>如图</p>
<p>  <img src="http://op05inpyd.bkt.clouddn.com/%E7%AE%80%E5%8D%95%E8%A1%A8%E7%9A%84%E6%8B%86%E5%88%86.png"></p>
</li>
<li><p><strong>描述</strong></p>
<pre><code>  有一张表 cars,有字段id,name,catename三个。
  现要将其拆分成新cars表和cates俩表，
  其中新cars表包含id,name和cates的主键cateid。
</code></pre>
</li>
<li><p><strong>操作</strong></p>
<pre><code>  1.创建cates表
  
  DROP TABLE IF EXISTS `cates`;
  CREATE TABLE `cates` (
    `id` int(11) NOT NULL AUTO_INCREMENT,
    `name` varchar(255) DEFAULT NULL,
    PRIMARY KEY (`id`)
  ) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8;

  2.将cars中的cateName插入到cates中

  insert into cates(name)
  select cateName from cars;

  3.创建表cars_tmp存放cars表的id,name和cates的id

  DROP TABLE IF EXISTS `cars_tmp`;
  CREATE TABLE `cars_tmp` (
    `id` int(11) DEFAULT NULL,
    `name` varchar(100) DEFAULT NULL,
    `cateid` int(11) DEFAULT NULL
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8;

  4.将对应数据插入到cars_tmp中
  
  insert into cars_tmp
  select c.id,c.name,cs.id
  from cars c join cates cs on c.cateName = cs.name;
  /inner join和join相同

  5.删除老cars表，重命名cars_tmp表为cars

  drop table cars;
  alter table cars_tmp rename to cars;
</code></pre>
</li>
</ul>
<h2 id="case转换"><a href="#case转换" class="headerlink" title="case转换"></a>case转换</h2><ul>
<li><p><strong>查询结果中字段性别 1和0 转换为 男/女</strong></p>
<pre><code>  SELECT id, case sex WHEN &#39;1&#39; THEN &#39;男&#39; WHEN &#39;0&#39; THEN &#39;女&#39; END AS sex FROM person;

  表结构：
  -- ----------------------------
  DROP TABLE IF EXISTS `person`;
  CREATE TABLE `person` (
    `id` int(11) NOT NULL,
    `sex` varchar(1) DEFAULT NULL,
    PRIMARY KEY (`id`)
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
</code></pre>
</li>
</ul>
<h2 id="临时表"><a href="#临时表" class="headerlink" title="临时表"></a>临时表</h2><p>创建临时表很容易，给正常的CREATE TABLE语句加上TEMPORARY关键字即可。</p>
<ul>
<li><p>创建临时表</p>
<pre><code>  CREATE TEMPORARY TABLE tmp_table (
   name VARCHAR(10) NOT NULL
  ) 
</code></pre>
</li>
<li><p>向临时表中插数据</p>
<pre><code>  insert into tmp_table(name)
  select name from cars_old;
</code></pre>
</li>
<li><p>删除临时表</p>
<p>  临时表将在你连接MySQL期间存在。当你断开时，MySQL将自动删除表并释放所用的空间。当然你可以在仍然连接的时候删除表并释放空间。</p>
<pre><code>  DROP TABLE tmp_table
</code></pre>
</li>
</ul>
<h2 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h2><ul>
<li>查看表结构<pre><code>  desc table_name
  describe table_name
</code></pre>
</li>
</ul>
<h2 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h2><ul>
<li><p>order by 1/2/3的含义</p>
<pre><code>  SELECT * FROM table_name ORDER BY 1;
  SELECT id,name,sex FROM table_name ORDER BY 3;
</code></pre>
<p>  ORDER BY 1代表以 所查询字段 的第1个字段排序；</p>
<p>  ORDER BY 3代表以 所查询字段 的第3个字段排序，如果查询总字段的个数小于3个字段，则会报错。</p>
</li>
</ul>
<h2 id="数据库视图"><a href="#数据库视图" class="headerlink" title="数据库视图"></a>数据库视图</h2><ul>
<li><p>什么是视图</p>
<p>  视图，并不是真实存在的数据表（但是其对应的数据表是真实存在的），而是数据表字段的组合或者筛选，可以与存储过程对比理解，也可以把视图暂且理解为一个或多个数据表特定字段的组合。</p>
</li>
<li><p>如何创建视图</p>
<p>  比如，现在存在数据表student</p>
<pre><code>  DROP TABLE IF EXISTS `student`;
  CREATE TABLE `student` (
    `id` int(11) NOT NULL,
    `sid` varchar(255) DEFAULT NULL,
    `sname` varchar(255) DEFAULT NULL,
    `ssex` varchar(255) DEFAULT NULL,
    `sage` varchar(255) DEFAULT NULL,
    `saddress` varchar(255) DEFAULT NULL,
    `sclass` varchar(255) DEFAULT NULL
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
  
  -- ----------------------------
  -- Records of student
  -- ----------------------------
  INSERT INTO `student` VALUES (&#39;1&#39;, &#39;2017001&#39;, &#39;张三&#39;, &#39;男&#39;, &#39;21&#39;, &#39;上海&#39;, &#39;001&#39;);
  INSERT INTO `student` VALUES (&#39;2&#39;, &#39;2017002&#39;, &#39;李四&#39;, &#39;女&#39;, &#39;22&#39;, &#39;北京&#39;, &#39;002&#39;);
</code></pre>
<p>  该表包含id,学号，姓名，性别，年龄，地址这几个字段，如果此刻只想暴露学号，姓名，性别这三个字段信息供外界查询，那么可以建立视图，用以隐藏其余不想暴露的字段。</p>
<pre><code>  create view v_student AS
  SELECT id,sid,sname,ssex FROM student;
</code></pre>
<p>  上面的SQL创建了名为v_student的视图，该视图针对student数据表而存在，展示学号，姓名，性别三个字段。</p>
</li>
<li><p>视图的调用</p>
<p>  视图的操作与普通数据表的操作一样</p>
<p>  查询：</p>
<pre><code>  select*from v_student;
</code></pre>
<p>  插入：</p>
<pre><code>  insert into v_student values(&#39;3&#39;,&#39;2017003&#39;,&#39;王五&#39;,&#39;男&#39;);
</code></pre>
<p>  修改：</p>
<pre><code>  UPDATE v_student set ssex=&#39;女&#39; WHERE sid = &#39;2017003&#39;;
</code></pre>
<p>  删除：</p>
<pre><code>   DELETE FROM v_student where sid=&#39;2017003&#39;;
</code></pre>
</li>
<li><p>视图的优劣</p>
<p>  <strong>优点：</strong></p>
<p>  使用视图，可以定制用户数据，聚焦特定的数据。</p>
<p>  使用视图，可以简化数据操作</p>
<p>  数据隐藏</p>
<p>  以合并分离的数据，创建分区视图</p>
<p>  <strong>缺点：</strong></p>
<p>   性能差</p>
<p>   修改限制</p>
<p>  <strong>参考文章：</strong></p>
<blockquote>
<p><a href="http://blog.csdn.net/javajxz008/article/details/50720936">http://blog.csdn.net/javajxz008/article/details/50720936</a></p>
</blockquote>
</li>
</ul>
<h2 id="外连接与内链接"><a href="#外连接与内链接" class="headerlink" title="外连接与内链接"></a>外连接与内链接</h2><ul>
<li><p>LEFT JOIN</p>
<p>  左表为主表，查询结果含有左表所有满足条件的。</p>
</li>
<li><p>RIGHT JOIN</p>
<p>  右表为主表，查询结果含有右表所有满足条件的。</p>
</li>
<li><p>INNER JOIN</p>
<p>  只有两表同时满足条件的记录，才会被查询出来。</p>
</li>
</ul>
<p><strong>以info1和info2表中主键(id/sid)相同为条件，查询info1中的id和info2的sname为例：</strong></p>
<ul>
<li><p>表1：</p>
<pre><code>  mysql&gt; select*from info1;
  +----+-------+
  | id | name  |
  +----+-------+
  |  4 | 张三4 |
  | 11 | 张三1 |
  | 22 | 张三2 |
  | 33 | 张三3 |
  +----+-------+
  
</code></pre>
</li>
<li><p>表2：</p>
<pre><code>  mysql&gt; select*from info2;
  +-----+-------+
  | sid | sname |
  +-----+-------+
  |   1 | 李四1 |
  |  22 | 李四2 |
  |  33 | 李四3 |
  |  44 | 李四4 |
  +-----+-------+
  4 rows in set
</code></pre>
</li>
<li><p>左连接，以左表为主，其中id为11，4，和55的在info2表中没有对应的id,所以sname为NULL</p>
<pre><code>  mysql&gt; select id,sname from info1 as a left join info2 as b on a.id = b.sid order by name;
  +----+-------+
  | id | sname |
  +----+-------+
  | 11 | NULL  |
  | 22 | 李四2 |
  | 33 | 李四3 |
  |  4 | NULL  |
  | 55 | NULL  |
  +----+-------+
  5 rows in set
</code></pre>
</li>
</ul>
<ul>
<li><p>右连接，以右表为主，因此左表中的第五列没有被查询出来</p>
<pre><code>  mysql&gt; select id,sname from info1 as a right join info2 as b on a.id = b.sid order by name;
  +------+-------+
  | id   | sname |
  +------+-------+
  | NULL | 李四1 |
  | NULL | 李四4 |
  |   22 | 李四2 |
  |   33 | 李四3 |
  +------+-------+
  4 rows in set
</code></pre>
</li>
<li><p>内连接，只查询a.id和b.sid一致的记录</p>
<pre><code>  mysql&gt; select id,sname from info1 as a inner join info2 as b on a.id = b.sid order by name;
  +----+-------+
  | id | sname |
  +----+-------+
  | 22 | 李四2 |
  | 33 | 李四3 |
  +----+-------+
  2 rows in set
</code></pre>
</li>
</ul>
<h2 id="给table起别名-DB2"><a href="#给table起别名-DB2" class="headerlink" title="给table起别名(DB2)"></a>给table起别名(DB2)</h2><ul>
<li>LC.B_SH_DlvSeqInfo起别名为TC.B_SH_DLVSEQINFO<pre><code>  CREATE ALIAS TC.B_SH_DLVSEQINFO FOR LC.B_SH_DlvSeqInfo;
</code></pre>
</li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li><p>索引的创建与查看</p>
<p>  <img src="http://op05inpyd.bkt.clouddn.com/%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95.jpg"></p>
</li>
</ul>
<h3 id="UNION与UNION-ALL"><a href="#UNION与UNION-ALL" class="headerlink" title="UNION与UNION ALL"></a>UNION与UNION ALL</h3><ul>
<li><p>示例表结构</p>
<pre><code>  DROP TABLE IF EXISTS `cars`;
  CREATE TABLE `cars` (
    `id` int(11) DEFAULT NULL,
    `name` varchar(100) DEFAULT NULL,
    `cateid` int(11) DEFAULT NULL,
    `new` int(255) DEFAULT NULL,
    KEY `myid` (`id`)
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
  
  -- ----------------------------
  -- Records of cars
  -- ----------------------------
  INSERT INTO `cars` VALUES (&#39;1001&#39;, &#39;car1&#39;, &#39;1&#39;, null);
  INSERT INTO `cars` VALUES (&#39;2&#39;, &#39;car2&#39;, &#39;2&#39;, null);
  INSERT INTO `cars` VALUES (&#39;3&#39;, &#39;car3&#39;, &#39;3&#39;, null);
  INSERT INTO `cars` VALUES (&#39;4&#39;, &#39;car4&#39;, &#39;4&#39;, null);
  INSERT INTO `cars` VALUES (&#39;5&#39;, &#39;car4&#39;, &#39;5&#39;, null);
</code></pre>
</li>
<li><p>union查询与union all查询对比</p>
<p>  <strong>UNION:</strong></p>
<pre><code>  mysql&gt; select &quot;信息名&quot; from cars
      -&gt; union
      -&gt; select name from cars;
  
  +--------+
  | 信息名 |
  +--------+
  | 信息名 |
  | car1   |
  | car2   |
  | car3   |
  | car4   |
  +--------+
</code></pre>
</li>
<li><p><strong>UNION ALL:</strong></p>
<pre><code>  mysql&gt; select &quot;信息名&quot; from cars
      -&gt; union all
      -&gt; select name from cars;

  +--------+
  | 信息名 |
  +--------+
  | 信息名 |
  | 信息名 |
  | 信息名 |
  | 信息名 |
  | 信息名 |
  | car1   |
  | car2   |
  | car3   |
  | car4   |
  | car4   |
  +--------+
</code></pre>
<p>  对比结果：</p>
<p>  UNION会将查询的结果去重复，UNION ALL不会进行重复过滤。</p>
</li>
</ul>
<p>但是，如果在UNION ALL中条件唯一（查询结果只有一条），一样可以做到和UNION一样的结果。</p>
<ul>
<li>如下：<pre><code>  mysql&gt; select sum(id),&quot;信息&quot; from cars
      -&gt; union
      -&gt; select id,name from cars;
  +---------+------+
  | sum(id) | 信息 |
  +---------+------+
  | 1015    | 信息 |
  | 1001    | car1 |
  | 2       | car2 |
  | 3       | car3 |
  | 4       | car4 |
  | 5       | car4 |
  +---------+------+
  
  mysql&gt; select sum(id),&quot;信息&quot; from cars
      -&gt; union all
      -&gt; select id,name from cars;
  +---------+------+
  | sum(id) | 信息 |
  +---------+------+
  | 1015    | 信息 |
  | 1001    | car1 |
  | 2       | car2 |
  | 3       | car3 |
  | 4       | car4 |
  | 5       | car4 |
  +---------+------+
</code></pre>
</li>
</ul>
<p>**因为sum（id）的结果只有一条，所以出现UNION ALL和UNION一样的结果。 **</p>
<h2 id="IFNULL-ISNULL-NVL"><a href="#IFNULL-ISNULL-NVL" class="headerlink" title="IFNULL/ISNULL/NVL"></a>IFNULL/ISNULL/NVL</h2><p>IFNULL/ISNULL/NVL 可以做数据表两个字段的查询，如字段1，字段2，若字段1为null，则用字段2代替</p>
<ul>
<li><p>MySQL语法如下：</p>
<pre><code>  SELECT IFNULL(new,name) from cars;
  
  +------------------+
  | IFNULL(new,name) |
  +------------------+
  | 33               |
  | car2             |
  | car3             |
  | car4             |
  | car4             |
  +------------------+
</code></pre>
</li>
<li><p>Oracle语法：</p>
<pre><code>  SELECT NVL(new,name) from cars;
  
</code></pre>
</li>
<li><p>DB2</p>
<pre><code>  SELECT COLUMN FROM TABLE FETCH FIRST N ROWS ONLY 
</code></pre>
</li>
</ul>
<h2 id="CASE的另一种用法"><a href="#CASE的另一种用法" class="headerlink" title="CASE的另一种用法"></a>CASE的另一种用法</h2><ul>
<li><p>CASE的另一种用法</p>
<pre><code>  需求：如果我想更新id=1的status为1，id不为1的status为0  ，且id有外键
  
  update AccountStatus a set a.statusSource=(case when a.statusSource =1 then 2 else  1 end )
  
  --这样可以替换掉id为1的数据为0，id为0的数据为1
  
</code></pre>
</li>
<li><p>普通用法</p>
<pre><code>  将成绩划分等级：
  select grade,case 
              when grade&gt;=90 then &#39;优秀&#39;
              when grade&gt;=80 then &#39;良好&#39;
              when grade&gt;=70 then &#39;中等&#39;
              when grade&gt;=60 then &#39;及格&#39;
              when grade is null then &#39;缺考&#39;
              else &#39;不及格&#39;
              end
  from sc
</code></pre>
</li>
</ul>
<h2 id="Mysql的Limit"><a href="#Mysql的Limit" class="headerlink" title="Mysql的Limit"></a>Mysql的Limit</h2><ul>
<li><p>limit</p>
<pre><code>  select * from tbname LIMIT 10;--检索前10行数据，显示1-10条数据
  select * from tbname LIMIT 1,10;--检索从第2行开始，累加10条id记录，共显示id为2....11
  select * from tbname limit 5,10;--检索从第6行开始向前加10条数据，共显示id为6,7....15
  select * from tbname limit 6,10;--检索从第7行开始向前加10条记录，显示id为7,8...16
</code></pre>
</li>
</ul>
]]></content>
      <tags>
        <tag>SQL进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM思维导图</title>
    <url>/2018/04/13/SSM/</url>
    <content><![CDATA[<h2 id="SSM思维导图"><a href="#SSM思维导图" class="headerlink" title="SSM思维导图"></a>SSM思维导图</h2><ul>
<li>SSM思维导图</li>
</ul>
<p><img src="http://ogy57hyu6.bkt.clouddn.com/SSM%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE1.png"></p>
<ul>
<li>指示器</li>
</ul>
<p><img src="http://ogy57hyu6.bkt.clouddn.com/%E6%8C%87%E7%A4%BA%E5%99%A8.png"></p>
<h2 id="SpringMVC工作原理图"><a href="#SpringMVC工作原理图" class="headerlink" title="SpringMVC工作原理图"></a>SpringMVC工作原理图</h2><ul>
<li><p>SpringMVC工作原理流程图</p>
<p>  <img src="http://ogy57hyu6.bkt.clouddn.com/SpringMVC%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%861.png"></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>SSM思维导图</tag>
      </tags>
  </entry>
  <entry>
    <title>SS</title>
    <url>/2017/10/17/SS/</url>
    <content><![CDATA[<h1 id="SS安装"><a href="#SS安装" class="headerlink" title="SS安装"></a>SS安装</h1><h1 id="CentOS下shadowsocks-libev一键安装脚本"><a href="#CentOS下shadowsocks-libev一键安装脚本" class="headerlink" title="CentOS下shadowsocks-libev一键安装脚本"></a>CentOS下shadowsocks-libev一键安装脚本</h1><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h3 id="关于本脚本："><a href="#关于本脚本：" class="headerlink" title="关于本脚本："></a>关于本脚本：</h3><ul>
<li><p>一键安装 libev 版的 Shadowsocks</p>
<pre><code>  一键安装 libev 版的 Shadowsocks 最新版本。该版本的特点是内存占用小（600k左右），
  低 CPU 消耗，甚至可以安装在基于 OpenWRT 的路由器上。
</code></pre>
</li>
</ul>
<h3 id="默认配置："><a href="#默认配置：" class="headerlink" title="默认配置："></a>默认配置：</h3><ul>
<li>服务器端口：<br>  自己设定（如不设定，默认从 9000-19999 之间随机生成）</li>
<li>密码：<br>  自己设定（如不设定，默认为 teddysun.com）</li>
<li>加密方式：<br>  自己设定（如不设定，默认为 aes-256-gcm）</li>
</ul>
<h3 id="Shadowsocks-for-Windows-客户端下载："><a href="#Shadowsocks-for-Windows-客户端下载：" class="headerlink" title="Shadowsocks for Windows 客户端下载："></a>Shadowsocks for Windows 客户端下载：</h3><ul>
<li><p>下载地址</p>
<blockquote>
<p><a href="https://github.com/shadowsocks/shadowsocks-windows/releases">https://github.com/shadowsocks/shadowsocks-windows/releases</a></p>
</blockquote>
</li>
</ul>
<h3 id="安装方法："><a href="#安装方法：" class="headerlink" title="安装方法："></a>安装方法：</h3><ul>
<li><p>使用root用户登录，运行以下命令：</p>
<pre><code>  wget --no-check-certificate -O shadowsocks-libev.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-libev.sh
  chmod +x shadowsocks-libev.sh
  ./shadowsocks-libev.sh 2&gt;&amp;1 | tee shadowsocks-libev.log
  
</code></pre>
</li>
<li><p>安装完成后，脚本提示如下：</p>
<pre><code>  Congratulations, Shadowsocks-libev server install completed!
  Your Server IP        :your_server_ip
  Your Server Port      :your_server_port
  Your Password         :your_password
  Your Encryption Method:your_encryption_method
  
  Welcome to visit:https://teddysun.com/357.html
  Enjoy it!    
</code></pre>
</li>
</ul>
<h3 id="卸载方法："><a href="#卸载方法：" class="headerlink" title="卸载方法："></a>卸载方法：</h3><ul>
<li><p>使用 root 用户登录，运行以下命令：</p>
<pre><code>  ./shadowsocks-libev.sh uninstall    
</code></pre>
</li>
</ul>
<h3 id="其他事项："><a href="#其他事项：" class="headerlink" title="其他事项："></a>其他事项：</h3><ul>
<li><p>客户端配置的参考链接：</p>
<blockquote>
<p><a href="https://teddysun.com/339.html">https://teddysun.com/339.html</a></p>
</blockquote>
</li>
</ul>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><ul>
<li><p>安装完成后即已后台启动 Shadowsocks-libev ，运行：</p>
<pre><code>  /etc/init.d/shadowsocks status    
  
  可以查看进程是否启动。
  本脚本安装完成后，会将 Shadowsocks-libev 加入开机自启动。
</code></pre>
</li>
</ul>
<h3 id="使用命令："><a href="#使用命令：" class="headerlink" title="使用命令："></a>使用命令：</h3><ul>
<li><p>命令参考</p>
<pre><code>  启动：/etc/init.d/shadowsocks start
  停止：/etc/init.d/shadowsocks stop
  重启：/etc/init.d/shadowsocks restart
  查看状态：/etc/init.d/shadowsocks status    
</code></pre>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3></li>
<li><p>链接</p>
<blockquote>
<p><a href="https://teddysun.com/357.html">https://teddysun.com/357.html</a>    </p>
</blockquote>
</li>
</ul>
<h1 id="CentOS下-ShadowsocksR-一键安装脚本-vps"><a href="#CentOS下-ShadowsocksR-一键安装脚本-vps" class="headerlink" title="CentOS下 ShadowsocksR 一键安装脚本(vps)"></a>CentOS下 ShadowsocksR 一键安装脚本(vps)</h1><h2 id="安装步骤-1"><a href="#安装步骤-1" class="headerlink" title="安装步骤"></a>安装步骤</h2><h3 id="关于本脚本：-1"><a href="#关于本脚本：-1" class="headerlink" title="关于本脚本："></a>关于本脚本：</h3><ul>
<li><p>关于脚本</p>
<p>  一键安装 ShadowsocksR 服务端。<br>  请下载与之配套的客户端程序来连接。<br>  （以下客户端只有 Windows 客户端和 Python 版客户端可以使用 SSR 新特性，其他原版客户端只能以兼容的方式连接 SSR 服务器）</p>
</li>
</ul>
<h3 id="默认配置：-1"><a href="#默认配置：-1" class="headerlink" title="默认配置："></a>默认配置：</h3><ul>
<li><p>默认配置</p>
<p>  服务器端口：自己设定（如不设定，默认从 9000-19999 之间随机生成）<br>  密码：自己设定（如不设定，默认为 teddysun.com）<br>  加密方式：自己设定（如不设定，默认为 aes-256-cfb）<br>  协议（Protocol）：自己设定（如不设定，默认为 origin）<br>  混淆（obfs）：自己设定（如不设定，默认为 plain）</p>
</li>
</ul>
<h3 id="客户端下载："><a href="#客户端下载：" class="headerlink" title="客户端下载："></a>客户端下载：</h3><ul>
<li><p>Windows / OS X</p>
<blockquote>
<p><a href="https://github.com/shadowsocksrr/shadowsocksr-csharp/releases">https://github.com/shadowsocksrr/shadowsocksr-csharp/releases</a><br><a href="https://github.com/shadowsocks/shadowsocks-iOS/wiki/Shadowsocks-for-OSX-Help">https://github.com/shadowsocks/shadowsocks-iOS/wiki/Shadowsocks-for-OSX-Help</a></p>
</blockquote>
</li>
<li><p>Linux</p>
<blockquote>
<p><a href="https://github.com/shadowsocks/shadowsocks-qt5">https://github.com/shadowsocks/shadowsocks-qt5</a></p>
</blockquote>
</li>
<li><p>Android / iOS</p>
<blockquote>
<p><a href="https://github.com/shadowsocks/shadowsocks-android">https://github.com/shadowsocks/shadowsocks-android</a><br><a href="https://github.com/shadowsocks/shadowsocks-iOS/wiki/Help">https://github.com/shadowsocks/shadowsocks-iOS/wiki/Help</a></p>
</blockquote>
</li>
<li><p>OpenWRT</p>
<blockquote>
<p><a href="https://github.com/shadowsocks/openwrt-shadowsocks">https://github.com/shadowsocks/openwrt-shadowsocks</a></p>
</blockquote>
</li>
</ul>
<h3 id="安装方法：-1"><a href="#安装方法：-1" class="headerlink" title="安装方法："></a>安装方法：</h3><ul>
<li><p>使用root用户登录，运行以下命令：</p>
<pre><code>  wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh
  chmod +x shadowsocksR.sh
  ./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log
</code></pre>
</li>
</ul>
<h3 id="安装完成后，脚本提示如下："><a href="#安装完成后，脚本提示如下：" class="headerlink" title="安装完成后，脚本提示如下："></a>安装完成后，脚本提示如下：</h3><ul>
<li><p>安装完成日志</p>
<pre><code>  Congratulations, ShadowsocksR server install completed!
  Your Server IP        :your_server_ip
  Your Server Port      :your_server_port
  Your Password         :your_password
  Your Protocol         :your_protocol
  Your obfs             :your_obfs
  Your Encryption Method:your_encryption_method
  
  Welcome to visit:https://shadowsocks.be/9.html
  Enjoy it!
</code></pre>
</li>
</ul>
<h3 id="卸载方法：-1"><a href="#卸载方法：-1" class="headerlink" title="卸载方法："></a>卸载方法：</h3><ul>
<li><p>使用 root 用户登录，运行以下命令：</p>
<pre><code>  ./shadowsocksR.sh uninstall
</code></pre>
</li>
</ul>
<h3 id="安装完成后即已后台启动-ShadowsocksR-，运行："><a href="#安装完成后即已后台启动-ShadowsocksR-，运行：" class="headerlink" title="安装完成后即已后台启动 ShadowsocksR ，运行："></a>安装完成后即已后台启动 ShadowsocksR ，运行：</h3><ul>
<li><p>启动程序并开机自启动</p>
<pre><code>  /etc/init.d/shadowsocks status
  
  可以查看 ShadowsocksR 进程是否已经启动。
  本脚本安装完成后，已将 ShadowsocksR 自动加入开机自启动。
</code></pre>
</li>
</ul>
<h3 id="使用命令：-1"><a href="#使用命令：-1" class="headerlink" title="使用命令："></a>使用命令：</h3><ul>
<li><p>使用命令</p>
<pre><code>  启动：/etc/init.d/shadowsocks start
  停止：/etc/init.d/shadowsocks stop
  重启：/etc/init.d/shadowsocks restart
  状态：/etc/init.d/shadowsocks status
</code></pre>
</li>
<li><p>配置文件相关</p>
<pre><code>  配置文件路径：/etc/shadowsocks.json
  日志文件路径：/var/log/shadowsocks.log
  代码安装目录：/usr/local/shadowsocks
</code></pre>
</li>
</ul>
<h3 id="多用户配置示例："><a href="#多用户配置示例：" class="headerlink" title="多用户配置示例："></a>多用户配置示例：</h3><ul>
<li><p>多用户配置示例</p>
<pre><code>  &#123;
  &quot;server&quot;:&quot;0.0.0.0&quot;,
  &quot;server_ipv6&quot;: &quot;[::]&quot;,
  &quot;local_address&quot;:&quot;127.0.0.1&quot;,
  &quot;local_port&quot;:1080,
  &quot;port_password&quot;:&#123;
      &quot;8989&quot;:&quot;password1&quot;,
      &quot;8990&quot;:&quot;password2&quot;,
      &quot;8991&quot;:&quot;password3&quot;
  &#125;,
  &quot;timeout&quot;:300,
  &quot;method&quot;:&quot;aes-256-cfb&quot;,
  &quot;protocol&quot;: &quot;origin&quot;,
  &quot;protocol_param&quot;: &quot;&quot;,
  &quot;obfs&quot;: &quot;plain&quot;,
  &quot;obfs_param&quot;: &quot;&quot;,
  &quot;redirect&quot;: &quot;&quot;,
  &quot;dns_ipv6&quot;: false,
  &quot;fast_open&quot;: false,
  &quot;workers&quot;: 1
  &#125;
</code></pre>
</li>
</ul>
<h3 id="如果你想修改配置文件，请参考："><a href="#如果你想修改配置文件，请参考：" class="headerlink" title="如果你想修改配置文件，请参考："></a>如果你想修改配置文件，请参考：</h3><ul>
<li><p>参考</p>
<blockquote>
<p><a href="https://github.com/shadowsocksr-backup/shadowsocks-rss/wiki/Server-Setup">https://github.com/shadowsocksr-backup/shadowsocks-rss/wiki/Server-Setup</a><br><a href="https://github.com/shadowsocksr-backup/shadowsocks-rss/blob/master/ssr.md">https://github.com/shadowsocksr-backup/shadowsocks-rss/blob/master/ssr.md</a><br><a href="https://github.com/shadowsocksr-backup/shadowsocks-rss/wiki/config.json">https://github.com/shadowsocksr-backup/shadowsocks-rss/wiki/config.json</a></p>
</blockquote>
</li>
</ul>
<h3 id="链接-1"><a href="#链接-1" class="headerlink" title="链接"></a>链接</h3><ul>
<li><p>链接</p>
<blockquote>
<p><a href="https://shadowsocks.be/9.html">https://shadowsocks.be/9.html</a></p>
</blockquote>
</li>
</ul>
]]></content>
      <tags>
        <tag>SS</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud-Eureka</title>
    <url>/2018/05/29/SpringCloud-Eureka/</url>
    <content><![CDATA[<h2 id="Eureka概述"><a href="#Eureka概述" class="headerlink" title="Eureka概述"></a>Eureka概述</h2><ul>
<li><p>eureka是干什么的</p>
<p>  作用：微服务中，负责服务（组件）的注册与发现，是一个“大管家”</p>
<p>  <img src="/2018/05/29/SpringCloud-Eureka/1-Eureka/0-Eureka%E4%BD%9C%E7%94%A8.png"></p>
<p>  由来：由SpringCloud基于Netflix Eureka做了二次封装</p>
<p>  Eureka组成：</p>
<pre><code>  由Eureka Server 注册中心和
  Eureka Client 服务注册 这两个主键组成
</code></pre>
<h2 id="Eureka-server端"><a href="#Eureka-server端" class="headerlink" title="Eureka server端"></a>Eureka server端</h2></li>
<li><p>参考链接</p>
<blockquote>
<p><a href="https://blog.csdn.net/forezp/article/details/69696915">https://blog.csdn.net/forezp/article/details/69696915</a></p>
</blockquote>
</li>
<li><p>如何创建eureka server端</p>
<pre><code>  1. IDEA下，new project&gt;&gt;Spring Intializr&gt;&gt;Cloud Discovery&gt;&gt;勾选Eureka Server
</code></pre>
<p>  <img src="/2018/05/29/SpringCloud-Eureka/1-Eureka/1-%E5%88%9B%E5%BB%BAserver01.png"><br>  <img src="/2018/05/29/SpringCloud-Eureka/1-Eureka/2-%E5%88%9B%E5%BB%BAserver02.png"> </p>
<pre><code>  2. 启动类使用@EnableEurekaServer注解：
  
      @SpringBootApplication
      @EnableEurekaServer
      public class EurekaserverApplication &#123;
      
          public static void main(String[] args) &#123;
              SpringApplication.run(EurekaserverApplication.class, args);
          &#125;
      &#125;
      
  3.application.yml配置文件配置相关信息：
  
          #server:
          #  port: 8761
          
          eureka:
            client:
              service-url:
                defaultZone: http://localhost:8761/eureka
              register-with-eureka: false
            #instance:
              #hostname: 192.168.1.102
            #server:
              #enable-self-preservation: false
          
          spring:
            application:
              name: eurekaserver1
          management:
            server:
              servlet:
                context-path: /
</code></pre>
</li>
</ul>
<h2 id="Eureka-client端"><a href="#Eureka-client端" class="headerlink" title="Eureka client端"></a>Eureka client端</h2><ul>
<li><p>如何创建eureka client端</p>
<pre><code>  1. IDEA下，new project&gt;&gt;Spring Intializr&gt;&gt;Cloud Discovery&gt;&gt;勾选Eureka Discovery(略微不同)
</code></pre>
<p>  <img src="/2018/05/29/SpringCloud-Eureka/1-Eureka/2-%E5%88%9B%E5%BB%BAclient%E7%AB%AF.png"></p>
<pre><code>  2. 方式创建的client端可能没有引入web组件，需要手动添加，否则启动失败

          &lt;dependency&gt;
              &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
              &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
          &lt;/dependency&gt;
          
  3. 启动类使用@EnableEurekaClient注解：

  @SpringBootApplication
  @EnableEurekaClient
  public class EurekaclientApplication &#123;
  
      public static void main(String[] args) &#123;
          SpringApplication.run(EurekaclientApplication.class, args);
      &#125;
  &#125;
  
  4. application.yml配置文件配置相关信息：
  
      eureka:
        client:
          service-url:
           defaultZone: http://localhost:8761/eureka/
        #instance:
          #hostname: www.baidu.com
      spring:
        application:
          name: eurekaclient01
      server:
        port: 8763
        
</code></pre>
</li>
<li><p>启动失败,解决参考链接</p>
<blockquote>
<p><a href="https://blog.csdn.net/ngl272/article/details/71087734">https://blog.csdn.net/ngl272/article/details/71087734</a></p>
</blockquote>
</li>
</ul>
<h3 id="server和client端都配置正确后，访问8761端口会看到client的Instances已经被注册到server端"><a href="#server和client端都配置正确后，访问8761端口会看到client的Instances已经被注册到server端" class="headerlink" title="server和client端都配置正确后，访问8761端口会看到client的Instances已经被注册到server端"></a>server和client端都配置正确后，访问8761端口会看到client的Instances已经被注册到server端</h3><h2 id="Eureka实现高可用集群"><a href="#Eureka实现高可用集群" class="headerlink" title="Eureka实现高可用集群"></a>Eureka实现高可用集群</h2><ul>
<li><p>什么是高可用</p>
<p>  <strong>高可用：</strong>即“高可用性”（High Availability），通常来描述一个系统经过专门的设计，从而减少停工时间，而保持其服务的高度可用性。</p>
</li>
<li><p>如何实现高可用集群</p>
<pre><code>  1. 先进行多个服务端相互注册，如eurekaserver1和eurekaserver2相互注册

  2. 再进行client对多个服务端同时注册

  这样可以有效防止服务端的不稳定因素导致整个应用挂掉。
</code></pre>
</li>
</ul>
<h3 id="1-先进行多个服务端相互注册（代码演示）"><a href="#1-先进行多个服务端相互注册（代码演示）" class="headerlink" title="1. 先进行多个服务端相互注册（代码演示）"></a>1. 先进行多个服务端相互注册（代码演示）</h3><h4 id="模拟两个server端："><a href="#模拟两个server端：" class="headerlink" title="模拟两个server端："></a>模拟两个server端：</h4><ul>
<li><p>IDEA中启动两个server端的服务（实例）即可（再复制一份服务启动配置即可，并设置不同端口）</p>
<p>  <img src="/2018/05/29/SpringCloud-Eureka/1-Eureka/3-%E5%90%AF%E5%8A%A8%E4%B8%A4%E4%B8%AA%E6%9C%8D%E5%8A%A1%E6%97%B6%E7%AB%AF%E5%8F%A3%E5%8F%82%E6%95%B0.png"></p>
</li>
</ul>
<h4 id="eurekaserver1在eurekaserver2进行注册："><a href="#eurekaserver1在eurekaserver2进行注册：" class="headerlink" title="eurekaserver1在eurekaserver2进行注册："></a>eurekaserver1在eurekaserver2进行注册：</h4><ul>
<li><p>eurekaserver1的yml文件配置信息</p>
<pre><code>  eureka:
    client:
      service-url:
        defaultZone: http://eureka2:8762/eureka
      register-with-eureka: false
    #instance:
      #hostname: 192.168.1.102
    #server:
      #enable-self-preservation: false

  spring:
    application:
      name: eurekaserver1
  management:
    server:
      servlet:
        context-path: /
</code></pre>
</li>
</ul>
<h4 id="eurekaserver2在eurekaserver1进行注册："><a href="#eurekaserver2在eurekaserver1进行注册：" class="headerlink" title="eurekaserver2在eurekaserver1进行注册："></a>eurekaserver2在eurekaserver1进行注册：</h4><ul>
<li><p>eurekaserver2的yml文件配置信息 </p>
<pre><code>  eureka:
    client:
      service-url:
        defaultZone: http://eureka1:8761/eureka
      register-with-eureka: false
    #instance:
      #hostname: 192.168.1.102
    #server:
      #enable-self-preservation: false

  spring:
    application:
      name: eurekaserver2
  management:
    server:
      servlet:
        context-path: /
</code></pre>
</li>
</ul>
<h4 id="client端对多个server端进行同时注册（这里演示的是两个）"><a href="#client端对多个server端进行同时注册（这里演示的是两个）" class="headerlink" title="client端对多个server端进行同时注册（这里演示的是两个）"></a>client端对多个server端进行同时注册（这里演示的是两个）</h4><ul>
<li><p>配置两个server的service-url，并用逗号分隔即可</p>
<pre><code>  service-url:
    defaultZone: http://eureka1:8761/eureka/,http://eureka2:8762/eureka/
</code></pre>
</li>
</ul>
<h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><ul>
<li>效果<img src="/2018/05/29/SpringCloud-Eureka/1-Eureka/4-%E4%BA%92%E7%9B%B8%E6%B3%A8%E5%86%8C%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E6%95%88%E6%9E%9C.png"></li>
</ul>
<h4 id="注释："><a href="#注释：" class="headerlink" title="注释："></a>注释：</h4><ul>
<li>说明<pre><code>  eurekaserver1的端口为：8761
  ip为：eureka1 
  application name为：eurekaserver1
    -----------------------------------
    eurekaserver2的端口为：8762
  ip为：eureka2
  application name为：eurekaserver2
  
  其中，ip为：eureka1和eureka2是在电脑的host文件中做的伪域名：
  127.0.0.1  eureka1
  127.0.0.1  eureka2
</code></pre>
</li>
</ul>
<h4 id="提别提醒："><a href="#提别提醒：" class="headerlink" title="提别提醒："></a>提别提醒：</h4><ul>
<li><p><strong>很重要的信息</strong></p>
<pre><code>  如果defaultZone: http://eureka1:8761/eureka中都填127.0.0.1或者localhost，则server端相互注册会失败！！
  
  版本：
  
  &lt;parent&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
      &lt;version&gt;2.0.2.RELEASE&lt;/version&gt;
      &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
  &lt;/parent&gt;

  &lt;properties&gt;
      &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
      &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
      &lt;java.version&gt;1.8&lt;/java.version&gt;
      &lt;spring-cloud.version&gt;Finchley.BUILD-SNAPSHOT&lt;/spring-cloud.version&gt;
  &lt;/properties&gt;
  
</code></pre>
</li>
<li><p>多个server端互相注册失败，参考链接    </p>
<blockquote>
<p><a href="https://blog.csdn.net/a60782885/article/details/70146615">https://blog.csdn.net/a60782885/article/details/70146615</a></p>
</blockquote>
</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul>
<li><p>代码链接</p>
<pre><code>  https://git.coding.net/uxaw/springCloud.git
</code></pre>
</li>
</ul>
]]></content>
      <tags>
        <tag>SpringCloud-Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud-Hystrix</title>
    <url>/2018/06/07/SpringCloud-Hystrix/</url>
    <content><![CDATA[<h2 id="Hystrix简介"><a href="#Hystrix简介" class="headerlink" title="Hystrix简介"></a>Hystrix简介</h2><ul>
<li><p>Hystrix简介</p>
<p>  在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用（RPC），在Spring Cloud可以用RestTemplate+Ribbon和Feign来调用。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。</p>
<p>  为了解决这个问题，业界提出了断路器模型。</p>
</li>
</ul>
<h2 id="Hystrix使用"><a href="#Hystrix使用" class="headerlink" title="Hystrix使用"></a>Hystrix使用</h2><h3 id="在Feign中使用Hystrix"><a href="#在Feign中使用Hystrix" class="headerlink" title="在Feign中使用Hystrix"></a>在Feign中使用Hystrix</h3><p>1：Feign工程中pom.xml中加入Hystrix依赖（feign工程参见《SpringCloud-feign》文章）：</p>
<pre><code>     &lt;!--hystrix断路器--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;!--hystrix dashboard--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;
    &lt;/dependency&gt;
    
</code></pre>
<p>2.Feign是自带断路器的，它没有默认打开。需要在配置文件中配置打开它</p>
<pre><code>spring:
  application:
    name: service-feign
eureka:
  client:
    service-url:
      defaultZone: http://172.96.251.101:8761/eureka
server:
  port: 8083

feign:
  hystrix:
    enabled: true
management:
  server:
    servlet:
      context-path: /
</code></pre>
<p>3：启动类上添加@EnableHystrix注解</p>
<pre><code>@SpringBootApplication
@EnableEurekaClient
@EnableFeignClients
@EnableHystrixDashboard
@EnableHystrix
public class FeignApplication &#123;

public static void main(String[] args) &#123;
    SpringApplication.run(FeignApplication.class, args);
&#125;
</code></pre>
<p>4：创建productServiceClientHystric.java实现ProductServiceClient接口（我的feign工程中有这个接口）</p>
<pre><code>package com.ux.feign.serviceClient;

import com.ux.feign.pojo.Product;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

@Component
@Slf4j
public class productServiceClientHystric implements ProductServiceClient &#123;

    @Override
    public Product plist(String productId) &#123;
        Product product = new Product();
        product.setProductName(&quot;访问出错了~~&quot;);
        log.info(&quot;~~~~~访问出错了，断路器起作用了~~~~~~~~&quot;);
        return product;
    &#125;
&#125;
</code></pre>
<p>5：ProductServiceClient接口添加fallback属性</p>
<pre><code>package com.ux.feign.serviceClient;

import com.ux.feign.pojo.Product;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.stereotype.Service;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;

@FeignClient(name = &quot;WXPROJECT&quot;,fallback = productServiceClientHystric.class)
@Service
public interface ProductServiceClient &#123;

    @GetMapping(&quot;/product/productInfo&quot;)
    Product plist(@RequestParam(&quot;productId&quot;) String productId);
&#125;
</code></pre>
<p>6.启动改造后的feign工程，不启动WXPROJECT服务，此时访问，会提示在productServiceClientHystric中返回的信息：</p>
<pre><code>product.setProductName(&quot;访问出错了~~&quot;);即：访问出错了~~
</code></pre>
<p>7：Hystrix Dashboard (断路器：Hystrix 仪表盘)</p>
<pre><code>1.pom.xml中已经添加 &lt;!--hystrix dashboard--&gt;依赖
2.启动类添加注解@EnableHystrixDashboard

两步即可
</code></pre>
<p>8：访问<a href="http://localhost:8083/hystrix">http://localhost:8083/hystrix</a></p>
<pre><code>1.http://localhost:8083/hystrix.stream
2.title填写:feignClient
3.点击monitor stream
4.进入下一个界面访问http://localhost:8083/product/list?productId=11
5.正常情况下应该出现分析数据，但是springboot2.0下可能不出现，解决办法如下：

    启动类下添加getServlet()方法并以bean方式注入即可：
    
    @SpringBootApplication
    @EnableEurekaClient
    @EnableFeignClients
    @EnableHystrixDashboard
    @EnableHystrix
    public class FeignApplication &#123;
    
        public static void main(String[] args) &#123;
            SpringApplication.run(FeignApplication.class, args);
        &#125;
    
        /**
         * hystrix-dashboard不显示解决方法
         *
         * @return
         */
        @Bean
        public ServletRegistrationBean getServlet() &#123;
            HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet();
            ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet);
            registrationBean.setLoadOnStartup(1);
            registrationBean.addUrlMappings(&quot;/hystrix.stream&quot;);
            registrationBean.setName(&quot;HystrixMetricsStreamServlet&quot;);
            return registrationBean;
        &#125;
    
        /***
         * http://localhost:8083/hystrix
         *
         * http://localhost:8083/hystrix.stream
         * feignClient
         * 1000
         *
         */
        &#125;
</code></pre>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li><p>小结</p>
<p>  访问feign工程，feign抵用远程服务，但是远程服务挂了怎么办？此时可以通过断路器Hystrix返回一个信息，说明这个服务挂掉了。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>SpringCloud-Hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud-Zuul</title>
    <url>/2018/06/24/SpringCloud-Zuul/</url>
    <content><![CDATA[<h2 id="Zuul简介"><a href="#Zuul简介" class="headerlink" title="Zuul简介"></a>Zuul简介</h2><ul>
<li><p>zuul简介</p>
<p>  Zuul的主要功能是路由转发和过滤器。路由功能是微服务的一部分，比如／api/user转发到到user服务，/api/shop转发到到shop服务。zuul默认和Ribbon结合实现了负载均衡的功能。</p>
</li>
</ul>
<h2 id="Zuul使用"><a href="#Zuul使用" class="headerlink" title="Zuul使用"></a>Zuul使用</h2><h3 id="zuul转发功能"><a href="#zuul转发功能" class="headerlink" title="zuul转发功能"></a>zuul转发功能</h3><ul>
<li><p>创建一个工程并添加依赖：</p>
<pre><code>   &lt;!--web--&gt;
  &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
  &lt;/dependency&gt;

  &lt;!--zuul--&gt;
  &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
      &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;
  &lt;/dependency&gt;
</code></pre>
</li>
<li><p>启动类添加注解</p>
<pre><code>  @SpringBootApplication
  @EnableEurekaClient
  @EnableZuulProxy
  public class ZuulApplication &#123;
  
      public static void main(String[] args) &#123;
          SpringApplication.run(ZuulApplication.class, args);
      &#125;
  &#125;
  
</code></pre>
</li>
<li><p>application.yml配置文件</p>
<pre><code>  spring:
    application:
      name: service-zuul
  eureka:
    client:
      service-url:
        defaultZone: http://172.96.251.101:8761/eureka
  server:
    port: 8085
  zuul:
    routes:
      api-a:
        path: /api-a/**
        serviceId: service-ribbon
      api-b:
        path: /api-b/**
        serviceId: service-feign
  
  #请求示例
  #http://localhost:8085/api-a/product/list?productId=11
  
  #filter过滤后的请求示例
  ##http://localhost:8085/api-b/product/list?productId=11&amp;token=1111
</code></pre>
</li>
</ul>
<h3 id="zuul过滤器功能"><a href="#zuul过滤器功能" class="headerlink" title="zuul过滤器功能"></a>zuul过滤器功能</h3><ul>
<li><p>过滤功能</p>
<p>  1.创建MyZuulFilter继承ZuulFilter</p>
<pre><code>  package com.ux.zuul.filter;

  import com.netflix.zuul.ZuulFilter;
  import com.netflix.zuul.context.RequestContext;
  import com.netflix.zuul.exception.ZuulException;
  import lombok.extern.slf4j.Slf4j;
  import org.springframework.stereotype.Component;
  
  import javax.servlet.http.HttpServletRequest;
  
  @Slf4j
  @Component
  public class MyZuulFilter extends ZuulFilter &#123;
  
      @Override
      public String filterType() &#123;
          return &quot;pre&quot;;
      &#125;
  
      @Override
      public int filterOrder() &#123;
          return 0;
      &#125;
  
      @Override
      public boolean shouldFilter() &#123;
          return true;
      &#125;
  
      @Override
      public Object run() throws ZuulException &#123;
          RequestContext ctx = RequestContext.getCurrentContext();
          HttpServletRequest request = ctx.getRequest();
          log.info(String.format(&quot;%s &gt;&gt;&gt; %s&quot;, request.getMethod(), request.getRequestURL().toString()));
          Object accessToken = request.getParameter(&quot;token&quot;);
          if (accessToken == null) &#123;
              log.warn(&quot;token参数为空~~&quot;);
              ctx.setSendZuulResponse(false);
              ctx.setResponseStatusCode(401);
              try &#123;
                  ctx.getResponse().getWriter().write(&quot;token is required~~~~~&quot;);
              &#125; catch (Exception e) &#123;
              &#125;
  
              return null;
          &#125;
          log.info(&quot;成功~~&quot;);
          return null;
      &#125;
  &#125;
</code></pre>
<p>  2.此时访问#filter过滤后的请求示例</p>
<pre><code>  ##http://localhost:8085/api-b/product/list?productId=11&amp;token=1111
  如果token为空（http://localhost:8085/api-b/product/list?productId=11）,会提示“token参数为空~~“
</code></pre>
<p>  3.filterType：返回一个字符串代表过滤器的类型，在zuul中定义了四种不同生命周期的过滤器类型，具体如下： </p>
<pre><code>  pre：路由之前
  routing：路由之时
  post： 路由之后
  error：发送错误调用
  filterOrder：过滤的顺序
  shouldFilter：这里可以写逻辑判断，是否要过滤，本文true,永远过滤。
  run：过滤器的具体逻辑。可用很复杂，包括查sql，nosql去判断该请求到底有没有权限访问。
</code></pre>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li><p>小结</p>
<p>  1.配置文件中配置转发规则&gt;&gt;&gt;用户请求后根据转发规则访问不同服务<br>  2.zuul不仅只是路由，并且还能过滤，做一些安全验证，通过创建MyZuulFilter继承ZuulFilter并重写其中的方法，实现过滤规则，增加安全系数。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>SpringCloud-Zuul</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud-feign</title>
    <url>/2018/06/07/SpringCloud-feign/</url>
    <content><![CDATA[<h2 id="Feign概述"><a href="#Feign概述" class="headerlink" title="Feign概述"></a>Feign概述</h2><ul>
<li><p>feign简述</p>
<p>  Feign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单;<br>  Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果。</p>
</li>
</ul>
<h2 id="Feign使用"><a href="#Feign使用" class="headerlink" title="Feign使用"></a>Feign使用</h2><ul>
<li><p>创建工程</p>
<p>  1.IDEA下通过Spring Initializr&gt;&gt;Cloud Discovery&gt;&gt;Eureka Discovery创建一个工程<br>  2.创建好的工程pom.xml中默认是没有web依赖和feign依赖的，添加依赖即可：</p>
<pre><code>   &lt;!--web--&gt;
  &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
  &lt;/dependency&gt;
  
   &lt;!--feign--&gt;
  &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
      &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
  &lt;/dependency&gt;
  
</code></pre>
<p>  3.后续可能用到SLF4J以及lombok,所以顺便添加lombok依赖：</p>
<pre><code>  &lt;!--Slf4j/不写getter/setter的插件--&gt;
  &lt;dependency&gt;
      &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
      &lt;artifactId&gt;lombok&lt;/artifactId&gt;
  &lt;/dependency&gt;
  
</code></pre>
<p>  4.配置文件application.yml(向<a href="http://172.96.251.101:8761/eureka%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1">http://172.96.251.101:8761/eureka注册服务</a>)</p>
<pre><code>  spring:
    application:
      name: service-feign
  eureka:
    client:
      service-url:
        defaultZone: http://172.96.251.101:8761/eureka
  server:
    port: 8083

  management:
    server:
      servlet:
        context-path: /
  
</code></pre>
<p>  5.SpringBoot启动类上添加Feign注解，因为是一个Eureka客户端，所以也会添加EurekaClient注解：</p>
<pre><code>  @SpringBootApplication
  @EnableEurekaClient
  @EnableFeignClients
  public class FeignApplication &#123;

  public static void main(String[] args) &#123;
      SpringApplication.run(FeignApplication.class, args);
  &#125;   
  
</code></pre>
<p>  6.创建包erviceClient，包中创建接口ProductServiceClient.java，作为调用远程服务的service接口：</p>
<pre><code>  package com.ux.feign.serviceClient;

  import com.ux.feign.pojo.Product;
  import org.springframework.cloud.openfeign.FeignClient;
  import org.springframework.stereotype.Service;
  import org.springframework.web.bind.annotation.GetMapping;
  import org.springframework.web.bind.annotation.RequestParam;
  
  @FeignClient(name = &quot;WXPROJECT&quot;)
  @Service
  public interface ProductServiceClient &#123;
  
      @GetMapping(&quot;/product/productInfo&quot;)
      Product plist(@RequestParam(&quot;productId&quot;) String productId);
  &#125;
  
  **注意：**
  ProductServiceClient接口中是访问另一个服务名为WXPROJECT的应用获取productInfo的信息的方法（plist），传递参数为productId，数据返回结果类型为Product，属性如下：
  
  @Data//lombok
  public class Product &#123;
  
      private String productId;
      private String productName;
      private BigDecimal productPrice;
      private Integer productStock;
      private String productDescription;
      private String productIcon;
      private String productStatus;
      private String categoryType;
      private Date createTime;
      private Date updateTime;
  
</code></pre>
<p>  }</p>
<p>  7.创建实体类Product，属性同上。</p>
<p>  8.创建Service类：ProduceService.java，起作用是调用ProductServiceClient接口中的方法。</p>
<pre><code>  package com.ux.feign.service;

  import com.ux.feign.pojo.Product;
  import com.ux.feign.serviceClient.ProductServiceClient;
  import org.springframework.beans.factory.annotation.Autowired;
  import org.springframework.stereotype.Service;
  import org.springframework.web.bind.annotation.GetMapping;
  import org.springframework.web.bind.annotation.RequestParam;
  
  @Service
  public class ProduceService &#123;
  
      @Autowired
      ProductServiceClient productServiceClient;
  
      @GetMapping(&quot;/plist&quot;)
      public Product plist(@RequestParam(&quot;productId&quot;) String productId) &#123;
          return productServiceClient.plist(productId);
      &#125;
  &#125;
  
</code></pre>
<p>  9.创建Controller：</p>
<pre><code>  package com.ux.feign.controller;

  import com.ux.feign.pojo.Product;
  import com.ux.feign.service.ProduceService;
  import lombok.extern.slf4j.Slf4j;
  import org.springframework.beans.factory.annotation.Autowired;
  import org.springframework.web.bind.annotation.RequestMapping;
  import org.springframework.web.bind.annotation.RequestParam;
  import org.springframework.web.bind.annotation.RestController;
  
  @RestController
  @Slf4j
  public class ProductController &#123;
  
      @Autowired
      ProduceService produceService;
  
      //http://localhost:8083/product/list?productId=11
      @RequestMapping(&quot;/product/list&quot;)
      public Product list(@RequestParam(&quot;productId&quot;) String productId) &#123;
  
          Product result = produceService.plist(productId);
  
          log.info(&quot;~~~feign实现服务间的调用result=&#123;&#125;&quot;, result);
          return result;
      &#125;

  &#125;
</code></pre>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li><p>小结</p>
<p>  上面的工程总结下来就是：</p>
<p>  通过使用Feign，来调用远程服务中的product/productInfo方法（这一步通过ProductServiceClient接口来做），而后在工程中想要获取远程productInfo，只需要调用ProductServiceClient中对应的方法即可。</p>
<pre><code>  1.ProductServiceClient接口&gt;&gt;&gt;调用远程服务
  
  2.ProduceService调用ProductServiceClient接口
  
  3.ProductController调用ProduceService
  
</code></pre>
</li>
<li><p>说明</p>
<p>  1.工程使用Intellij IDEA 2017.02创建<br>  2.SpringBoot版本为2.0</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>SpringCloud-feign</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud-rest+ribbon</title>
    <url>/2018/06/07/SpringCloud-rest-ribbon/</url>
    <content><![CDATA[<h2 id="Ribbon简介"><a href="#Ribbon简介" class="headerlink" title="Ribbon简介"></a>Ribbon简介</h2><ul>
<li><p>ribbon</p>
<p>  在微服务架构中，业务都会被拆分成一个独立的服务，服务与服务的通讯是基于http restful的。Spring cloud有两种服务调用方式，一种是ribbon+restTemplate，另一种是feign。在这一篇文章首先讲解下基于ribbon+rest;</p>
<p>  ribbon是一个负载均衡客户端，可以很好的控制htt和tcp的一些行为。Feign默认集成了ribbon.</p>
</li>
</ul>
<h2 id="Ribbon使用"><a href="#Ribbon使用" class="headerlink" title="Ribbon使用"></a>Ribbon使用</h2><ul>
<li><p>创建工程</p>
<p>  1.Cloud Discovery&gt;&gt;Eureka Discovery工程</p>
<p>  2.pom.xml中添加web依赖：</p>
<pre><code>  &lt;!--web--&gt;
  &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
  &lt;/dependency&gt;

  &lt;!--不写getter/setter的插件--&gt;
  &lt;dependency&gt;
      &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
      &lt;artifactId&gt;lombok&lt;/artifactId&gt;
  &lt;/dependency&gt;
  
</code></pre>
<p>  3.启动类添加@EnableEurekaClient注解：</p>
<pre><code>  @SpringBootApplication
  @EnableEurekaClient
  public class ResttemplateribbonApplication &#123;
  
      public static void main(String[] args) &#123;
          SpringApplication.run(ResttemplateribbonApplication.class, args);
      &#125;
  &#125;
  
</code></pre>
<p>  4.application.yml配置文件配置服务注册地址：</p>
<pre><code>  eureka:
    client:
      service-url:
        defaultZone: http://172.96.251.101:8761/eureka
  spring:
    application:
      name: service-Ribbon
            #service-restTemplate-Ribbon
  
  ##更改ribbon默认的负载均衡方式（默认是轮循，改为随机）
  ##WXPROJECT：目标应用的名称
  #WXPROJECT:
  #  ribbon:
  #    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule
  
  server:
    port: 8084
    
</code></pre>
<p>   5.依然调用WXPROJECT这个服务的productInfo方法，所以创建实体类Product.java</p>
<pre><code>    @Data
      public class Product &#123;
      
          private String productId;
          private String productName;
          private BigDecimal productPrice;
          private Integer productStock;
          private String productDescription;
          private String productIcon;
          private String productStatus;
          private String categoryType;
          private Date createTime;
          private Date updateTime;    
      &#125;
      
</code></pre>
<p>  6.创建RestTemplateConfig.java</p>
<pre><code>  package com.ux.resttemplateribbon.restTemplateConfig;

  import org.springframework.cloud.client.loadbalancer.LoadBalanced;
  import org.springframework.context.annotation.Bean;
  import org.springframework.stereotype.Component;
  import org.springframework.web.client.RestTemplate;
  
  @Component
  public class RestTemplateConfig &#123;
  
      @Bean
      @LoadBalanced
      public RestTemplate restTemplate() &#123;
          return new RestTemplate();
      &#125;
  &#125;
  
</code></pre>
<p>  7.利用RestTeamlate+LoadBalanced注解实现对远程服务的调用：</p>
<pre><code>  package com.ux.resttemplateribbon.controller;

  import com.ux.resttemplateribbon.pojo.Product;
  import lombok.extern.slf4j.Slf4j;
  import org.springframework.beans.factory.annotation.Autowired;
  import org.springframework.web.bind.annotation.GetMapping;
  import org.springframework.web.bind.annotation.RequestMapping;
  import org.springframework.web.bind.annotation.RequestParam;
  import org.springframework.web.bind.annotation.RestController;
  import org.springframework.web.client.RestTemplate;
  
  /**
   * 利用RestTeamlate+LoadBalanced注解实现对远程服务的调用：
   * **************@Bean
   * **************@LoadBalanced public RestTemplate restTemplate() &#123;
   * **************return new RestTemplate();
   * **************&#125;
   * &lt;p&gt;
   * &lt;p&gt;
   * 本质依然是RestTeamlate+loadBalancerClient
   */
  
  @Slf4j
  @RestController
  @RequestMapping(&quot;/client/product&quot;)
  public class ProductController &#123;
  
      @Autowired
      RestTemplate restTemplate;
  
      @GetMapping(&quot;/info&quot;)
      public Product info(@RequestParam(&quot;productId&quot;) String productId) &#123;
  
          Product result = restTemplate.getForObject(&quot;http://WXPROJECT/product/productInfo?productId=&quot; + productId, Product.class);
  
          log.info(&quot;~~~~~Product=&#123;&#125;&quot;, result);
          return result;
      &#125;
  &#125;
</code></pre>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li><p>小结</p>
<p>  利用RestTeamlate+LoadBalanced注解实现对远程服务的调用本质依然是RestTeamlate+loadBalancerClient，RestTeamlate+loadBalancerClient调用方式如下，不需要单独写RestTemplateConfig.java了：</p>
<pre><code>  package com.ux.resttemplateribbon.controller;

  import com.ux.resttemplateribbon.pojo.Product;
  import lombok.extern.slf4j.Slf4j;
  import org.springframework.beans.factory.annotation.Autowired;
  import org.springframework.cloud.client.ServiceInstance;
  import org.springframework.cloud.client.loadbalancer.LoadBalancerClient;
  import org.springframework.web.bind.annotation.GetMapping;
  import org.springframework.web.bind.annotation.RequestMapping;
  import org.springframework.web.bind.annotation.RequestParam;
  import org.springframework.web.bind.annotation.RestController;
  import org.springframework.web.client.RestTemplate;
  
  /**
   * restTeamlate+loadBalancerClient(根据服务名称获取host和端口构造成url)实现服务之间的请求调用
   */
  
  @Slf4j
  @RestController
  @RequestMapping(&quot;/client/product&quot;)
  public class ProductController2 &#123;
  
      @Autowired
      LoadBalancerClient loadBalancerClient;
  
      @GetMapping(&quot;/info2&quot;)
      public Product info(@RequestParam(&quot;productId&quot;) String productId) &#123;
  
          RestTemplate restTemplate = new RestTemplate();
          //根据服务名称获取服务信息
          ServiceInstance instance = loadBalancerClient.choose(&quot;WXPROJECT&quot;);
          //获取服务端口
          Integer port = instance.getPort();
          //获取服务host
          String host = instance.getHost();
          //构造（拼接）url  形式为：http://192.168.1.102:8081/product/productInfo?productId=11
          String url = String.format(&quot;http://%s:%s&quot;, host, port + &quot;/product/productInfo?productId=&quot; + productId);
          Product result = restTemplate.getForObject(url, Product.class);
          //Product result = restTemplate.getForObject(&quot;http://WXPROJECT/product/productInfo?productId=&quot;+productId, Product.class);
          log.info(&quot;~~~~~Product=&#123;&#125;&quot;, url);
          return result;
      &#125;
  &#125;
  
  
</code></pre>
</li>
</ul>
]]></content>
      <tags>
        <tag>SpringCloud-ribbon</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud</title>
    <url>/2018/05/29/SpringCloud/</url>
    <content><![CDATA[<h2 id="springCloud中的几个主要组件"><a href="#springCloud中的几个主要组件" class="headerlink" title="springCloud中的几个主要组件"></a>springCloud中的几个主要组件</h2><ul>
<li><p>业务场景以及底层原理</p>
<blockquote>
<p><a href="https://blog.csdn.net/forezp/article/details/83999882">https://blog.csdn.net/forezp/article/details/83999882</a></p>
</blockquote>
</li>
</ul>
]]></content>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring缓存注解@Cacheable @CacheEvict @CachePut的区别和使用</title>
    <url>/2019/04/24/Spring%E7%BC%93%E5%AD%98%E6%B3%A8%E8%A7%A3@Cacheable%20@CacheEvict%20@CachePut%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Spring缓存注解-Cacheable-CacheEvict-CachePut的区别和使用"><a href="#Spring缓存注解-Cacheable-CacheEvict-CachePut的区别和使用" class="headerlink" title="Spring缓存注解@Cacheable @CacheEvict @CachePut的区别和使用"></a>Spring缓存注解@Cacheable @CacheEvict @CachePut的区别和使用</h2><p>启动类注解：</p>
<pre><code>@EnableCaching
</code></pre>
<p>方法上的注解：</p>
<pre><code>@CacheEvict---------------------
@Caching(
        evict = &#123;
                @CacheEvict(cacheNames = &quot;listUmsOrgByUserNo&quot;, allEntries = true),
                @CacheEvict(cacheNames = &quot;all-resource-byuser&quot;, allEntries = true),
                @CacheEvict(cacheNames = &quot;all-role-byuser&quot;, allEntries = true),
                @CacheEvict(cacheNames = &quot;all-user-byrole&quot;, allEntries = true)
        &#125;
)
@Override
public int deleteUmsUserOrgRelate(String id) &#123;
    return mapper.deleteUmsUserOrgRelate(id);
&#125;


Cacheable---------------------
@Override
@Cacheable(cacheNames = &quot;user-tree&quot;, key = &quot;#systemNo+#orgNo+#range&quot;)
public List&lt;HashMap&gt; listUserTree(String systemNo, String orgNo, String range, String isPrimary) &#123;
    return mapper.getUserTrees(systemNo, orgNo, range, isPrimary);
&#125;

Cacheable---------------------
@Cacheable(cacheNames = &quot;user&quot;, key = &quot;#userNo&quot;)
@Override
public UmsUser getUmsUserByNo(String userNo) &#123;
    return mapper.getUmsUserByNo(userNo);
&#125;


@CacheEvict(key = “123”)该注解表示要清除123这个key，作用域可以在类上面@CacheConfig(cacheNames = “product”)声明也可以在方法上面这样声明@CacheEvict(cacheNames = “product”,key = “123”)

@CachePut(cacheNames = “product”,key = “123”)表示对123这个key进行更新。
————————————————
版权声明：本文为CSDN博主「buchicaodetuzi」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_42404323/article/details/94722161
</code></pre>
<p>SpringBus</p>
<pre><code>@Bean(name = Bus.DEFAULT_BUS_ID)
public SpringBus springBus() &#123;
    return new SpringBus();
&#125;
</code></pre>
]]></content>
      <tags>
        <tag>Spring缓存注解</tag>
      </tags>
  </entry>
  <entry>
    <title>UUID</title>
    <url>/2017/05/23/UUID/</url>
    <content><![CDATA[<h2 id="java生成8位UUID做主键"><a href="#java生成8位UUID做主键" class="headerlink" title="java生成8位UUID做主键"></a>java生成8位UUID做主键</h2><ul>
<li><p>java生成8位UUID做主键</p>
<p>  源码文件：</p>
<blockquote>
<p><a href="http://op05inpyd.bkt.clouddn.com/UUIDTest.txt">http://op05inpyd.bkt.clouddn.com/UUIDTest.txt</a></p>
</blockquote>
<p>  源码内容：</p>
<pre><code>  import java.util.UUID;
  
  /**
   * 生成8位UUID做主键
   */
  public class UUIDTest &#123;
      public static void main(String[] args) &#123;
          System.out.println(getShortUuid());
      &#125;

      public static String[] chars = new String[]
              &#123;
                      &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;, &quot;o&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;,
                      &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;,
                      &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;
              &#125;;

      public static String getShortUuid() &#123;
          StringBuffer stringBuffer = new StringBuffer();
          String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);
          for (int i = 0; i &lt; 8; i++) &#123;
              String str = uuid.substring(i * 4, i * 4 + 4);
              int strInteger = Integer.parseInt(str, 16);
              stringBuffer.append(chars[strInteger % 0x3E]);
          &#125;
  
          return stringBuffer.toString().toLowerCase();
      &#125;
  
  &#125;
</code></pre>
</li>
</ul>
<h2 id="java生成普通UUID"><a href="#java生成普通UUID" class="headerlink" title="java生成普通UUID"></a>java生成普通UUID</h2><ul>
<li><p>java生成普通UUID</p>
<pre><code>  import java.util.UUID;
  
  /**
   * java普通UUID
   */
  public class UUIDTest2 &#123;
      public static void main(String[] args) &#123;
          System.out.println(get32UUID());
  
      &#125;
  
      public static String get32UUID() &#123;
          String uuid = UUID.randomUUID().toString().trim().replaceAll(&quot;-&quot;, &quot;&quot;);
          return uuid;
      &#125;
  &#125;
  
  ------------------------------------------------------------------------
  public static void main(String[] args) &#123;
      for (int i = 0; i &lt; 100; i++) &#123;
          //import java.util.UUID;
          String uuidStr = UUID.randomUUID().toString();
          System.out.println(uuidStr);
          System.out.println(uuidStr.replaceAll(&quot;-&quot;, &quot;&quot;));
      &#125;
  &#125;
</code></pre>
</li>
</ul>
]]></content>
      <tags>
        <tag>UUID</tag>
      </tags>
  </entry>
  <entry>
    <title>ab压测模拟高并发</title>
    <url>/2018/05/22/ab%E5%8E%8B%E6%B5%8B%E6%A8%A1%E6%8B%9F%E9%AB%98%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h2 id="用apache-ab压测模拟高并发"><a href="#用apache-ab压测模拟高并发" class="headerlink" title="用apache ab压测模拟高并发"></a>用apache ab压测模拟高并发</h2><ul>
<li><p>工具下载安装</p>
<p>  windows下安装apache,执行压测命令需进入bin目录下再执行压测命令：</p>
<pre><code>  cd C:\mysoft\Apache2.2\bin
  
</code></pre>
<p>  macOS下直接执行压测命令即可（macOS自带apache）</p>
</li>
<li><p>命令</p>
<p>  1.ab -n 100 -c 100 <a href="http://www.baidu.com/">http://www.baidu.com</a></p>
<pre><code>  -n 100 :发出100个请求
  -c 100 :模拟100个并发
  相当于100个人同时访问http://www.baidu.com
</code></pre>
<p>  2.ab -t 60 -c 100 <a href="http://www.baidu.com/">http://www.baidu.com</a></p>
<pre><code>  -t 60 :60秒
  -c 100 :100个并发
  在60秒内不停发请求，一次100个请求
</code></pre>
<blockquote>
<p><a href="https://www.jianshu.com/p/166a4ea8aade">https://www.jianshu.com/p/166a4ea8aade</a></p>
</blockquote>
</li>
</ul>
]]></content>
      <tags>
        <tag>ab压测模拟高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>alfred</title>
    <url>/2019/04/22/alfred/</url>
    <content><![CDATA[<h2 id="alfred使用中出现的问题"><a href="#alfred使用中出现的问题" class="headerlink" title="alfred使用中出现的问题"></a>alfred使用中出现的问题</h2><h3 id="Alfred3的搜索书签功能无法使用"><a href="#Alfred3的搜索书签功能无法使用" class="headerlink" title="Alfred3的搜索书签功能无法使用"></a>Alfred3的搜索书签功能无法使用</h3><p>Mac 的版本是 macOS Mojave 10.14.4，使用 Alfred3的搜索书签功能，发现不能搜索 Safari 和chrome 的书签。</p>
<p>解决办法：<br>在安全隐私设置里面， 完全磁盘访问权限（Full Disk Access） 里面添加Alfred应用。因为 Alfred 是从缓存文件里面读取书签的，所以它需要有这个权限。</p>
]]></content>
      <tags>
        <tag>alfred</tag>
      </tags>
  </entry>
  <entry>
    <title>bash_profile</title>
    <url>/2020/04/24/bash_profile/</url>
    <content><![CDATA[<h2 id="bash-profile"><a href="#bash-profile" class="headerlink" title="bash_profile"></a>bash_profile</h2><pre><code>    PATH=$PATH:/usr/local/mysql/bin
    
    # 设置 JDK 6
    #export JAVA_6_HOME=`/usr/libexec/java_home -v 1.6`
    
    # 设置 JDK 7 
    export JAVA_7_HOME=`/usr/libexec/java_home -v 1.7.0_80`
      
    # 设置 JDK 8  
    export JAVA_8_HOME=`/usr/libexec/java_home -v 1.8.0_172`
    # 可添加其他版本 
    
    #默认JDK 7 
    export JAVA_HOME=$JAVA_8_HOME  
    
    #alias命令动态切换JDK版本   
    #alias jdk6=&quot;export JAVA_HOME=$JAVA_6_HOME&quot; 
    alias jdk7=&quot;export JAVA_HOME=$JAVA_7_HOME&quot;  
    alias jdk8=&quot;export JAVA_HOME=$JAVA_8_HOME&quot;
     
    export M2_HOME=/Users/ux/Applications/apache-maven-3.5.4
    export PATH=$PATH:$M2_HOME/bin
    
    ##GO环境配置
    export GOPATH=/Users/ux/code/go
    export GOBIN=$GOPATH/bin
    export PATH=$PATH:$GOBIN
    
    
    # Setting PATH for Python 3.7
    # The original version is saved in .bash_profile.pysave
    PATH=&quot;/Library/Frameworks/Python.framework/Versions/3.7/bin:$&#123;PATH&#125;&quot;
    export PATH
    
    ##添加别名 执行python命令时默认python3
    alias python=&quot;/Library/Frameworks/Python.framework/Versions/3.7/bin/python3&quot;
</code></pre>
]]></content>
      <tags>
        <tag>bash_profile</tag>
      </tags>
  </entry>
  <entry>
    <title>centos6下安装mysql5.7</title>
    <url>/2018/04/26/centos6%E4%B8%8B%E5%AE%89%E8%A3%85mysql5-7/</url>
    <content><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><ul>
<li><p>卸载系统自带的MySql</p>
<pre><code>  查看是否已经安装了mysql
  rpm -qa | grep mysql

  普通删除模式
  rpm -e mysql-libs-5.1.66-2.el6_3.x86_64
  
  强力删除模式，如果使用上面命令删除时，提示有依赖的其它文件，则用该命令可以对其进行强力删除
  rpm -e --nodeps mysql-libs-5.1.66-2.el6_3.x86_64
  
</code></pre>
<blockquote>
<p><a href="https://www.cnblogs.com/MIC2016/p/7117854.html">https://www.cnblogs.com/MIC2016/p/7117854.html</a></p>
</blockquote>
</li>
<li><p>下载rpm安装包</p>
<blockquote>
<p><a href="https://dev.mysql.com/downloads/mysql/">https://dev.mysql.com/downloads/mysql/</a></p>
</blockquote>
<p>  操作系统选red hat,否则没有rpm版本。</p>
</li>
<li><p>安装准备</p>
<p>  将下载的tar安装包传输到centos中，命令格式如下：</p>
<pre><code>  scp -P 22 source user@ip:/desition
  
  解压tar文件
  
  tar -xf mysql5.7.tar
  
  得到下面几个rpm包：
  
  mysql-community-client-5.7.22-1.el6.x86_64.rpm
  mysql-community-common-5.7.22-1.el6.x86_64.rpm
  mysql-community-devel-5.7.22-1.el6.x86_64.rpm
  mysql-community-embedded-5.7.22-1.el6.x86_64.rpm
  mysql-community-embedded-devel-5.7.22-1.el6.x86_64.rpm
  mysql-community-libs-5.7.22-1.el6.x86_64.rpm
  mysql-community-libs-compat-5.7.22-1.el6.x86_64.rpm
  mysql-community-server-5.7.22-1.el6.x86_64.rpm
  mysql-community-test-5.7.22-1.el6.x86_64.rpm
  
  
</code></pre>
</li>
<li><p>安装</p>
<pre><code>  如果直接执行mysql-server：
  rpm -ivh mysql-community-server-5.7.22-1.el6.x86_64.rpm
  会无法安装，并提示安装前需要先安装libs、common、以及namactl相关
  
  需要先安装依赖：
  
  yum install numactl
  rpm -ivh mysql-community-common-5.7.22-1.el6.x86_64.rpm
  rpm -ivh mysql-community-libs-5.7.22-1.el6.x86_64.rpm
  rpm -ivh mysql-community-client-5.7.22-1.el6.x86_64.rpm

  安装外依赖后再安装mysql-server:
  
  rpm -ivh mysql-community-server-5.7.22-1.el6.x86_64.rpm
  
</code></pre>
</li>
<li><p>初始化</p>
<pre><code>  mysqld --initialize --user=mysql
  初始化后到/var/log/查看mysqld.log，找到默认密码：
  cat /var/log/mysqld.log
  
</code></pre>
</li>
<li><p>注册服务，开机自启数据库</p>
<pre><code>  安装完初始化后并不能直接使用service mysqld start命令启动数据库，可以使用完整路径启动数据库：
  
  /etc/rc.d/init.d/mysqld start
  
  设置mysql开机启动
  chkconfig mysqld on 
  
  修改mysqld执行权限
  chmod 755 /etc/rc.d/init.d/mysqld
  
  启动：
  service mysqld start
  
</code></pre>
<blockquote>
<p><a href="http://www.ctohome.com/FuWuQi/aa/511.html">http://www.ctohome.com/FuWuQi/aa/511.html</a></p>
</blockquote>
</li>
</ul>
<p>###如果初始密码无法使用，重置密码</p>
<ul>
<li><p>重置方式</p>
<pre><code>  /etc/my.cnf下添加（有的Linux版本是/etc/mysql/mysql.conf.d/mysqld.cnf）：
  skip-grant-tables
  
  保存后刷新配置：
  flush privileges;

  此时mysql -u root -p直接回车就能登录数据库了
      
</code></pre>
</li>
<li><p>登录过后从新设置密码</p>
<pre><code>  update mysql.user set authentication_string=password(&#39;新密码&#39;) where user=&#39;root&#39;;
      
</code></pre>
</li>
<li><p>复原/etc/my.cnf</p>
<pre><code>  将/etc/my.cnf下的skip-grant-tables注释掉
</code></pre>
</li>
</ul>
<h3 id="表名不区分大小写配置"><a href="#表名不区分大小写配置" class="headerlink" title="表名不区分大小写配置"></a>表名不区分大小写配置</h3><ul>
<li>安装后如果在查询时表名区分大小写了，配置一下<pre><code>  /etc/my.cnf下的[mysqld]下加：
  
  #（设置查询表名不区分大小写）
  lower_case_table_names=1
  
</code></pre>
<blockquote>
<p><a href="https://www.cnblogs.com/MIC2016/p/7117854.html">https://www.cnblogs.com/MIC2016/p/7117854.html</a></p>
</blockquote>
</li>
</ul>
<h3 id="远程连接设置"><a href="#远程连接设置" class="headerlink" title="远程连接设置"></a>远程连接设置</h3><ul>
<li><p>修改配置使数据库可以被远程连接</p>
<pre><code>  update user set host = &#39;%&#39; where user = &#39;root&#39; and host = &#39;localhost&#39;;
  flush privileges;
</code></pre>
</li>
</ul>
<h3 id="刷新配置命令"><a href="#刷新配置命令" class="headerlink" title="刷新配置命令"></a>刷新配置命令</h3><ul>
<li><p>命令</p>
<pre><code>  flush privileges;

  

  
  
  
  
  


  
</code></pre>
</li>
</ul>
]]></content>
      <tags>
        <tag>centos安装mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>DB2相关</title>
    <url>/2017/09/04/db2%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h2 id="DB2编辑节点"><a href="#DB2编辑节点" class="headerlink" title="DB2编辑节点"></a>DB2编辑节点</h2><ul>
<li><p><strong>调出db2 CLP</strong></p>
<pre><code>  windows cmd下执行
  db2cmd或db2cw
  调出db2 CLP
</code></pre>
</li>
<li><p><strong>编辑节点：</strong></p>
<pre><code>  &lt;格式&gt;
  catalog tcpip node db2node remote hostname server service_port
  &lt;实例&gt;
  catalog tcpip node node1 remote 30.31.32.33 server 50000

  &lt;格式&gt;
  catalog database db_name as alias_name at node db2node
      db_name是指远程数据库的名字，
      alias_name是客户端实例名，
      db2node是指上面你所指定的node。

  &lt;实例&gt;
  catalog database db1 as tc1 at node node1
</code></pre>
</li>
<li><p><strong>连接测试</strong></p>
<pre><code>  &lt;格式&gt;
  connect to 数据库名 user 用户名 Using 密码    
  connect to tc1
</code></pre>
</li>
</ul>
]]></content>
      <tags>
        <tag>db2</tag>
      </tags>
  </entry>
  <entry>
    <title>discuz论坛用户账号批量导入</title>
    <url>/2018/01/02/discuz%E8%AE%BA%E5%9D%9B%E7%94%A8%E6%88%B7%E8%B4%A6%E5%8F%B7%E6%89%B9%E9%87%8F%E5%AF%BC%E5%85%A5/</url>
    <content><![CDATA[<h2 id="脚本文件"><a href="#脚本文件" class="headerlink" title="脚本文件"></a>脚本文件</h2><ul>
<li><p>Python脚本</p>
<blockquote>
<p><a href="http://ogy57hyu6.bkt.clouddn.com/discuz.py.txt">http://ogy57hyu6.bkt.clouddn.com/discuz.py.txt</a></p>
</blockquote>
</li>
</ul>
<h2 id="用户信息源"><a href="#用户信息源" class="headerlink" title="用户信息源"></a>用户信息源</h2><p>用户信息文件按顺序存储用户信息（用户名，密码，邮箱，用户组，是否通知，addsubmit）。可以按如下两种方式组织(以以下格式复制到txt文本中即可)：</p>
<ul>
<li><p>包含全部信息</p>
<pre><code>  usr1,123456,usr1@usr.com,10,0,addsubmit
  usr2,123456,usr2@usr.com,10,0,addsubmit
  usr3,123456,usr3@usr.com,10,0,addsubmit
  usr4,123456,usr4@usr.com,10,0,addsubmit
</code></pre>
</li>
<li><p>也可以只需要部分信息</p>
<pre><code>  usr1,123456,usr1@usr.com
  usr2,123456,usr2@usr.com
  usr3,123456,usr3@usr.com
  usr4,123456,usr4@usr.com
      
</code></pre>
</li>
<li><p>txt文本</p>
<blockquote>
<p><a href="http://ogy57hyu6.bkt.clouddn.com/user.txt">http://ogy57hyu6.bkt.clouddn.com/user.txt</a></p>
</blockquote>
</li>
<li><p>说明</p>
</li>
</ul>
<p>访问此链接即可查看添加新用户所需要填写的选项：</p>
<pre><code>http://192.168.1.111/bbs/admin.php?frames=yes&amp;action=members&amp;operation=add

192.168.1.111 是discuz所在服务器ip
bbs 是discuz部署在服务器上的名称
</code></pre>
<h2 id="脚本执行说明"><a href="#脚本执行说明" class="headerlink" title="脚本执行说明"></a>脚本执行说明</h2><ul>
<li>执行环境：Python2.7</li>
<li>执行命令：./discuz.py</li>
</ul>
<h2 id="脚本相应调整"><a href="#脚本相应调整" class="headerlink" title="脚本相应调整"></a>脚本相应调整</h2><ul>
<li><p>根据具体环境需要作出的调整</p>
<ul>
<li><p>1.main函数中（在130行）:</p>
<pre><code>  file = &#39;/Users/ux/py/dis/user.txt&#39;
  home_url = &#39;http://192.168.1.147/bbs/admin.php&#39;
  admin = &#39;ux&#39;
  pwd = &#39;ux123456&#39;

  file：需要被导入的用户信息的txt文本路径
  home_url：管理后台的访问路径
  admin：管理员的登录名
  pwd：管理员的登录密码
</code></pre>
</li>
<li><p>2.对应的host修改（29行）:</p>
<pre><code>  &quot;Host&quot;:&quot;192.168.1.111&quot;, 

  将host修改为与home_url中一致的IP即可
</code></pre>
</li>
</ul>
</li>
<li><p>个别用户添加失败解决方法</p>
<pre><code>  找到Discuz的数据表pre_common_member，
  查找与添加失败的用户email一致的记录，删除或修改即可。
</code></pre>
</li>
</ul>
<h2 id="查询并导出符合discuz-py要求的用户数据"><a href="#查询并导出符合discuz-py要求的用户数据" class="headerlink" title="查询并导出符合discuz.py要求的用户数据"></a>查询并导出符合discuz.py要求的用户数据</h2><ul>
<li><p>mysql:</p>
<pre><code>  SELECT CONCAT(username,&#39;,&#39;),CONCAT(password,&#39;,&#39;),CONCAT(username,&quot;@email.com&quot;) AS email 
  FROM pre_ucenter_members;
</code></pre>
</li>
<li><p>db2:</p>
<pre><code>  SELECT CONCAT(name,&#39;,&#39;),CONCAT(pwd,&#39;,&#39;),CONCAT(name,&#39;@user.com&#39;) AS email 
  FROM PersonInfo
  WHERE Active=&#39;1&#39;;    
</code></pre>
</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><blockquote>
<p><a href="http://blog.csdn.net/zhongping136/article/details/46730191">http://blog.csdn.net/zhongping136/article/details/46730191</a><br><a href="http://blog.csdn.net/change518/article/details/50555301">http://blog.csdn.net/change518/article/details/50555301</a>    </p>
</blockquote>
]]></content>
      <tags>
        <tag>discuz用户批量导入</tag>
      </tags>
  </entry>
  <entry>
    <title>docker下安装jenkins</title>
    <url>/2021/07/01/docker%E4%B8%8B%E5%AE%89%E8%A3%85jenkins/</url>
    <content><![CDATA[<h2 id="安装jenkins并挂载目录"><a href="#安装jenkins并挂载目录" class="headerlink" title="安装jenkins并挂载目录"></a>安装jenkins并挂载目录</h2><ul>
<li><p>从dockerhub获取镜像并安装jenkins</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -itd --name jenkins -p 9001:8080 -p 9002:50000 -v /Users/ux/Applications/docker/jenkins/jenkins_home:/var/jenkins_home jenkins/jenkins</span><br></pre></td></tr></table></figure></li>
<li><p>从jenkins的安装日志上找到admin的初始密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*************************************************************</span><br><span class="line">*************************************************************</span><br><span class="line">*************************************************************</span><br><span class="line">Jenkins initial setup is required. An admin user has been created and a password generated.</span><br><span class="line">Please use the following password to proceed to installation:</span><br><span class="line">3d3f3166b89a47e58939b4573f4b2133</span><br><span class="line">This may also be found at: /var/jenkins_home/secrets/initialAdminPassword</span><br><span class="line">*************************************************************</span><br><span class="line">*************************************************************</span><br><span class="line">*************************************************************</span><br></pre></td></tr></table></figure></li>
<li><p>或者进入docker容器找到初始密码(或者直接在宿主机挂载目录找到对应文件，查看初始密码)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#进入jenkins容器</span><br><span class="line">docker exec -it jenkins /bin/bash</span><br><span class="line">#查看/var/jenkins_home/secrets/initialAdminPassword文件内容</span><br><span class="line">cat /var/jenkins_home/secrets/initialAdminPassword</span><br><span class="line">#得到初始admin密码为：3d3f3166b89a47e58939b4573f4b2133</span><br></pre></td></tr></table></figure></li>
<li><p>初始化时选择“install suggested plugins”报错：An error occurred during installation: No such plugin: cloudbees-folder</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 如果是直接从dockerhub搜索jenkins，并且选择使用了jenkins，而不是jenkins/jenkins下的镜像包，则在初始化时会报错，原因是jenkins版本太低。(从官网跳转的链接发现)拉取jenkins/jenkins下的镜像安装即可。</span><br><span class="line"> </span><br><span class="line">docker run -itd --name jenkins -p 9001:8080 -p 9002:50000 -v /Users/ux/Applications/docker/jenkins/jenkins_home:/var/jenkins_home jenkins</span><br><span class="line"></span><br><span class="line">An error occurred during installation: No such plugin: cloudbees-folder</span><br><span class="line">初始化时报没有这个插件错误</span><br></pre></td></tr></table></figure></li>
<li><p>参考文档</p>
<blockquote>
<p><a href="https://www.jenkins.io/download">https://www.jenkins.io/download</a></p>
</blockquote>
</li>
</ul>
<blockquote>
<p><a href="https://registry.hub.docker.com/_/jenkins">https://registry.hub.docker.com/_/jenkins</a></p>
</blockquote>
<ul>
<li> 无效解决方案</li>
</ul>
<blockquote>
<p><a href="https://aflyun.blog.csdn.net/article/details/103338558">https://aflyun.blog.csdn.net/article/details/103338558</a></p>
</blockquote>
<h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h2><ul>
<li>Maven Integration（构建工具）</li>
<li>SonarQube Scanner（代码审查）</li>
<li>Publish Over SSH（将构建结果发布到远程服务器用）</li>
<li>GitLab</li>
<li>Deploy to container</li>
<li>docker-build-step</li>
<li>Docker</li>
<li><a href="https://plugins.jenkins.io/docker-workflow">Docker Pipeline</a></li>
<li><a href="https://plugins.jenkins.io/docker-slaves">Docker Slaves</a></li>
<li><a href="https://plugins.jenkins.io/docker-compose-build-step"> Docker Compose Build Step</a></li>
</ul>
<blockquote>
<p><a href="https://www.freesion.com/article/9270779025">https://www.freesion.com/article/9270779025</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>docker下安装jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>docker下安装portainer2</title>
    <url>/2021/05/01/docker%E4%B8%8B%E5%AE%89%E8%A3%85portainer2/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><blockquote>
<p><a href="https://www.docker.com/products/docker-toolbox">https://www.docker.com/products/docker-toolbox</a></p>
</blockquote>
<blockquote>
<p><a href="https://hub.docker.com/explore/">https://hub.docker.com/explore/</a></p>
</blockquote>
<blockquote>
<p><a href="https://c.163.com/">https://c.163.com/</a></p>
</blockquote>
<h2 id="使用命令"><a href="#使用命令" class="headerlink" title="使用命令"></a>使用命令</h2><p>未完待续…</p>
<h2 id="docker可视化portainer2-x安装"><a href="#docker可视化portainer2-x安装" class="headerlink" title="docker可视化portainer2.x安装"></a>docker可视化portainer2.x安装</h2><ul>
<li>docker下安装portainer2.x(自启动方式restart=always)  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -p 9000:9000 --restart=always --name portainer -v /var/run/docker.sock:/var/run/docker.sock -v /Users/ux/Applications/docker/portainer2/data:/data portainer/portainer-ce</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>docker下安装portainer2</tag>
      </tags>
  </entry>
  <entry>
    <title>docker下安装nexus</title>
    <url>/2021/07/04/docker%E4%B8%8B%E5%AE%89%E8%A3%85nexus/</url>
    <content><![CDATA[<h2 id="docker下安装nexus"><a href="#docker下安装nexus" class="headerlink" title="docker下安装nexus"></a>docker下安装nexus</h2><ul>
<li><p>安装命令，将data挂载到宿主机</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -p 9009:8081 --name nexus -v /Users/ux/Applications/docker/nexus/nexus-data:/nexus-data sonatype/nexus3</span><br></pre></td></tr></table></figure></li>
<li><p>查看初始密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it 550dd77a89e1 /bin/bash</span><br><span class="line">cat /nexus-data/admin.password</span><br></pre></td></tr></table></figure></li>
<li><p>访问访问nexus并根据初始密码更改密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:9009</span><br><span class="line">admin</span><br><span class="line">输入上一步中cat /nexus-data/admin.password看到的密码，然后会提示设置新密码</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://blog.csdn.net/linpxing1/article/details/108378323">https://blog.csdn.net/linpxing1/article/details/108378323</a></p>
</blockquote>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>docker下安装rocketMQ</title>
    <url>/2021/08/01/docker%E4%B8%8B%E5%AE%89%E8%A3%85rocketMQ/</url>
    <content><![CDATA[<h2 id="docker下安装rocketMQ"><a href="#docker下安装rocketMQ" class="headerlink" title="docker下安装rocketMQ"></a>docker下安装rocketMQ</h2><h3 id="安装NameServer"><a href="#安装NameServer" class="headerlink" title="安装NameServer"></a>安装NameServer</h3><ul>
<li><p>拉取镜像并启动(以挂载配置文件等到宿主机的形式启动)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -p 9876:9876 \</span><br><span class="line">-v /Users/ux/Applications/docker/rocketmq4.5/rocketmq-namesrv/logs:/root/logs \</span><br><span class="line">-v /Users/ux/Applications/docker/rocketmq4.5/rocketmq-namesrv/store:/root/store \</span><br><span class="line">--name rmqserver foxiswho/rocketmq:server-4.5.1</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="安装broker"><a href="#安装broker" class="headerlink" title="安装broker"></a>安装broker</h3><ul>
<li><p>拉取镜像并启动(以挂载配置文件等到宿主机的形式启动)</p>
<p><strong>注：首先要在宿主机路径下创建好broker.conf文件</strong></p>
<p><strong>路径：/Users/ux/Applications/docker/rocketmq4.5/rocketmq-broker/conf/</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -p 10911:10911 -p 10909:10909 \</span><br><span class="line">--name rmqbroker \</span><br><span class="line">--link rmqserver:namesrv \</span><br><span class="line">-e &quot;NAMESRV_ADDR=namesrv:9876&quot; \</span><br><span class="line">-e &quot;JAVA_OPTS=-Duser.home=/opt&quot; \</span><br><span class="line">-e &quot;JAVA_OPT_EXT=-server -Xms128m -Xmx128m&quot; \</span><br><span class="line">-v /Users/ux/Applications/docker/rocketmq4.5/rocketmq-broker/conf/broker.conf:/etc/rocketmq/broker.conf \</span><br><span class="line">-v /Users/ux/Applications/docker/rocketmq4.5/rocketmq-broker/logs:/root/logs \</span><br><span class="line">-v /Users/ux/Applications/docker/rocketmq4.5/rocketmq-broker/store:/root/store \</span><br><span class="line">-v /Users/ux/Applications/docker/rocketmq4.5/rocketmq-broker/conf/broker.conf:/opt/rocketmq-4.5.1/conf/broker.conf \</span><br><span class="line">foxiswho/rocketmq:broker-4.5.1</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="rocketmq-console-可视化控制台"><a href="#rocketmq-console-可视化控制台" class="headerlink" title="rocketmq console 可视化控制台"></a>rocketmq console 可视化控制台</h3><ul>
<li><p>拉取镜像(可缺省步骤)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull styletang/rocketmq-console-ng</span><br></pre></td></tr></table></figure></li>
<li><p>运行容器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d --name rmqconsole -p 8180:8080 \</span><br><span class="line">--link rmqserver:namesrv \</span><br><span class="line">-e &quot;JAVA_OPTS=-Drocketmq.namesrv.addr=namesrv:9876 \</span><br><span class="line">-Dcom.rocketmq.sendMessageWithVIPChannel=false&quot; \</span><br><span class="line">-t apacherocketmq/rocketmq-console:2.0.0</span><br></pre></td></tr></table></figure></li>
<li><p>运行容器(其他镜像源)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##其他镜像源</span><br><span class="line">-t styletang/rocketmq-console-ng</span><br><span class="line"></span><br><span class="line">##没什么卵用 --link rmqbroker:rmqbroker \ </span><br><span class="line">docker run -d --name rmqconsole -p 8180:8080 \</span><br><span class="line">--link rmqserver:namesrv \</span><br><span class="line">--link rmqbroker:rmqbroker \</span><br><span class="line">-e &quot;JAVA_OPTS=-Drocketmq.namesrv.addr=namesrv:9876 \</span><br><span class="line">-Dcom.rocketmq.sendMessageWithVIPChannel=false&quot; \</span><br><span class="line">-t apacherocketmq/rocketmq-console:2.0.0</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="当NameServer和broker、console都分别以docker容器运行的时候，需要增加broker-conf配置"><a href="#当NameServer和broker、console都分别以docker容器运行的时候，需要增加broker-conf配置" class="headerlink" title="当NameServer和broker、console都分别以docker容器运行的时候，需要增加broker.conf配置"></a>当NameServer和broker、console都分别以docker容器运行的时候，需要增加broker.conf配置</h3><ul>
<li><p>brokerIP1和namesrvAddr配置【直接拷贝，替换ip即可】</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 配置为brokerIP1=127.0.0.1，如果namesrv，broker和console都安装在docker，会造成console访问不到namesrv</span><br><span class="line"># brokerIP1=127.0.0.1</span><br><span class="line"># 192.168.1.101是本机ip</span><br><span class="line">brokerIP1=192.168.1.101</span><br><span class="line"></span><br><span class="line"># 注释掉，mq会正常，【可能】自动创建topic会失效，即namesrv和broker通信失败，【实测后发现不配置也正常自动创建】</span><br><span class="line"># namesrvAddr=127.0.0.1:9876</span><br><span class="line"># 192.168.1.101是本机ip</span><br><span class="line"># namesrvAddr=192.168.1.101:9876</span><br><span class="line"></span><br><span class="line"># ---------------------------------说明----------------------------------------------------</span><br><span class="line"># 注意：</span><br><span class="line"></span><br><span class="line"># 如果不配置brokerIP1，则会使用docker内部分配的ip，即172.17.0.3这种，外部系统调用mq服务，是调用不到的；</span><br><span class="line"># 如果配置brokerIP1=127.0.0.1，如果外部系统调用mq服务，也是调用不到的。</span><br><span class="line"></span><br><span class="line"># 如果不配置namesrvAddr，诸如autoCreateTopicEnable配置为true时，可能不#会生效的。</span><br><span class="line"># 如果namesrvAddr配置为:namesrvAddr=127.0.0.1:9876,则在console里是看不到namesrv服务的。</span><br><span class="line"></span><br><span class="line"># ---------------------------------broker启动日志，观察连接的namesrv---------------------------</span><br><span class="line"># broker启动日志：</span><br><span class="line"># The broker[6c357964d9e9, 192.168.1.101:10911] boot success. serializeType=JSON and name </span><br><span class="line"># server is 192.168.1.101:9876</span><br><span class="line"># The broker[6c357964d9e9, 192.168.1.101:10911] boot success. serializeType=JSON and name </span><br><span class="line"># server is 127.0.0.1:9876</span><br><span class="line"># The broker[6c357964d9e9, 192.168.1.101:10911] boot success. serializeType=JSON and name </span><br><span class="line"># server is namesrv:9876</span><br><span class="line"></span><br><span class="line"># ---------------------------------以docker的通信隔离为基础去思考即可---------------------------</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>docker下安装rocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>docker下安装wordpress</title>
    <url>/2021/06/05/docker%E4%B8%8B%E5%AE%89%E8%A3%85wordpress/</url>
    <content><![CDATA[<h2 id="Docker安装wordpress"><a href="#Docker安装wordpress" class="headerlink" title="Docker安装wordpress"></a>Docker安装wordpress</h2><h3 id="docker下mysql和wpress"><a href="#docker下mysql和wpress" class="headerlink" title="docker下mysql和wpress"></a>docker下mysql和wpress</h3><ul>
<li><p>1.docker下安装mysql作为数据存储</p>
<pre><code>  docker安装wordpress前需要先安装mysql,这里把mysql也安装在docker下。
  关于docker安装mysql这里不再详细说明，搜索另一篇docker下安装mysql即可。
  mysql容器名定为mysql
</code></pre>
</li>
<li><p>2.docker下安装wordpress</p>
<pre><code>  1.拉取wordpress镜像
  docker pull wordpress
  2.启动镜像
  docker run -d --name wpress -p 9999:80 wordpress

  docker run：启动容器
  -d：后台运行容器
  –-name wpress：指定容器的名字，本文设置为wpress
  -p 9999:80：端口映射，这里将容器内的80端口映射&lt;/code&gt;&lt;/pre&gt;
  &lt;pre&gt;&lt;code&gt;到docker宿主机的9999端口
  - wordpress：镜像的名字，首先从docker宿主机本地加载，其次从dockerHub上加载

  或者可以在docker desktop里设置端口9999，名称wpress启动容器
</code></pre>
</li>
</ul>
<h3 id="mysql和wpress容器加入同一个网络组"><a href="#mysql和wpress容器加入同一个网络组" class="headerlink" title="mysql和wpress容器加入同一个网络组"></a>mysql和wpress容器加入同一个网络组</h3><ul>
<li><p>3.将mysql容器和wpress容器加入同一个网络组，否则wpress容器无法访问mysql数据库</p>
<pre><code>  1.创建名为macbridge的网络：
  docker network create -d bridge macbridge

  2.查看已经存在的网络组
  docker network ls
  
  3.查看macbridge中加入的容器
  docker network inspect macbridge
  
  4.将mysql容器加入到网络组
  docker network connect macbridge mysql
  
  5.将wpress容器加入到网络组
  docker network connect macbridge wpress
  
  ps.将mysql容器移出macbridge网络组(这里不要移除，这只是一个移出的示范命令)
  docker network disconnect macbridge mysql
</code></pre>
</li>
</ul>
<h3 id="初始化wpress"><a href="#初始化wpress" class="headerlink" title="初始化wpress"></a>初始化wpress</h3><ul>
<li><p>4.wpress容器启动完成后，进行初始化设置</p>
<pre><code>  要先在mysql中创建一个数据库用于wordpress初始化时连接，
  这里创建名为wordpress的数据库。
  
  本地访问localhost:9999即可进入初始化界面，进行初始化设置，
  注意，mysql地址那里填写容器名mysql:3306即可。
  
</code></pre>
<p>  <img src="/2021/06/05/docker%E4%B8%8B%E5%AE%89%E8%A3%85wordpress/01wordpress%E8%BF%9E%E6%8E%A5mysql.png"></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title>docker安装mysql</title>
    <url>/2021/06/15/docker%E5%AE%89%E8%A3%85mysql/</url>
    <content><![CDATA[<h2 id="docker下安装mysql"><a href="#docker下安装mysql" class="headerlink" title="docker下安装mysql"></a>docker下安装mysql</h2><ul>
<li><p>docker安装mysql</p>
<pre><code>  #1.mysql5.7:不挂载 配置文件、data和日志到宿主机        docker run -itd --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123 mysql:5.7.33 --lower_case_table_names=1
  
  #2.mysql5.7:配置文件、data和日志挂载方式运行容器
  docker run --name mysql5.7 -p 3306:3306 -v /Users/ux/Applications/docker/mysql5.7/data:/var/lib/mysql -v /Users/ux/Applications/docker/mysql5.7/conf:/etc/mysql/conf.d -v /Users/ux/Applications/docker/mysql5.7/logs:/var/log/mysql -e MYSQL_ROOT_PASSWORD=12306 -d mysql5.7:config_v1
  
  ============================================================================================
  
  #1.mysql8:不挂载 配置文件、data和日志到宿主机
  docker run -itd --name mysql8 -p 3307:3306 -e MYSQL_ROOT_PASSWORD=123 mysql:8.0.25 --lower_case_table_names=1
  
  #2.mysql8:配置文件、data和日志挂载方式运行容器
  docker run --name mysql8.0 -p 3307:3306 -v /Users/ux/Applications/docker/mysql8/data:/var/lib/mysql -v /Users/ux/Applications/docker/mysql8/conf:/etc/mysql/conf.d -v /Users/ux/Applications/docker/mysql8/logs:/var/log/mysql -e MYSQL_ROOT_PASSWORD=12306 -d mysql8:config_v1
  
  lower_case_table_names=1： 设置不区分大小
</code></pre>
</li>
<li><p>安装时没设置不区分大小写的补救措施：</p>
<pre><code>  或者在mysql安装后再修改：
  
  1.进入 docker 容器 mysql
      docker exec -it mysql  /bin/bash
  2.配置镜像源安装 VIM
      mv /etc/apt/sources.list /etc/apt/sources.list.bak   ---可缺省的异步
      apt-get update
      apt-get install vim
      
       apt-get update，这个命令的作用是：同步 /etc/apt/sources.list 和 /etc/apt/sources.list.d 中列出的源的索引，这样才能获取到最新的软件包。
      等更新完毕以后再敲命令：apt-get install vim命令即可
      
  3.编辑/etc/mysql/mysql.conf.d/mysqld.cnf 文件
      #[mysqld]后添加 
      lower_case_table_names=1
      
  4、重启应用
      
      #容器中执行
      service mysql restart
      
      #或者退出容器直接重启mysql容器
      docker restart mysql
      
      #或者通过docker客户端手动操作
</code></pre>
<p>  ​<br>  参考链接：<a href="https://ld246.com/article/1554211578902">https://ld246.com/article/1554211578902</a></p>
</li>
<li><p>默认字符集修改</p>
<pre><code>  打开终端执行命令：
  docker exec -it mysql  /bin/bash
  进入/etc，执行ls -a 查看有没有my.cnf文件，没有则创建my.cnf:
  
  vim /etc/my.cnf ，输入计算机管理员密码，创建my.cnf文件，并复制
  
  [client]
  default-character-set=utf8
  [mysqld]
  character-set-server=utf8
  
  按下esc按键，输入:wq保存退出即可。
  重启mysql服务，OK。
</code></pre>
</li>
<li><p>MySQL-this is incompatible with sql_mode=only_full_group_by错误解决方案</p>
<p>  一、查看sql_mode的语句如下</p>
<pre><code>  select @@GLOBAL.sql_mode;
</code></pre>
<p>  二、解决方案一：</p>
<pre><code>  sql语句暂时性修改sql_mode。重启mysql数据库服务之后，ONLY_FULL_GROUP_BY还会出现。
  
  set @@GLOBAL.sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION

 解决方案2.

     需修改mysql配置文件，通过手动添加sql_mode的方式强制指定不需要ONLY_FULL_GROUP_BY属性，
     
     my.cnf位于etc文件夹下，vim下光标移到最后，添加如下：
    
     sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION    
</code></pre>
<blockquote>
<p><a href="https://blog.csdn.net/qq_42175986/article/details/82384160">https://blog.csdn.net/qq_42175986/article/details/82384160</a></p>
</blockquote>
</li>
</ul>
<h3 id="mysql服务设置远程连接-解决1251-client-does-not-support问题"><a href="#mysql服务设置远程连接-解决1251-client-does-not-support问题" class="headerlink" title="mysql服务设置远程连接 解决1251 client does not support问题"></a>mysql服务设置远程连接 解决1251 client does not support问题</h3><ul>
<li><p>虽然在mysql容器安装启动时已经设置过密码为123，但是只能在命令行通过123登录，navicat依然无法登陆：</p>
<pre><code>  docker容器初始化时设置密码为123：
  
  docker run -itd --name mysql8 -p 3307:3306 -e MYSQL_ROOT_PASSWORD=123 mysql:8.0.25 --lower_case_table_names=1
  
  1.先从docker容器里登录mysql
  
      mysql -u root -p
      
  2.查看用户信息 
  select host,user,plugin,authentication_string from mysql.user; 
  
  注意：host为 % 表示不限制ip   
       localhost表示本机使用    
       plugin非mysql_native_password 则需要修改密码！！！
       
  3.修改用户密码 
  
  ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;123&#39;; #更新一下用户的密码 root用户密码为123
  
  4.再次使用navicat即可连接
</code></pre>
<blockquote>
<p><a href="https://blog.csdn.net/qq_22211217/article/details/80415248">https://blog.csdn.net/qq_22211217/article/details/80415248</a></p>
</blockquote>
<h3 id="更改容器自启动"><a href="#更改容器自启动" class="headerlink" title="更改容器自启动"></a>更改容器自启动</h3></li>
<li><p>设置开机启动mysql (mysql8为我的mysql容器名)</p>
<pre><code>  docker update mysql8 --restart=always
</code></pre>
</li>
<li><p>关闭开机启动mysql (mysql8为我的mysql容器名)</p>
<pre><code>  docker update mysql8 --restart=no
</code></pre>
<h2 id="基于mysql原有镜像，增加配置文件后的容器，制作新镜像并运行"><a href="#基于mysql原有镜像，增加配置文件后的容器，制作新镜像并运行" class="headerlink" title="基于mysql原有镜像，增加配置文件后的容器，制作新镜像并运行"></a>基于mysql原有镜像，增加配置文件后的容器，制作新镜像并运行</h2></li>
</ul>
<h3 id="mysql5-7"><a href="#mysql5-7" class="headerlink" title="mysql5.7"></a>mysql5.7</h3><ul>
<li><p>1.以commit方式制作新镜像</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker commit -a <span class="string">&quot;uxawseny&quot;</span> -m <span class="string">&quot;mysql with config&quot;</span> <span class="number">2</span>c974cde0cac mysql5.<span class="number">7</span>:config_v1</span><br></pre></td></tr></table></figure></li>
<li><p>2.将容器中MySQL的3306端口映射到本地的3306端口，挂载宿主机目录到容器目录，并设置登录密码为：123</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> --name mysql5.7 -p 3306:3306 -v /Users/ux/Applications/docker/mysql5.7/data:/var/lib/mysql -v /Users/ux/Applications/docker/mysql5.7/conf:/etc/mysql/conf.d -v /Users/ux/Applications/docker/mysql5.7/logs:/var/<span class="built_in">log</span>/mysql -e MYSQL_ROOT_PASSWORD=123 -d mysql5.7:config_v1</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="mysql8"><a href="#mysql8" class="headerlink" title="mysql8"></a>mysql8</h3><ul>
<li><p>1.以commit方式制作新镜像</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker commit -a <span class="string">&quot;uxawseny&quot;</span> -m <span class="string">&quot;mysql8 with config&quot;</span> 【<span class="number">6</span>ed746769e85容器id】 mysql8:config_v1</span><br></pre></td></tr></table></figure></li>
<li><p>2.将容器中MySQL的3306端口映射到本地的3307端口，挂载宿主机目录到容器目录，并设置登录密码为：123</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --name mysql8.0 -p 3307:3306 -v /Users/ux/Applications/docker/mysql8/data:/var/lib/mysql -v /Users/ux/Applications/docker/mysql8/conf:/etc/mysql/conf.d -v /Users/ux/Applications/docker/mysql8/logs:/var/log/mysql -e MYSQL_ROOT_PASSWORD=123 -d mysql8:config_v1</span><br></pre></td></tr></table></figure>

<p>  cmooit方式不会存储mysql中创建的库数据:</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/530d00f97cbf">https://www.jianshu.com/p/530d00f97cbf</a></p>
</blockquote>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>docker安装zookeeper</title>
    <url>/2021/06/25/docker%E5%AE%89%E8%A3%85zookeeper/</url>
    <content><![CDATA[<h2 id="Docker安装ZooKeeper"><a href="#Docker安装ZooKeeper" class="headerlink" title="Docker安装ZooKeeper"></a>Docker安装ZooKeeper</h2><p>1.使用Docker安装ZooKeeper，首先下载它的Docker镜像;</p>
<pre><code>docker pull zookeeper
</code></pre>
<p>2.创建好ZooKeeper的配置文件目录(-p 递归创建)，并切换到该目录创建配置文件zoo.cfg;</p>
<pre><code>mkdir /Users/ux/Applications/docker/zookeeper/conf/ -p
</code></pre>
<p>3.cd /Users/ux/Applications/docker/zookeeper/conf/</p>
<pre><code>touch zoo.cfg
</code></pre>
<p>配置文件zoo.cfg内容如下，直接使用VIM编辑即可；</p>
<pre><code>### 设置心跳时间，单位毫秒
tickTime=2000
### 存储内存数据库快照的文件夹
dataDir=/Users/ux/Applications/docker/zookeeper/tmp/zookeeper
### 监听客户端连接的端口
clientPort=2181
</code></pre>
<p>4.运行ZooKeeper容器。</p>
<pre><code>docker run -d --name zookeeper -p 2181:2181 -p 2888:2888 -p 9008:8080 zookeeper

下面的命令安装会出错，应该是-v指定配置文件路径不对导致，mac下docker下zookeeper的conf路径是:/apache-zookeeper-3.7.0-bin/conf(改为/apache-zookeeper-3.7.0-bin/conf依旧无法启动，原因未知):

docker run -d --name zookeeper -p 2181:2181 -p 2888:2888 -p 3888:3888 -p 9008:8080 zookeeper -v /Users/ux/Applications/docker/zookeeper/conf/zoo.cfg:/conf/zoo.cfg

dockerHub上的：

This image includes EXPOSE 2181 2888 3888 8080
(the zookeeper client port, follower port, election port, AdminServer port respectively),
so standard container linking will make it automatically available to the linked containers.
Since the Zookeeper &quot;fails fast&quot; it&#39;s better to always restart it.
</code></pre>
<p>5.启动报audit is disabled日志：</p>
<pre><code>后续搜索发现是因为zookeeper新版本启动的过程中，zookeeper新增的审核日志是默认关闭，
所以控制台输出ZooKeeper audit is disabled
标准的修改方式应该是在zookeeper的配置文件
zoo.cfg新增一行audit.enable=true即可
</code></pre>
<p>6.容器内无法使用vim命令：</p>
<pre><code>apt-get update
apt-get install vim
</code></pre>
]]></content>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>freemarker</title>
    <url>/2018/05/17/freemarker/</url>
    <content><![CDATA[<h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2>]]></content>
      <tags>
        <tag>freemarker</tag>
      </tags>
  </entry>
  <entry>
    <title>http常见status</title>
    <url>/2018/08/30/http%E5%B8%B8%E8%A7%81status/</url>
    <content><![CDATA[<h2 id="HTTP-Status"><a href="#HTTP-Status" class="headerlink" title="HTTP Status"></a>HTTP Status</h2><ul>
<li><p>http常见status</p>
<pre><code>  200,OK:
      用户请求成功，如查询数据成功返回。
      
  400,错误的请求：
      URL匹配上Controller，但方法参数匹配错误，旧货跑出错误
  404,NOT Found:
      用户发出的请求针对的资源不存在。
      
  405,用户来访问本页面的HTTP Method不被允许：
      比如以GET请求方式请求了以@PostMapping限定请求方式的的Controller方法。
      
  406,表示无法使用请求的内容特性来响应请求的资源：
      比如，请求后缀以html结尾，但同时请求的HTTP头中又包含了Accept:application/json。
      
  500,服务器内部错误，无法完成请求：
      通常是Controller抛出的异常。
      
</code></pre>
</li>
</ul>
]]></content>
      <tags>
        <tag>http常见status</tag>
      </tags>
  </entry>
  <entry>
    <title>http请求</title>
    <url>/2018/05/17/http%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<h2 id="post-get请求工具类"><a href="#post-get请求工具类" class="headerlink" title="post/get请求工具类"></a>post/get请求工具类</h2><ul>
<li>HttpRequest工具类<pre><code>  package com.code.util;
  
  import java.io.*;
  import java.net.URL;
  import java.net.URLConnection;
  import java.util.List;
  import java.util.Map;
  
  public class HttpRequest &#123;
      /**
       * 向指定URL发送GET方法的 请求
       *
       * @param url   发送请求的URL
       * @param param 请求参数，请求参数应该是name1=value1&amp;name2=value2的形式。
       * @return URL所代表远程资源的响应
       */
      public static String sendGet(String url, String param) &#123;
          String result = &quot;&quot;;
          BufferedReader in = null;
          try &#123;
              String urlName = url + &quot;?&quot; + param;
              URL realUrl = new URL(urlName);
              // 打开和URL之间的连接
              URLConnection conn = realUrl.openConnection();
              // 设置通用的请求属性
              conn.setRequestProperty(&quot;accept&quot;, &quot;*/*&quot;);
              conn.setRequestProperty(&quot;connection&quot;, &quot;Keep-Alive&quot;);
              conn.setRequestProperty(&quot;user-agent&quot;,
                      &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&quot;);
              // 建立实际的连接
              conn.connect();
              // 获取所有响应头字段
              Map&lt;String, List&lt;String&gt;&gt; map = conn.getHeaderFields();
              // 遍历所有的响应头字段
              for (String key : map.keySet()) &#123;
                  System.out.println(key + &quot;---&gt;&quot; + map.get(key));
              &#125;
              // 定义BufferedReader输入流来读取URL的响应
              in = new BufferedReader(
                      new InputStreamReader(conn.getInputStream(),&quot;UTF-8&quot;));
              String line;
              while ((line = in.readLine()) != null) &#123;
                  result += line;
              &#125;
          &#125; catch (Exception e) &#123;
              System.out.println(&quot;发送GET请求出现异常！&quot; + e);
              e.printStackTrace();
          &#125;
          // 使用finally块来关闭输入流
          finally &#123;
              try &#123;
                  if (in != null) &#123;
                      in.close();
                  &#125;
              &#125; catch (IOException ex) &#123;
                  ex.printStackTrace();
              &#125;
          &#125;
          return result;
      &#125;
  
      /**
       * 向指定URL发送POST方法的请求
       *
       * @param url   发送请求的URL
       * @param param 请求参数，请求参数应该是name1=value1&amp;name2=value2的形式。
       * @return URL所代表远程资源的响应
       */
      public static String sendPost(String url, String param) &#123;
          PrintWriter out = null;
          BufferedReader in = null;
          String result = &quot;&quot;;
          try &#123;
              URL realUrl = new URL(url);
              // 打开和URL之间的连接
              URLConnection conn = realUrl.openConnection();
              // 设置通用的请求属性
              conn.setRequestProperty(&quot;accept&quot;, &quot;*/*&quot;);
              conn.setRequestProperty(&quot;connection&quot;, &quot;Keep-Alive&quot;);
              conn.setRequestProperty(&quot;user-agent&quot;,
                      &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)&quot;);
              // 发送POST请求必须设置如下两行
              conn.setDoOutput(true);
              conn.setDoInput(true);
              // 获取URLConnection对象对应的输出流
              out = new PrintWriter(conn.getOutputStream());
              // 发送请求参数
              out.print(param);
              // flush输出流的缓冲
              out.flush();
              // 定义BufferedReader输入流来读取URL的响应
              in = new BufferedReader(
                      new InputStreamReader(conn.getInputStream(),&quot;UTF-8&quot;));
              String line;
              while ((line = in.readLine()) != null) &#123;
                  result += line;
              &#125;
          &#125; catch (Exception e) &#123;
              System.out.println(&quot;发送POST请求出现异常！&quot; + e);
              e.printStackTrace();
          &#125;
          // 使用finally块来关闭输出流、输入流
          finally &#123;
              try &#123;
                  if (out != null) &#123;
                      out.close();
                  &#125;
                  if (in != null) &#123;
                      in.close();
                  &#125;
              &#125; catch (IOException ex) &#123;
                  ex.printStackTrace();
              &#125;
          &#125;
          return result;
      &#125;
  
  &#125;
</code></pre>
</li>
</ul>
<h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><ul>
<li><p>调用方式（详情参考lib下http文件夹中的附件）</p>
<pre><code>  //String loginParam = &quot;accessKey=test&amp;accessSecret=test&amp;clientId=clientId&amp;clientType=PC&quot;;
    String loginParam = &quot;accessKey=&quot; + accessKey + &quot;&amp;accessSecret=&quot; + accessSecret + &quot;&amp;clientId=&quot; + clientId + &quot;&amp;clientType=&quot; + clientType;
  
   //登陆接口：
    String loginUrl = &quot;https://open.wellsign.cn/dandanqian/api/index.php/Conv/User/login&quot;;
  //loginParam = &quot;accessKey=test&amp;accessSecret=test&amp;clientId=clientId&amp;clientType=PC&quot;;
    String loginSuccess = HttpRequest.sendPost(loginUrl, loginParam);
</code></pre>
</li>
</ul>
]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>java内存分析</title>
    <url>/2019/08/22/java%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<pre><code>    UXdeMacBookPro:cgov-doc-common ux$ jps
    
    
    9395 DocCommonWebConfiguration
    9411 Jps
    9396 Launcher
    683 
    717 RemoteMavenServer
    
    UXdeMacBookPro:cgov-doc-common ux$ jmap -dump:format=b,file=heap.bin 9395
    
    
    
    Dumping heap to /Users/ux/code/compy/rj/ideaSpringCloud/cgov/cgov-doc-common/heap.bin ...
    
    
    
    
    
    Heap dump file created
    UXdeMacBookPro:cgov-doc-common ux$ jhat -J-Xmx512m heap.bin
    Reading from heap.bin...
    Dump file created Thu Aug 22 16:19:29 CST 2019
    Snapshot read, resolving...
    Resolving 2316249 objects...
</code></pre>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java杂记</title>
    <url>/2017/11/03/java%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h2><ul>
<li><p>字符串路径截取</p>
<pre><code>  filename=&quot;2017\11\01\050000001\7b3d73a2e080c2722e1fb6e71be2f0be_aaa2.doc&quot;
  
  //截取最后一个反斜杠后面的内容，即：7b3d73a2e080c2722e1fb6e71be2f0be_aaa2.doc
   String filenameStr =  filename.substring(filename.lastIndexOf(&quot;\\&quot;)+1);
   
   //截取开头到最后一个反斜杠之间的内容，即：2017\11\01\050000001\
   String filePathStr =  filename.substring(0,filename.lastIndexOf(&quot;\\&quot;)+1);
</code></pre>
</li>
<li><p>URL转码解码</p>
<pre><code>   //转码
   String filenameStr2 = java.net.URLEncoder.encode(filenameStr, &quot;utf-8&quot;);
   
   //解码
   java.net.URLDecoder.decode(str, ENCODE);
   
   参考网址:
   http://www.cnblogs.com/haha12/p/4344992.html
</code></pre>
</li>
<li><p>重新拼接</p>
<pre><code>   //重新拼接
   filename = filePathStr+filenameStr2;
</code></pre>
</li>
<li><p>反斜杠转正斜杠</p>
<pre><code>   //将反斜杠替换为正斜杠
   filename.replace(&quot;\\&quot;, &quot;/&quot;))
</code></pre>
</li>
<li><p>字符串年月日时分秒毫秒</p>
<pre><code>   //年月日时分秒毫秒
  java.text.SimpleDateFormat date = new java.text.SimpleDateFormat(&quot;yyyyMMddHHmmssSS&quot;);
  String currentTimeMillis = date.format(new Date(System.currentTimeMillis()));
</code></pre>
</li>
<li><p>截图文件后缀重新拼接</p>
<pre><code>  //fileName=&quot;fjsdfidjfi.swf&quot;
  String suffix = fileName.substring(fileName.lastIndexOf(&quot;.&quot;));
  //拼接得到结果：20171102103140271.swf
  String newFileName = currentTimeMillis + suffix;
</code></pre>
</li>
</ul>
<h2 id="Date转时间戳"><a href="#Date转时间戳" class="headerlink" title="Date转时间戳"></a>Date转时间戳</h2><ul>
<li><p>Date转时间戳</p>
<pre><code>  import java.sql.Timestamp;
  import java.text.SimpleDateFormat;
  import java.util.Calendar;
  import java.util.Date;
  
  public class Test &#123;
      public static void main(String[] args) &#123;
          Timestamp timestamp = new Timestamp((new Date()).getTime());
          //System.out.println(&quot;wre:&quot;+timestamp);
  
          String s = timestamp.toString();
          Timestamp ts = Timestamp.valueOf(s);
          Calendar c = Calendar.getInstance();
          SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy/MM/dd/HH:mm:ss&quot;);//hh:12小时制，HH小时制度
          System.out.println(sdf.format(c.getTime()));
  
      &#125;
  &#125;
</code></pre>
</li>
</ul>
<h2 id="StringUtils截取字符串"><a href="#StringUtils截取字符串" class="headerlink" title="StringUtils截取字符串"></a>StringUtils截取字符串</h2><ul>
<li><p>截取 }, 之后的字符串，不包含 }, </p>
<pre><code>  String str4 = StringUtils.substringAfter(jsonArray.toString(),&quot;&#125;,&quot;);
</code></pre>
</li>
<li><p>依赖包</p>
<pre><code>  import org.apache.commons.lang3.StringUtils;
  
</code></pre>
</li>
<li><p>依赖包maven配置</p>
<pre><code>  &lt;!-- commons-lang3 --&gt;
  &lt;dependency&gt;
      &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
      &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;
      &lt;version&gt;3.1&lt;/version&gt;
  &lt;/dependency&gt;
</code></pre>
</li>
</ul>
<h2 id="mybatis参数映射"><a href="#mybatis参数映射" class="headerlink" title="mybatis参数映射"></a>mybatis参数映射</h2><ul>
<li><p>mybatis参数映射</p>
<p>  and h.regist_status = #{hallRegistration.statusLeave,jdbcType=VARCHAR}</p>
</li>
</ul>
<h2 id="字符串替换正则"><a href="#字符串替换正则" class="headerlink" title="字符串替换正则"></a>字符串替换正则</h2><ul>
<li><p>字符串替换正则</p>
<p>  str.replaceAll(“ {2,}”, “ “)</p>
</li>
</ul>
<h2 id="yml配置读取"><a href="#yml配置读取" class="headerlink" title="yml配置读取"></a>yml配置读取</h2><ul>
<li><p>yml配置读取</p>
<p>  yml配置读取不到：写在根yml下（application.yml）即可</p>
</li>
</ul>
<h2 id="待续…"><a href="#待续…" class="headerlink" title="待续…"></a>待续…</h2>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>java源码计划</title>
    <url>/2017/04/20/java%E6%BA%90%E7%A0%81%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<h2 id="JDK源码阅读计划："><a href="#JDK源码阅读计划：" class="headerlink" title="JDK源码阅读计划："></a>JDK源码阅读计划：</h2><p><strong>JDK（Java SE Development Kit）</strong></p>
<ul>
<li><strong>Java运行时环境(JVM)</strong></li>
<li><strong>Java的基础类库</strong></li>
<li><strong>是Java的开发工具</strong></li>
</ul>
<p><strong>第一部分：Java运行时环境</strong></p>
<ul>
<li>对于JVM，就是往死里学，往死里研究，能有多深就多深。</li>
</ul>
<p><strong>第二部分：Java的基础类库</strong></p>
<ol>
<li><p>第一级别：精读源码</p>
<pre><code> java.io
 java.lang
 java.util
</code></pre>
<p> Exception和Error这一类的，就不用读源码了</p>
</li>
<li><p>第二级别：深刻理解</p>
<pre><code> java.lang.reflect
 java.net
 javax.net.*
 java.nio.*
 java.util.concurrent.*
</code></pre>
</li>
<li><p>第三级别：会用即可</p>
<pre><code> java.lang.annotation
 javax.annotation.*
 java.lang.ref
 java.math
 java.rmi.*
 javax.rmi.*
 java.security.*
 javax.security.*
 java.sql
 javax.sql.*
 javax.transaction.*
 java.text
 javax.xml.*
 org.w3c.dom.*
 org.xml.sax.*
 javax.crypto.*
 javax.imageio.*
 javax.jws.*
 java.util.jar
 java.util.logging
 java.util.prefs
 java.util.regex
 java.util.zip
</code></pre>
</li>
<li><p>第四级别：无视它</p>
<pre><code> swing
 awt
 ...
</code></pre>
</li>
</ol>
<p><strong>第三部分：Java的开发工具</strong></p>
<ul>
<li>javac</li>
<li>jmap</li>
<li>jconsole</li>
<li>jstac</li>
<li>jvisualvm</li>
<li>JDK的bin目录find</li>
<li><strong>……</strong></li>
</ul>
<p>可以把第一级别的那些包称作基础，第二级别的那些包称为进阶。<br>最重要的还是那万年不变的JVM，JVM才是Java根基的根本，再牛的类，没了JVM它也就是一个无用的class文件而已。</p>
<h2 id="Linux实践计划"><a href="#Linux实践计划" class="headerlink" title="Linux实践计划"></a>Linux实践计划</h2><ul>
<li><strong>习惯并持续ubunutu环境下编程</strong></li>
</ul>
<h2 id="未来接触"><a href="#未来接触" class="headerlink" title="未来接触"></a>未来接触</h2><ul>
<li><strong>高并发</strong></li>
<li><strong>分布式</strong></li>
</ul>
]]></content>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>java项目集成Discuz的单点登录</title>
    <url>/2017/12/29/java%E9%A1%B9%E7%9B%AE%E9%9B%86%E6%88%90Discuz%E7%9A%84%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<h2 id="条件准备"><a href="#条件准备" class="headerlink" title="条件准备"></a>条件准备</h2><ul>
<li><p>部署Discuz</p>
<p>  参见文章：windows下discuz论坛<br>  Linux下原理相同</p>
</li>
<li><p>Java项目</p>
<p>  普通Javaweb项目即可</p>
</li>
<li><p>Discuz用户中心访问程序包</p>
<p>  云盘地址<br>  链接:<a href="https://pan.baidu.com/s/1dFtW97z">https://pan.baidu.com/s/1dFtW97z</a>  密码:mkay</p>
<p>  下载解压，将里面的<br>  com.fivestars.interfaces.bbs包<br>  和 config.properties<br>  和 Jsp_demo.jsp<br>  和 web.xml<br>  拷贝出来 备用。</p>
</li>
</ul>
<h2 id="Java项目与Discuz整合单点登录"><a href="#Java项目与Discuz整合单点登录" class="headerlink" title="Java项目与Discuz整合单点登录"></a>Java项目与Discuz整合单点登录</h2><h3 id="将配置和工具类放到Java项目"><a href="#将配置和工具类放到Java项目" class="headerlink" title="将配置和工具类放到Java项目"></a>将配置和工具类放到Java项目</h3><ul>
<li><p>清单</p>
<pre><code>  1.discuz工具包
  2.web.xml添加discuz工具包路径
  3.discuz配置文件
  4.修改Java项目登录代码
  5.discuz jsp
  
</code></pre>
</li>
<li><p>将工具包放到Java项目中：</p>
<pre><code>      com.fivestars.interfaces.bbs包（src根目录）
      和 config.properties（src根目录）
      分别放到对应目录（参考下载的Demo目录结构）
</code></pre>
</li>
<li><p>将web.xml中的复制到Java项目的web.xml中，内容如下：</p>
<pre><code>      &lt;servlet&gt;
          &lt;servlet-name&gt;api&lt;/servlet-name&gt;
          &lt;servlet-class&gt;com.fivestars.interfaces.bbs.api.UC&lt;/servlet-class&gt;
          &lt;load-on-startup&gt;2&lt;/load-on-startup&gt;
        &lt;/servlet&gt;
        &lt;servlet-mapping&gt;
          &lt;servlet-name&gt;api&lt;/servlet-name&gt;
          &lt;url-pattern&gt;/api/uc.php&lt;/url-pattern&gt;
        &lt;/servlet-mapping&gt;
        

  
</code></pre>
</li>
</ul>
<h3 id="Discuz的UCenter中配置参数，使其与Java项目通信"><a href="#Discuz的UCenter中配置参数，使其与Java项目通信" class="headerlink" title="Discuz的UCenter中配置参数，使其与Java项目通信"></a>Discuz的UCenter中配置参数，使其与Java项目通信</h3><ul>
<li><p>访问Discuz的用户管理中心（我的discuz在apache下部署的名称为bbs,部署机器ip为192.148.1.147），如：</p>
<pre><code>  http://192.168.1.147/bbs/uc_server
  
</code></pre>
</li>
<li><p>以创始人或管理员身份登录</p>
<p>  <img src="http://ogy57hyu6.bkt.clouddn.com/dis1.png"></p>
</li>
<li><p>点击应用管理，添加新应用</p>
<pre><code>  1.应用类型
      选择：其他
      
  2.应用名称
      随便写，最好和Java项目名保持一致
      
  3.应用的主URL
      Java项目的访问地址，如：
      http://localhost:8080/discuzTest
      
  4.通信密钥
      随便写，如123456，后面在Java项目中要用到
      
  5.是否开启同步登陆
      勾选：是
      
  6.是够接受通知
      勾选：是
  
  最后提交,提交后在应用管理用看到，此时应用通信还处于失败状态，接下来配置Java项目
      
</code></pre>
<p>  <img src="http://ogy57hyu6.bkt.clouddn.com/dis2.png"><br>  <img src="http://ogy57hyu6.bkt.clouddn.com/dis3.png"></p>
</li>
</ul>
<h3 id="修改Java项目中的config-properties"><a href="#修改Java项目中的config-properties" class="headerlink" title="修改Java项目中的config.properties"></a>修改Java项目中的config.properties</h3><ul>
<li><p>修改前面复制到Java src跟目录下的config.properties内容，内容如下（根据实际情况配置）：</p>
<pre><code>  #UCenter访问地址
  UC_API = http://192.168.1.147/bbs/uc_server
  
  #uc ip address，UCenter ip地址
  UC_IP = 192.168.1.147

  #key，通信密钥
  UC_KEY = 123456

  #appid,应用ID（在应用管理&gt;应用列表中可以看到）
  UC_APPID = 4

  #connect mode: default value is &quot;&quot;，可以不填
  UC_CONNECT = 
      
  启动Java项目，进入UCenter&gt;应用管理，可以看到此时的通信情况会变为：通信成功。
  
</code></pre>
<p>  <img src="http://ogy57hyu6.bkt.clouddn.com/dis4.png"></p>
</li>
</ul>
<h3 id="单点登录开发"><a href="#单点登录开发" class="headerlink" title="单点登录开发"></a>单点登录开发</h3><ul>
<li><p>Java项目中访问Discuz,</p>
<pre><code>  假定点击一个按钮跳转到一个loginDiscuz.jsp页面，提供Discuz论坛地址，点击地址后跳转到论坛首页：
  
</code></pre>
<p>  将上面Jsp_demo.jsp中的代码拷贝到loginDiscuz.jsp中，稍加修改：</p>
<blockquote>
<p><a href="http://ogy57hyu6.bkt.clouddn.com/2-logindiscuz.jsp.txt">http://ogy57hyu6.bkt.clouddn.com/2-logindiscuz.jsp.txt</a></p>
</blockquote>
<p>  <strong>注：其中下面的代码比较重要</strong></p>
<pre><code>  out.println($ucsynlogin
                  + &quot;&lt;a href=&#39;http://localhost/bbs&#39; target=&#39;_blank&#39;&gt;&lt;span style=&#39;font-size:18px&#39;&gt;点此访问论坛！&lt;/span&gt;&lt;/a&gt;&quot;);    

  将返回的$ucsynlogin输出到页面，才能是单点登录成功。
  如何用postman访问整合好的Java项目，如：
  http://192.168.1.147:8080/discuzTest/Jsp_demo.jsp
      
  会看到返回一段js:
      
  &lt;script type=&quot;text/javascript&quot; src=&quot;http://localhost/bbs/api/uc.php?time=1514532782&amp;code=2f15Z57hlywzRB9IwfMmFH%2BVicj4NZLJyxbcdwiTFsOfI1mv2SPKISVXNEkTEmtP9AdwcNfJJPB9z9F36U4T%2FGvSm%2BHvR4%2BefOyk6x4k1zS0KmP%2BZKXM9i6Pj%2BizV06jNyT7kLnYVyPChoOwEMeoqomqIKYbnBaI5pN3&quot; reload=&quot;1&quot;&gt;&lt;/script&gt;
          
  将js中的src中的内容复制粘贴到浏览器地址栏访问，如果不报错，
  再访问Discuz地址，可以看到不用输入登录信息，用户已经处于登录状态。
  
</code></pre>
<h4 id="关于上面返回值中的URL中的localhost"><a href="#关于上面返回值中的URL中的localhost" class="headerlink" title="关于上面返回值中的URL中的localhost"></a><strong>关于上面返回值中的URL中的localhost</strong></h4><p>  上面返回的链接中是src=”<a href="http://localhost/bbs%E3%80%82%E3%80%82%E3%80%82">http://localhost/bbs。。。</a></p>
<p>  如果想要返回discuz所在服务器ip，如src=”<a href="http://local192.168.1.147/host/bbs%E3%80%82%E3%80%82%E3%80%82%E3%80%82">http://local192.168.1.147/host/bbs。。。。</a></p>
<pre><code>  需要在UCenter的应用管理中将Discuz的
  应用的主URL 由http://localhost/bbs替换为所对应的ip，如：
  http://192.168.1.147/bbs
  
</code></pre>
<p>  如图：</p>
<p>  <img src="http://ogy57hyu6.bkt.clouddn.com/discuz_url.png"></p>
</li>
</ul>
<h2 id="bug修改"><a href="#bug修改" class="headerlink" title="bug修改"></a>bug修改</h2><ul>
<li><p>UCenter可能无法登陆bug修正</p>
<pre><code>  在discuz\uc_server\model\admin.php
  找到adminbase函数，将
  $this-&gt;cookie_status = 0;
  
  修改为：
  $this-&gt;cookie_status = isset($_COOKIE[&#39;sid&#39;]) ? 1 : 0;
</code></pre>
</li>
<li><p>单点登录后关闭浏览器用户没有注销bug修正（十分不安全）</p>
<pre><code>  在discuz\source\function\function_core.php
  
</code></pre>
<p>  找到dsetcookie函数，将</p>
<pre><code>  $path = $httponly &amp;&amp; PHP_VERSION &lt; &#39;5.2.0&#39; ? $config[&#39;cookiepath&#39;].&#39;; HttpOnly&#39; : $config[&#39;cookiepath&#39;];
  
</code></pre>
<p>  修改为：</p>
<pre><code>  //将cookie的生命周期改为浏览器会话结束时结束
  $cookie_life = -1;
  $life = $life &gt; 0 ? $cookie_life : ($life &lt; 0 ? getglobal(&#39;timestamp&#39;) - 31536000 : 0);
</code></pre>
</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><p>bug修改</p>
<blockquote>
<p><a href="http://blog.sina.com.cn/s/blog_a77576280102vgga.html">http://blog.sina.com.cn/s/blog_a77576280102vgga.html</a></p>
</blockquote>
</li>
<li><p>单点登录</p>
<blockquote>
<p><a href="http://blog.51cto.com/linhongyu/1614618">http://blog.51cto.com/linhongyu/1614618</a></p>
</blockquote>
</li>
</ul>
<h2 id="discuz全部文件"><a href="#discuz全部文件" class="headerlink" title="discuz全部文件"></a>discuz全部文件</h2><ul>
<li><p>云盘地址</p>
<p>  链接:<a href="https://pan.baidu.com/s/1pLSilC3">https://pan.baidu.com/s/1pLSilC3</a>  密码:tned</p>
</li>
<li><p>包含文件列表</p>
<pre><code>  1-discuzTest.rar
  2-修改后的logindiscuz.jsp
  3-修改后的config.properties
  4-修改后的Discuz部署的文件
  5-官网下载的Discuz原包
  6-Windows下的xamp（PHP集成环境）
  
  
  
</code></pre>
</li>
</ul>
]]></content>
      <tags>
        <tag>discuz单点登录</tag>
      </tags>
  </entry>
  <entry>
    <title>jrebel</title>
    <url>/2018/07/01/jrebel/</url>
    <content><![CDATA[<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ul>
<li><p>用途</p>
<p>  IDEA安装jrebel插件，即可实现热部署，更改静态文件以及java文件，都不需要再耗费大量的时间重启了。</p>
</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li><p>安装JRebel插件</p>
<p>  1.IDEA&gt;pluggings&gt;搜索jrebel插件直接安装，安装完重启IDEA即可<br>  2.下载反向代理，激活jrebel:</p>
<blockquote>
<p><a href="https://github.com/ilanyu/ReverseProxy/releases/latest">https://github.com/ilanyu/ReverseProxy/releases/latest</a></p>
</blockquote>
<p>  3.运行反向代理软件，打开IDEA中JRebel的激活界面，在License Server处填写云翔反向代    理的机器ip，格式为：<a href="http://10.200.55.11:8888/GUID%E3%80%82">http://10.200.55.11:8888/GUID。</a><br>  其中端口为8888，GUID为随机码，网上生成的：</p>
<blockquote>
<p><a href="https://www.guidgenerator.com/online-guid-generator.aspx">https://www.guidgenerator.com/online-guid-generator.aspx</a></p>
</blockquote>
<p>  4.激活完成后改为offline模式 </p>
<p>  地址示例：<a href="http://10.200.55.11:8888/7c06a95e-64fb-462f-9b69-edf4ad5a7ca2">http://10.200.55.11:8888/7c06a95e-64fb-462f-9b69-edf4ad5a7ca2</a></p>
</li>
</ul>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><ul>
<li>其他问题</li>
</ul>
<p> 1.tomcat的On update action 改为update classes and resources</p>
<p> 2.如果出现内存溢出，VM options添加参数：</p>
<pre><code>     -server
    -XX:PermSize=256M
    -XX:MaxPermSize=512m
    -Dfile.encoding=UTF-8
    -Djava.awt.headless=true
    
-Djava.awt.headless=true是系统缺少了显示设备、键盘或鼠标的设置参数，不是内存参数配置。在此配置只是不让代码在运行时在dock栏显示一个小窗口而已。
</code></pre>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><p>参考链接</p>
<blockquote>
<p><a href="https://www.cnblogs.com/wang1024/p/7211194.html">https://www.cnblogs.com/wang1024/p/7211194.html</a>    </p>
</blockquote>
</li>
</ul>
]]></content>
      <tags>
        <tag>jrebel</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下Nginx的负载均衡与HTTPS</title>
    <url>/2017/12/19/linux%E4%B8%8BNginx%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%B8%8EHTTPS/</url>
    <content><![CDATA[<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><pre><code>在http代码块中添加
    
upstream upstream_weblogic &#123;  
    server 192.168.1.191:7001;  
    server 192.168.1.192:7001;  
&#125; 
  
location / &#123;
      root   html;
      index  index.html index.htm;
        proxy_pass http://upstream_weblogic; 
        proxy_set_header Host $host;
        proxy_set_header Connection close;
        proxy_connect_timeout 100ms; # 代理机器连接超时时长(默认的60s太长了)
        expires 30d; 
 &#125;
</code></pre>
<h2 id="http跳转HTTPS"><a href="#http跳转HTTPS" class="headerlink" title="http跳转HTTPS"></a>http跳转HTTPS</h2><pre><code>    ##server配置begin
    server &#123;
    
            listen       80;
            listen       443 ssl;
            server_name  www.aaa.com;
            if ($scheme != https) &#123;
                #rewrite ^(.*)$  https://$host$1 permanent; 
                return 301    https://$host$request_uri;
            &#125;
    ##server配置end
          
    # HTTPS 专用配置 begin
    # http://nginx.org/en/docs/http/configuring_https_servers.html
    ssl_certificate      /usr/local/nginx/nginx.crt; 
    ssl_certificate_key  /usr/local/nginx/nginx.key; 
    ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # SSL(包括 v3)都有漏洞，应该用 TLS(TLS1.0 = SSL 3.1)
    ssl_ciphers   HIGH:!aNULL:!MD5;
    # HTTPS 专用配置 end
    
    &#125;      
</code></pre>
<h2 id="添加头信息让浏览器加载http资源（该方法只适用于静态资源）"><a href="#添加头信息让浏览器加载http资源（该方法只适用于静态资源）" class="headerlink" title="添加头信息让浏览器加载http资源（该方法只适用于静态资源）"></a>添加头信息让浏览器加载http资源（该方法只适用于静态资源）</h2><pre><code>server中添加：
add_header &#39;Content-Security-Policy&#39; &#39;upgrade-insecure-requests&#39;;
这一句可以让浏览器加载http的资源。但是有的浏览器不支持，比如IE

或者在页面的head中加入：
&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;upgrade-insecure-requests&quot;&gt;
</code></pre>
<p>意思是自动将http的不安全请求升级为https</p>
<h2 id="完整配置"><a href="#完整配置" class="headerlink" title="完整配置"></a>完整配置</h2><pre><code>    #user  nobody;
    worker_processes  1;
    
    #error_log  logs/error.log;
    #error_log  logs/error.log  notice;
    #error_log  logs/error.log  info;
    
    #pid        logs/nginx.pid;
    
    events &#123;
        worker_connections  1024;
    &#125;
        
    http &#123;
        include       mime.types;
        default_type  application/octet-stream;
    
        #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;
        #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;
        #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;
    
        #access_log  logs/access.log  main;
    
        sendfile        on;
        #tcp_nopush     on;
    
        #keepalive_timeout  0;
        keepalive_timeout  65;
    
        #gzip  on;
         
        upstream upstream_weblogic &#123;  
            server 192.168.1.190:7001;  
            server 192.168.1.190:7001;  
        &#125; 
    
        ignore_invalid_headers on;
        underscores_in_headers on;
        merge_slashes on;
    
        #include /etc/nginx/conf.d/*.conf; ## 各个 server&#123;&#125; 块
    
        server &#123;
                listen       80;
                listen       443 ssl;
                server_name  www.aaa.com;
                if ($scheme != https) &#123;
                    #rewrite ^(.*)$  https://$host$1 permanent; 
                    return 301    https://$host$request_uri;
                &#125;
    
                #charset koi8-r;
                # 让浏览器自动升级请求为https
                add_header &#39;Content-Security-Policy&#39; &#39;upgrade-insecure-requests&#39;;
    
                #access_log  logs/host.access.log  main;
    
            location / &#123;
                  root   html;
                    index  index.html index.htm;
                    proxy_pass http://upstream_weblogic; 
                    proxy_set_header Host $host;
                    proxy_set_header Connection close;
                    proxy_connect_timeout 100ms; # 代理机器连接超时时长(默认的60s太长了)
                    expires 30d; 
            &#125;
    
            # HTTPS 专用配置
            # http://nginx.org/en/docs/http/configuring_https_servers.html
            ssl_certificate      /usr/local/nginx/nginx.crt; 
            ssl_certificate_key  /usr/local/nginx/nginx.key; 
            # SSL(包括 v3)都有漏洞，应该用 TLS(TLS1.0 = SSL 3.1)
            ssl_protocols TLSv1 TLSv1.1 TLSv1.2; 
            ssl_ciphers   HIGH:!aNULL:!MD5;
    
            #error_page  404              /404.html;
    
            # redirect server error pages to the static page /50x.html
            #
            error_page   500 502 503 504  /50x.html;
            location = /50x.html &#123;
                root   html;
            &#125;
    
            # proxy the PHP scripts to Apache listening on 127.0.0.1:80
            #
            #location ~ \.php$ &#123;
            #    proxy_pass   http://127.0.0.1;
            #&#125;
    
            # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
            #
            #location ~ \.php$ &#123;
            #    root           html;
            #    fastcgi_pass   127.0.0.1:9000;
            #    fastcgi_index  index.php;
            #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
            #    include        fastcgi_params;
            #&#125;
    
            # deny access to .htaccess files, if Apache&#39;s document root
            # concurs with nginx&#39;s one
            #
            #location ~ /\.ht &#123;
            #    deny  all;
            #&#125;
        &#125;
    
        # another virtual host using mix of IP-, name-, and port-based configuration
        #
        #server &#123;
        #    listen       8000;
        #    listen       somename:8080;
        #    server_name  somename  alias  another.alias;
    
        #    location / &#123;
        #        root   html;
        #        index  index.html index.htm;
        #    &#125;
        #&#125;
    
        # HTTPS server
        # 
    #    server &#123;
    #        listen       443 ssl;
    #        server_name  10.201.50.2;
    #
    #        ssl_certificate      /usr/local/nginx/nginx.crt;
    #        ssl_certificate_key  /usr/local/nginx/nginx.key;
    
    #       ssl_session_cache    shared:SSL:1m;
    #        ssl_session_timeout  5m;
    
    #        ssl_ciphers  HIGH:!aNULL:!MD5;
    #        ssl_prefer_server_ciphers  on;
    
    #        location / &#123;
    #            root   html;
    #            index  index.html index.htm;
    #        &#125;
    #    &#125;
    
    &#125;
</code></pre>
<h2 id="使用OpenSSL生成证书"><a href="#使用OpenSSL生成证书" class="headerlink" title="使用OpenSSL生成证书"></a>使用OpenSSL生成证书</h2><pre><code>sudo openssl req -x509 -nodes -days 36500 -newkey rsa:2048 -keyout /usr/local/nginx/nginx.key -out /usr/local/nginx/nginx.crt

这样自制证书，会被提示不安全。
</code></pre>
<h2 id="Nginx文件"><a href="#Nginx文件" class="headerlink" title="Nginx文件"></a>Nginx文件</h2><pre><code>链接:https://pan.baidu.com/s/1qXJHXA8  密码:gd0w
</code></pre>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><blockquote>
<p><a href="http://www.xitongzhijia.net/xtjc/20150910/57367.html?1441869885">http://www.xitongzhijia.net/xtjc/20150910/57367.html?1441869885</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.cnblogs.com/hustskyking/p/upgrade-insecure-requests.html">https://www.cnblogs.com/hustskyking/p/upgrade-insecure-requests.html</a><br><a href="https://googlechrome.github.io/samples/csp-upgrade-insecure-requests/index.html">https://googlechrome.github.io/samples/csp-upgrade-insecure-requests/index.html</a></p>
</blockquote>
<blockquote>
<p><a href="http://nginx.org/en/docs/http/ngx_http_headers_module.html">http://nginx.org/en/docs/http/ngx_http_headers_module.html</a></p>
</blockquote>
<p>阿里：</p>
<blockquote>
<p><a href="https://ninghao.net/blog/4449">https://ninghao.net/blog/4449</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>nginx-https</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下安装apache</title>
    <url>/2017/11/27/linux%E4%B8%8B%E5%AE%89%E8%A3%85apache/</url>
    <content><![CDATA[<h2 id="安装包准备"><a href="#安装包准备" class="headerlink" title="安装包准备"></a>安装包准备</h2><ul>
<li><p>下载APR源码包</p>
<blockquote>
<p><a href="http://apr.apache.org/">http://apr.apache.org</a></p>
</blockquote>
<p>  详细地址：</p>
<blockquote>
<p><a href="http://apr.apache.org/download.cgi">http://apr.apache.org/download.cgi</a></p>
</blockquote>
</li>
<li><p>下载APR-Util源码包</p>
<blockquote>
<p><a href="http://apr.apache.org/">http://apr.apache.org</a></p>
</blockquote>
<p>  详细地址：</p>
<blockquote>
<p><a href="http://apr.apache.org/download.cgi">http://apr.apache.org/download.cgi</a></p>
</blockquote>
</li>
<li><p>下载PCRE源码包</p>
<blockquote>
<p><a href="http://www.pcre.org/">http://www.pcre.org</a></p>
</blockquote>
<p>  详细地址：</p>
<blockquote>
<p><a href="https://ftp.pcre.org/pub/pcre/">https://ftp.pcre.org/pub/pcre/</a></p>
</blockquote>
</li>
<li><p>下载Apache Server2.4源码包</p>
<blockquote>
<p><a href="http://httpd.apache.org/">http://httpd.apache.org/</a></p>
</blockquote>
<p>  详细地址：</p>
<blockquote>
<p><a href="http://httpd.apache.org/download.cgi#apache24">http://httpd.apache.org/download.cgi#apache24</a></p>
</blockquote>
</li>
</ul>
<h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><ul>
<li><p>安装unzip</p>
<pre><code>  yum install -y unzip zip
</code></pre>
</li>
<li><p>全部解压</p>
<p>  解压命令：</p>
<pre><code>  gzip  -d  pcre-8.36.tar.gz
  tar  -xf  pcre-8.36.tar
  
  或者
  tar xzvf this.tar.gz
  
</code></pre>
</li>
<li><p>安装gcc</p>
<pre><code>  无论你是要安装APR、APR-Util、PCRE还是Apache Server或者是其他的一些软件，
  总之，只要是源码安装，那么就需要一个ANSI-C编译器。如果你没有，那就用yum装一个吧，
  既然推荐使用GCC，那就装个GCC吧。
  执行命令：yum  install  -y  gcc    
</code></pre>
</li>
<li><p>首先安装apr</p>
<p>  依次执行命令：</p>
<pre><code>  cd apr-1.6.3
  ./configure
  sudo make
  sudo make install
  
</code></pre>
</li>
<li><p>然后安装apr-util</p>
<p>  依次执行命令：</p>
<pre><code>  cd apr-util-1.6.1
  ./configure  --with-apr=/usr/local/apr
  sudo make
  sudo make install
  
  在安装APR-Util时，需要指定APR的安装路径，所以需要带上选项--with-apr=/usr/local/apr，如果你不带上这个选项，在configure的时候会看到下图的错误提示
</code></pre>
</li>
<li><p>最后安装pcre</p>
<p>  依次执行命令：</p>
<pre><code>  cd pcre-8.41
  在执行./configure时出错，提示configure: error: You need a C++ compiler for C++ support
  此时使用yum安装安装gcc-c++：
  yum  install  -y  gcc  gcc-c++
  
  然后再执行：
  ./configure
  sudo make
  sudo make install
  
</code></pre>
</li>
<li><p>开始安装apache2.4</p>
<p>  解压apache源码包</p>
<pre><code>  gzip  -d  httpd-2.4.29.tar.gz
  tar  -xf  httpd-2.4.29.tar
</code></pre>
<p>  依次执行命令：</p>
<pre><code>  ./configure  --enable-mods-shared=all
  sudo make
  sudo make install
</code></pre>
<p>  Apache默认安装在/usr/local/apache2目录下。同样，这里你也可以使用<br>  –prefix=目录名<br>  来指定一个安装目录，例如：</p>
<pre><code>  ./configure  --prefix=/usr/mydir  --enable-mods-shared=all
</code></pre>
</li>
<li><p>启动apache进行测试</p>
<pre><code>  启动命令：
  /usr/local/apache2/bin/apachectl  -k  start
  
  如果提示以下信息，则是配置文件httpd.conf中的ServerName没有修改：
  
  AH00558: httpd: Could not reliably determine the server&#39;s fully qualified domain name, using localhost.localdomain. Set the &#39;ServerName&#39; directive globally to suppress this message
</code></pre>
</li>
</ul>
<h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><ul>
<li><p>开关防火墙</p>
<pre><code> systemctl  status  firewalld
 如果处于running运行状态，就把它关掉：
 systemctl  stop  firewalld
 然后，查看一下防火墙是否已经关掉：
 systemctl  status  firewalld
 如果处于dead状态，就说明已经关掉了。
 如果你希望每次系统启动的时候都不要启动防火墙，可以执行命令：
 systemctl  disable  firewalld
 同样，如果你希望每次系统启动的时候都启动防火墙，可以执行命令：
 systemctl  enable  firewalld    
</code></pre>
</li>
</ul>
<h2 id="文件夹权限"><a href="#文件夹权限" class="headerlink" title="文件夹权限"></a>文件夹权限</h2><ul>
<li>刚安装完apache发现普通用户没有apache的写入权限，方便起见，将apache下的所有文件设置为了所有用户可读写：<pre><code>  修改apache2下所有文件权限(777:everyone均可读写)：
  sudo chmod -R 777 /usr/local/apache2/
</code></pre>
</li>
</ul>
<h2 id="安装过程中可能出现的错误"><a href="#安装过程中可能出现的错误" class="headerlink" title="安装过程中可能出现的错误"></a>安装过程中可能出现的错误</h2><ul>
<li><p>expat库缺失提示</p>
<pre><code>  安装expat库:
  yum install expat-devel        
</code></pre>
</li>
</ul>
<h2 id="文件包链接"><a href="#文件包链接" class="headerlink" title="文件包链接"></a>文件包链接</h2><ul>
<li>apache2.4源码包以及依赖源码包<pre><code>  链接:http://pan.baidu.com/s/1jIQUArk  密码:5ccg
</code></pre>
</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><p>参考文章（已亲测）</p>
<blockquote>
<p><a href="https://jingyan.baidu.com/article/7e4409533d7f0f2fc0e2ef91.html">https://jingyan.baidu.com/article/7e4409533d7f0f2fc0e2ef91.html</a></p>
</blockquote>
</li>
</ul>
]]></content>
      <tags>
        <tag>linux安装apache</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下安装Nginx</title>
    <url>/2017/12/19/linux%E4%B8%8B%E5%AE%89%E8%A3%85Nginx/</url>
    <content><![CDATA[<h2 id="centos7-64位下安装nginx"><a href="#centos7-64位下安装nginx" class="headerlink" title="centos7 64位下安装nginx"></a>centos7 64位下安装nginx</h2><ul>
<li><p>软件准备</p>
<p>  安装Nginx需要先安装下列软件包：</p>
<pre><code>  GCC
  PCRE
  zlib
  openssl
  
</code></pre>
<p>  GCC和PCRE之前在centos7中使用源码安装apache2.4的时候已经安装过，这里用再安装；<br>  这里需要下载安装zlib后再安装nginx</p>
<p>  zlib官网下载地址：</p>
<blockquote>
<p><a href="http://www.zlib.net/">http://www.zlib.net/</a></p>
</blockquote>
<p>  openssl官网下载地址</p>
<blockquote>
<p><a href="https://www.openssl.org/source/">https://www.openssl.org/source/</a></p>
</blockquote>
<p>  nginx官网下载地址：</p>
<blockquote>
<p><a href="http://nginx.org/en/download.html">http://nginx.org/en/download.html</a></p>
</blockquote>
</li>
<li><p>安装</p>
<ul>
<li><p>将zlib、OpenSSL、nginx源码包上传到centos7</p>
<p>  打开terminal执行：</p>
<pre><code>  scp /Users/ux/Downloads/zlib-1.2.11.tar.gz ux@10.211.55.5:/home/ux/mysoft/
  
  scp /Users/ux/Downloads/nginx-1.12.2.tar.gz ux@10.211.55.5:/home/ux/mysoft/
  
</code></pre>
<p>  该命令将macOS系统中位于下载文件夹下的zlib-1.2.11.tar.gz和nginx-1.12.2.tar.gz 源码包上传到centos7的/home/ux/mysoft文件夹下。</p>
</li>
<li><p>解压，编译，安装</p>
<pre><code>  解压zlib：
  
      gzip -d zlib-1.2.11.tar.gz
      tar -xf zlib-1.2.11.tar
      
  编译安装zlib：
  
      cd zlib-1.2.11
      ./configure
      sudo make
      sudo make install
  
  解压OpenSSL
  
          gzip -d openssl-1.0.2n.tar.gz
          tar -xf openssl-1.0.2n.tar
  
  安装OpenSSL
  
          ./config --prefix=/usr/local/ssl --openssldir=/usr/local/ssl
          sudo make
          sudo make install
  
  如果zlib正常安装，则继续安装nginx:
  
  解压nginx
  
      gzip -d nginx-1.12.2.tar.gz
      tar -xf nginx-1.12.2.tar
      
  编译安装nginx：
  
      cd nginx-1.12.2
      
      ./configure --prefix=/usr/local/nginx  --with-openssl=/home/ux/mysoft/openssl-1.0.2n --with-http_ssl_module
      
      注意：这一步要指定OpenSSL源码包的位置（是OpenSSL源码包位置，不是OpenSSL的安装位置！！），否则后续无法使用ssl模块。
      
      sudo make
      sudo make install
</code></pre>
</li>
</ul>
</li>
<li><p>启动测试</p>
<p>  在安装nginx时执行./configure可以看到。nginx默认安装到</p>
<pre><code>  /usr/local/nginx/下
  
</code></pre>
<p>  启动nginx：</p>
<pre><code>  cd /usr/local/nginx/sbin
  
  ./nginx
  
</code></pre>
<p>  快速停止nginx:</p>
<pre><code>  ./nginx -s stop
  
</code></pre>
<p>  正常停止nginx:</p>
<pre><code>  ./nginx -s quit
  
</code></pre>
<p>  置文件修改重装载命令：</p>
<pre><code>  ./nginx -s reload
  
</code></pre>
<p>  关闭防火墙或者把80端口放行：</p>
<pre><code>  systemctl stop firewalld.service             #停止firewall
  systemctl disable firewalld.service          #禁止firewall开机启动

  firewall-cmd --zone=public --add-port=80/tcp --permanent     #开启80端口，这样外部就能访问nginx的80端口了

  --zone #作用域
  --add-port=80/tcp #添加端口，格式为：端口/通讯协议
  --permanent #永久生效，没有此参数重启后失效
</code></pre>
</li>
</ul>
<h2 id="软件包百度云连接"><a href="#软件包百度云连接" class="headerlink" title="软件包百度云连接"></a>软件包百度云连接</h2><ul>
<li><p>链接</p>
<pre><code>  链接:https://pan.baidu.com/s/1qYyZvhM  密码:1xti 
</code></pre>
</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><p>openssl</p>
<blockquote>
<p><a href="http://blog.csdn.net/u012889638/article/details/49310123">http://blog.csdn.net/u012889638/article/details/49310123</a>    </p>
</blockquote>
<h2 id="NGINX的参数"><a href="#NGINX的参数" class="headerlink" title="NGINX的参数"></a>NGINX的参数</h2></li>
<li><p>  NGINX的参数</p>
<pre><code>  nginx指定文件路径有两种方式root和alias，指令的使用方法和作用域：
  [root]
  语法：root path
  默认值：root html
  配置段：http、server、location、if
  [alias]
  语法：alias path
  配置段：location
  
  root与alias主要区别在于nginx如何解释location后面的uri，这会使两者分别以不同的方式将请求映射到服务器文件上。
  
  ************************************************
  root的处理结果是：root路径＋location路径
  alias的处理结果是：使用alias路径替换location路径
  ************************************************
  
  alias是一个目录别名的定义，root则是最上层目录的定义。
  
  ###这句话有待考证：
  还有一个重要的区别是alias后面必须要用“/”结束，否则会找不到文件的。。。
  而root则可有可无~~
</code></pre>
</li>
</ul>
<pre><code>root实例
    
    location ^~ /t/ &#123;
          root /www/root/html/;
          location ^~ /t/ &#123;
          root /www/root/html/;
    &#125;
    
如果一个请求的URI是/t/a.html时，web服务器将会返回服务器上的/www/root/html/t/a.html的文件。

alias实例：


    location ^~ /t/ &#123;
        alias /www/root/html/new_t/;
        location ^~ /t/ &#123;
        alias /www/root/html/new_t/;
    &#125;
    
    
如果一个请求的URI是/t/a.html时，web服务器将会返回服务器上的/www/root/html/new_t/a.html的文件。

注意这里是new_t，因为alias会把location后面配置的路径丢弃掉，把当前匹配到的目录指向到指定的目录。

注意：
1. 使用alias时，目录名后面一定要加&quot;/&quot;。
3. alias在使用正则匹配时，必须捕捉要匹配的内容并在指定的内容处使用。
4. alias只能位于location块中。（root可以不放在location中）

&gt; http://www.nginx.cn/4658.html
</code></pre>
]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下配置apache-weblogic负载均衡+https</title>
    <url>/2017/11/27/linux%E4%B8%8B%E9%85%8D%E7%BD%AEapache-weblogic%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-https/</url>
    <content><![CDATA[<h2 id="加载所需要的模块（httpd-conf文件中）"><a href="#加载所需要的模块（httpd-conf文件中）" class="headerlink" title="加载所需要的模块（httpd.conf文件中）"></a>加载所需要的模块（httpd.conf文件中）</h2><ul>
<li><p>所需模块清单</p>
<pre><code>  LoadModule lbmethod_bybusyness_module modules/mod_lbmethod_bybusyness.so 
  LoadModule proxy_module modules/mod_proxy.so
  LoadModule proxy_ajp_module modules/mod_proxy_ajp.so
  LoadModule proxy_balancer_module modules/mod_proxy_balancer.so 
  LoadModule proxy_http_module modules/mod_proxy_http.so
  LoadModule rewrite_module modules/mod_rewrite.so
  LoadModule slotmem_shm_module modules/mod_slotmem_shm.so 
  LoadModule socache_shmcb_module modules/mod_socache_shmcb.so
  #ssl模块
  LoadModule ssl_module modules/mod_ssl.so
  #weblogic模块
  LoadModule weblogic_module modules/mod_wl_24.so
</code></pre>
</li>
</ul>
<h2 id="apache-weblogic负载均衡（httpd-conf文件中）"><a href="#apache-weblogic负载均衡（httpd-conf文件中）" class="headerlink" title="apache-weblogic负载均衡（httpd.conf文件中）"></a>apache-weblogic负载均衡（httpd.conf文件中）</h2><ul>
<li><p>在LoadModule weblogic_module modules/mod_wl_24.so下方添加以下配置即可：</p>
<pre><code>   &lt;IfModule mod_weblogic.c&gt;
        ###多台weblogic改成相应的ip即可，这里用两个相同的服务器地址暂代。
        WeblogicCluster 10.211.55.3:7001,10.211.55.3:7001
  
        MatchExpression *
  
        #WLLogFile &quot;/home/ux/Desktop/apache2.log&quot;
  
        #Debug On
  
        #DebugConfigInfo On
  
        KeepAliveEnabled On
  
        KeepAliveSecs 15
  
     &lt;/IfModule&gt;
     
     注：注释掉的视情况开启。
</code></pre>
</li>
</ul>
<h2 id="引入SSL配置文件（httpd-conf文件中）"><a href="#引入SSL配置文件（httpd-conf文件中）" class="headerlink" title="引入SSL配置文件（httpd.conf文件中）"></a>引入SSL配置文件（httpd.conf文件中）</h2><ul>
<li><p>引入httpd-ssl.conf</p>
<pre><code>  找到：
  # Secure (SSL/TLS) connections 
  #Include conf/extra/httpd-ssl.conf
  改为：
  # Secure (SSL/TLS) connections 
  Include conf/extra/httpd-ssl.conf
</code></pre>
</li>
</ul>
<h2 id="自动跳转https-httpd-conf文件中"><a href="#自动跳转https-httpd-conf文件中" class="headerlink" title="自动跳转https(httpd.conf文件中)"></a>自动跳转https(httpd.conf文件中)</h2><ul>
<li><p>http自动跳转https</p>
<pre><code>      找到ServerName，将Rewrite规则写在其下面即可：

      ######
      ServerName www.aa.com:80
      RewriteEngine on
      RewriteCond %&#123;SERVER_PORT&#125; !^443$
      RewriteRule ^(.*)?$ https://%&#123;SERVER_NAME&#125;$1 [L,R=301]    
</code></pre>
</li>
</ul>
<h2 id="修改httpd-ssl-conf文件"><a href="#修改httpd-ssl-conf文件" class="headerlink" title="修改httpd-ssl.conf文件"></a>修改httpd-ssl.conf文件</h2><ul>
<li><p>修改ServerName</p>
<pre><code>  找到：
  &lt;VirtualHost _default_:443&gt;
  
  将ServerName改为自己的域名，例如：    
  ServerName www.aa.com:443
  
  
</code></pre>
</li>
<li><p>  配置证书</p>
<pre><code>  打开httpd-ssl.conf看到，
  SSLCertificateFile &quot;/usr/local/apache2/conf/server.crt&quot;
  SSLCertificateKeyFile &quot;/usr/local/apache2/conf/server.key&quot;
  #SSLCACertificateFile &quot;/usr/local/apache2/conf/ssl.crt/ca-bundle.crt&quot;
  
  前两个已经默认被加载，后一个需要我们手动加载，去掉注释即可。
  
  
</code></pre>
</li>
<li><p>所需模块文件获取方式（注：实验机器为centos7 64位）</p>
<pre><code>  mod_ssl.so：
  
  sudo yum install -y mod_ssl
  
  安装完成后我们可以看到mod_ssl的配置文件/etc/httpd/modules/下找到mod_ssl.so文件
  
  mod_wl_24.so：
  百度下载的....
  
  文件包：
  链接:http://pan.baidu.com/s/1gfxo77P  密码:cy47
  
</code></pre>
</li>
<li><p>参考链接</p>
<blockquote>
<p><a href="http://blog.csdn.net/qq229596421/article/details/51789872">http://blog.csdn.net/qq229596421/article/details/51789872</a></p>
</blockquote>
</li>
</ul>
<h2 id="负载均衡其他配置方式"><a href="#负载均衡其他配置方式" class="headerlink" title="负载均衡其他配置方式"></a>负载均衡其他配置方式</h2><ul>
<li><p>URL分发</p>
<pre><code>  &lt;IfModule mod_weblogic.c&gt;
WebLogicCluster johndoe02：8005，johndoe：8006
调试打开
WLLogFile c：/tmp/global_proxy.log 
WLTempDir“c：/ myTemp”
DebugConfigInfo On
KeepAliveEnabled打开
KeepAliveSecs 15
</code></pre>
<p>  &lt;/ IfModule&gt;配置</p>
<p>  &lt;Location / jurl&gt;</p>
<pre><code>SetHandler weblogic-handler
WebLogicCluster agarwalp01：7001
</code></pre>
<p>  &lt;/位置&gt;</p>
<p>  &lt;Location / web&gt;</p>
<pre><code>SetHandler weblogic-handler
PathTrim /web
调试关闭
WLLogFile c：/tmp/web_log.log
</code></pre>
<p>  &lt;/位置&gt;</p>
<p>  &lt;Location / foo&gt;</p>
<pre><code>SetHandler weblogic-handler
PathTrim /foo
调试错误
WLLogFile c：/tmp/foo_proxy.log
</code></pre>
<p>  &lt;/位置&gt;</p>
<p>  所有匹配/ jurl / *的请求都将调试级别设置为ALL，并且日志消息将被记录到c:/tmp/global_proxy.log文件中。<br>  所有匹配/ web / *的请求都将设置为“关闭”调试级别，并且不会记录日志消息。<br>  所有匹配/ foo / *的请求都将调试级别设置为ERR，并且日志消息将被记录到c:/tmp/foo_proxy.log文件中。</p>
<p>  Oracle建议您使用该MatchExpression语句而不是<Files>块。</Files></p>
</li>
</ul>
<h2 id="https下让浏览器自动将HTTP资源升级为HTTPS"><a href="#https下让浏览器自动将HTTP资源升级为HTTPS" class="headerlink" title="https下让浏览器自动将HTTP资源升级为HTTPS"></a>https下让浏览器自动将HTTP资源升级为HTTPS</h2><ul>
<li><p>在apache的httpd.conf中添加如下配置</p>
<pre><code>  找到加载模块代码，并去掉注释：
  LoadModule headers_module modules/mod_headers.so
  
  搜索
  &lt;IfModule headers_module&gt;
  
  将
  &lt;IfModule headers_module&gt;
      #
      # Avoid passing HTTP_PROXY environment to CGI&#39;s on this or any proxied
      # backend servers which have lingering &quot;httpoxy&quot; defects.
      # &#39;Proxy&#39; request header is undefined by the IETF, not listed by IANA
      #
      RequestHeader unset Proxy early
  
  &lt;/IfModule&gt;
  
  改为
  
  &lt;IfModule headers_module&gt;
      #
      # Avoid passing HTTP_PROXY environment to CGI&#39;s on this or any proxied
      # backend servers which have lingering &quot;httpoxy&quot; defects.
      # &#39;Proxy&#39; request header is undefined by the IETF, not listed by IANA
      #
      RequestHeader unset Proxy early
  
      Header set Content-Security-Policy &quot;upgrade-insecure-requests&quot;
  &lt;/IfModule&gt;
  
</code></pre>
</li>
<li><p>参考链接</p>
<blockquote>
<p><a href="https://www.cnblogs.com/hustskyking/p/upgrade-insecure-requests.html">https://www.cnblogs.com/hustskyking/p/upgrade-insecure-requests.html</a><br><a href="http://httpd.apache.org/docs/current/mod/mod_headers.html">http://httpd.apache.org/docs/current/mod/mod_headers.html</a></p>
</blockquote>
</li>
<li><p>apache完整包</p>
<pre><code>  链接:https://pan.baidu.com/s/1mizN7Uo  密码:c4p2
  
</code></pre>
</li>
</ul>
]]></content>
      <tags>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>docker容器停止运行时修改容器内的配置文件信息</title>
    <url>/2021/06/20/mac%E4%B8%8Bdocker%E5%AE%B9%E5%99%A8%E5%81%9C%E6%AD%A2%E8%BF%90%E8%A1%8C%E6%97%B6%E4%BF%AE%E6%94%B9%E5%AE%B9%E5%99%A8%E5%86%85%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF(mysql%E4%B8%BA%E4%BE%8B)/</url>
    <content><![CDATA[<h1 id="mac下docker容器停止运行时修改容器内的配置文件信息-mysql为例"><a href="#mac下docker容器停止运行时修改容器内的配置文件信息-mysql为例" class="headerlink" title="mac下docker容器停止运行时修改容器内的配置文件信息(mysql为例)"></a>mac下docker容器停止运行时修改容器内的配置文件信息(mysql为例)</h1><h2 id="docker容器工具nsenter"><a href="#docker容器工具nsenter" class="headerlink" title="docker容器工具nsenter"></a>docker容器工具nsenter</h2><pre><code>1.docker run -it --privileged --pid=host justincormack/nsenter1
2.cd /var/lib/docker&amp;&amp; ls
</code></pre>
<h3 id="进入nsenter容器内，执行"><a href="#进入nsenter容器内，执行" class="headerlink" title="进入nsenter容器内，执行"></a>进入nsenter容器内，执行</h3><pre><code>3.cd /var/lib/docker/ &amp;&amp; ls

builder     containerd  image       overlay2    runtimes    tmp         volumes
buildkit    containers  network     plugins     swarm       trust
</code></pre>
<h3 id="进入overlay2下"><a href="#进入overlay2下" class="headerlink" title="进入overlay2下"></a>进入overlay2下</h3><pre><code>cd overlay2/ &amp;&amp; ls

032aa097f9e44b7fe1983ece7239c5ceb47deaf8dbd8c290a146718265323493
0713cff7f10dfb5d266587b6fa37c96e0d4e32d91828e8789ede09eec2405ee6
6ac139acad4e6d7206e09a590232381d3e4131f95c10790de09777a1b4dbbd16
</code></pre>
<h3 id="进入对应的容器"><a href="#进入对应的容器" class="headerlink" title="进入对应的容器"></a>进入对应的容器</h3><pre><code> cd 6ac139acad4e6d7206e09a590232381d3e4131f95c10790de09777a1b4dbbd16 &amp;&amp; ls
 
注：6ac139acad4e6d7206e09a590232381d3e4131f95c10790de09777a1b4dbbd16容器(这个容器ID是mysql8的容器ID)
</code></pre>
<h3 id="进入diff目录，然后再进入etc目录，mysql的my-cnf配置文件就在这里。"><a href="#进入diff目录，然后再进入etc目录，mysql的my-cnf配置文件就在这里。" class="headerlink" title="进入diff目录，然后再进入etc目录，mysql的my.cnf配置文件就在这里。"></a>进入diff目录，然后再进入etc目录，mysql的my.cnf配置文件就在这里。</h3><pre><code>cd diff/etc
</code></pre>
<h3 id="配置文件完整目录"><a href="#配置文件完整目录" class="headerlink" title="配置文件完整目录"></a>配置文件完整目录</h3><pre><code>/var/lib/docker/overlay2/6ac139acad4e6d7206e09a590232381d3e4131f95c10790de09777a1b4dbbd16/diff/etc
</code></pre>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><blockquote>
<p><a href="https://www.jianshu.com/p/6aefed2be1c7">https://www.jianshu.com/p/6aefed2be1c7</a><br><a href="https://blog.csdn.net/ilovemilk/article/details/80239489">https://blog.csdn.net/ilovemilk/article/details/80239489</a></p>
</blockquote>
<h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><pre><code>容器内无法使用vim命令：
apt-get update
apt-get install vim
</code></pre>
<h2 id="my-cnf开启慢日志（废弃，暂时有问题）"><a href="#my-cnf开启慢日志（废弃，暂时有问题）" class="headerlink" title="my.cnf开启慢日志（废弃，暂时有问题）"></a>my.cnf开启慢日志（废弃，暂时有问题）</h2><pre><code>将配置文件外挂到宿主机(macos下)：

/Users/ux/Applications/docker/mysql8/conf/my.cnf

slow_query_log=1

slow_query_log_file=/Users/ux/Applications/docker/mysql8/logs/mysql_slow.log

show VARIABLES LIKE &#39;%slow_query_log%&#39;
show VARIABLES like &#39;%slow_query_log%&#39;

set global slow_query_log=1

cd /var/lib/docker/overlay2/6ac139acad4e6d7206e09a590232381d3e4131f95c10790de09777a1b4dbbd16
/Users/ux/Library/Containers/com.docker.docker

screen ~/Library/Containers/com.docker.docker/Data/vms/0/tty

screen ~/Library/Containers/com.docker.docker/Data/com.docker.driver.amd64-linux/tty

screen ~/Library/Containers/com.docker.docker/Data/tasks/com.docker.driver.amd64-linux/tty

screen ~/Library/Containers/com.docker.docker/Data/tasks/com.docker.driver.amd64-linux/tty

[screen is terminating]

docker run -it --rm --privileged --pid=host justincormack/nsenter1

cd /var/lib/docker/containers &amp;&amp; ls
</code></pre>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>mac下brew安装与管理</title>
    <url>/2021/07/23/mac%E4%B8%8Bbrew%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="安装brew"><a href="#安装brew" class="headerlink" title="安装brew"></a>安装brew</h2><p>/bin/bash -c “$(curl -fsSL <a href="https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;">https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;</a></p>
<h2 id="安装brew可视化界面工具"><a href="#安装brew可视化界面工具" class="headerlink" title="安装brew可视化界面工具"></a>安装brew可视化界面工具</h2><ul>
<li>cakebrew可视化工具下载地址</li>
</ul>
<blockquote>
<p><a href="http://www.cakebrew.com/">www.cakebrew.com</a></p>
</blockquote>
<h2 id="brew管理包"><a href="#brew管理包" class="headerlink" title="brew管理包"></a>brew管理包</h2><ul>
<li><p>可以直接在cakebrew下安装工具</p>
</li>
<li><p>也可以通过类似下面的命令安装telnet、svn等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew安装svn:</span><br><span class="line">brew install svn</span><br><span class="line"></span><br><span class="line">安装telnet：</span><br><span class="line">brew install telnet</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>mac下brew安装与管理</tag>
      </tags>
  </entry>
  <entry>
    <title>html转Docset</title>
    <url>/2017/12/13/mac%E4%B8%8Bhtml%E8%BD%ACDocset/</url>
    <content><![CDATA[<h2 id="软件使用"><a href="#软件使用" class="headerlink" title="软件使用"></a>软件使用</h2><ul>
<li><p>安装Python</p>
<p>  macOS自带python,这里就不需要再安装了。</p>
</li>
<li><p>安装beautifulsoup4.3.2</p>
<p>  下载地址</p>
<blockquote>
<p><a href="https://pypi.python.org/pypi/beautifulsoup4/4.3.2">https://pypi.python.org/pypi/beautifulsoup4/4.3.2</a></p>
</blockquote>
<p>  解压下载好的beautifulsoup4-4.3.2.tar.gz<br>  然后终端进入beautifulsoup4-4.3.2文件夹<br>  执行安装命令：</p>
<pre><code>  sudo python setup.py install
</code></pre>
</li>
<li><p>下载html2Dash</p>
<p>  下载地址</p>
<blockquote>
<p><a href="https://github.com/xuelangZF/html2Dash#fork-destination-box">https://github.com/xuelangZF/html2Dash#fork-destination-box</a></p>
</blockquote>
</li>
<li><p>html转Docset</p>
<ul>
<li><p>材料清单</p>
<p>  准备好的需要转为docset的网页（需要有一个名为index.html的网页）<br>  html2Dash工具</p>
</li>
<li><p>转换命令</p>
<p>  ./html2dash.py  /Users/ux/0_API/linux</p>
<p>  注： /Users/ux/0_API/linux 是需要转换为docset的网页的文件夹路径</p>
</li>
<li><p>作者原文档</p>
<pre><code>  The full usage is:

      $ doc2dash [OPTIONS] SOURCE  
  
  The `SOURCE` is a directory containing the HTML documents you would like to convert.
  
  Valid `OPTIONS` are the following:
  
  * -n, --name  
  
      Name the docset explicitly instead of letting doc2dash guess the correct name from the directory name of the source.
  
  * -d PATH, --destination PATH  
  
      Put the resulting docset into PATH. Default is the directory `~/Library/Application Support/html2dash/DocSets` 
  
  * -i FILENAME, --icon FILENAME
  
      Add PNG icon FILENAME to docset that is used within Dash.app to represent the docset.
      
  * -p INDEX_PAGE, --index-page INDEX_PAGE
      
      Set the file that is shown when the docset is clicked within Dash.app.
      
  * -h, --help
  
      Show a brief usage summary and exit.
  
  DEPENDENCIES:  
      
  * BeautifulSoup HTML parsing library
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li>链接<blockquote>
<p><a href="https://segmentfault.com/a/1190000000721142">https://segmentfault.com/a/1190000000721142</a><br><a href="http://selfboot.cn/2014/10/13/html2dash/">http://selfboot.cn/2014/10/13/html2dash/</a><br><a href="https://github.com/xuelangZF/html2Dash#fork-destination-box">https://github.com/xuelangZF/html2Dash#fork-destination-box</a></p>
</blockquote>
</li>
</ul>
]]></content>
      <tags>
        <tag>Docset</tag>
      </tags>
  </entry>
  <entry>
    <title>teamviewer</title>
    <url>/2019/03/14/mac%E4%B8%8Bteamviewer5%E5%88%86%E9%92%9F%E9%99%90%E5%88%B6%E8%A7%A3%E9%99%A4/</url>
    <content><![CDATA[<h2 id="mac版teamviewer商业限制解除"><a href="#mac版teamviewer商业限制解除" class="headerlink" title="mac版teamviewer商业限制解除"></a>mac版teamviewer商业限制解除</h2><ul>
<li><p>mac版teamviewer商业限制解除</p>
<p>  下载Python脚本，在python2.x(2.7)环境下执行:</p>
<pre><code>  sudo python2.7 TeamViewer-id-changer.py
</code></pre>
<blockquote>
<p><a href="https://github.com/uxawseny/teamviewers.git">https://github.com/uxawseny/teamviewers.git</a></p>
</blockquote>
</li>
</ul>
]]></content>
      <tags>
        <tag>teamviewer</tag>
      </tags>
  </entry>
  <entry>
    <title>mac下启动tomcat</title>
    <url>/2017/11/21/mac%E4%B8%8B%E5%90%AF%E5%8A%A8tomcat/</url>
    <content><![CDATA[<h2 id="下载适用于mac的tomcat"><a href="#下载适用于mac的tomcat" class="headerlink" title="下载适用于mac的tomcat"></a>下载适用于mac的tomcat</h2><ul>
<li><p>mac下的tomcat</p>
<pre><code>  百度搜tomcat，到tomcat官网下载zip或者tar.gz
  
</code></pre>
</li>
<li><p>tomcat官网：</p>
<blockquote>
<p><a href="https://tomcat.apache.org/">https://tomcat.apache.org/</a></p>
</blockquote>
</li>
<li><p>安装tomcat</p>
<pre><code>  由于下载的是解压版，所有直接解压，放到想要放的目录下即可。

  仅仅这样还是不能够启动tomcat的，打开terminal，进入到tomcat/bin

  修改.sh文件的执行权限为所有用户读写
  sudo chmod 777 *.sh
  
  此时即可启动：
  sudo sh startup.sh
  
</code></pre>
</li>
<li><p>在IDEA中配置tomcat</p>
<pre><code>  这一步骤和Windows下的操作一模一样。
  
  
</code></pre>
</li>
</ul>
]]></content>
      <tags>
        <tag>mac下tomcat启动</tag>
      </tags>
  </entry>
  <entry>
    <title>mac下自用docker清单</title>
    <url>/2021/07/23/mac%E4%B8%8B%E8%87%AA%E7%94%A8docker%E6%B8%85%E5%8D%95/</url>
    <content><![CDATA[<h2 id="mac下自用docker容器清单"><a href="#mac下自用docker容器清单" class="headerlink" title="mac下自用docker容器清单"></a>mac下自用docker容器清单</h2><ul>
<li><p>mysql安装时需要按自己需求设置密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">本地docker清单：</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line">1.mysql5.7.33</span><br><span class="line"></span><br><span class="line">docker run --name mysql5.7 -p 3306:3306 -v /Users/ux/Applications/docker/mysql5.7/data:/var/lib/mysql -v /Users/ux/Applications/docker/mysql5.7/conf:/etc/mysql/conf.d -v /Users/ux/Applications/docker/mysql5.7/logs:/var/log/mysql -e MYSQL_ROOT_PASSWORD=1230 -d mysql:5.7.33 --lower_case_table_names=1</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line">2.mysql8.0.25</span><br><span class="line"></span><br><span class="line">docker run --name mysql8.0 -p 3307:3306 -v /Users/ux/Applications/docker/mysql8/data:/var/lib/mysql -v /Users/ux/Applications/docker/mysql8/conf:/etc/mysql/conf.d -v /Users/ux/Applications/docker/mysql8/logs:/var/log/mysql -e MYSQL_ROOT_PASSWORD=1230 -d mysql:8.0.25 --lower_case_table_names=1</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line">3.redis</span><br><span class="line"></span><br><span class="line">不设置密码:</span><br><span class="line">docker run --name redis -d -p 6379:6379 redis:5.0.12</span><br><span class="line">设置密码:</span><br><span class="line">docker run --name redis5 -d -p 6380:6379 redis:5.0.12 --requirepass 123456</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line">4.jenkins</span><br><span class="line"></span><br><span class="line">docker run -itd --name jenkins -p 9001:8080 -p 9002:50000 -v /Users/ux/Applications/docker/jenkins/jenkins_home:/var/jenkins_home jenkins/jenkins</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line">5.nexus</span><br><span class="line"></span><br><span class="line">docker run -d -p 9009:8081 --name nexus -v /Users/ux/Applications/docker/nexus/nexus-data:/nexus-data sonatype/nexus3</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line">6.portainer2.x</span><br><span class="line"></span><br><span class="line">docker run -d -p 9000:9000 --name portainer -v /var/run/docker.sock:/var/run/docker.sock -v /Users/ux/Applications/docker/portainer2/data:/data portainer/portainer-ce</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>mac下自用docker清单</tag>
      </tags>
  </entry>
  <entry>
    <title>mac下安装与卸载mysql</title>
    <url>/2017/11/25/mac%E4%B8%8B%E5%AE%89%E8%A3%85mysql/</url>
    <content><![CDATA[<h2 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h2><ul>
<li>下载地址<pre><code>  安装mysql社区版，免费。下载地址：
  
</code></pre>
<blockquote>
<p><a href="https://dev.mysql.com/downloads/">https://dev.mysql.com/downloads/</a></p>
</blockquote>
  下载MySQL Community Server (GPL)版本。<br>  macOS下下载的安装包是dmg格式的。</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li><p>macOS下安装mysql</p>
<p>  macOS下的mysql dmg安装包基本就是傻瓜式安装，一路确定即可，但是要注意最后一步的mysql installer弹窗，会提示mysql的root用户的默认密码，抄下即可，方便后续登录root用户以及修改密码。</p>
<p>  macOS下启动与关闭mysql服务，可以在 系统偏好设置&gt; 最下边看到mysql图标，点击去即可启动/关闭 mysql服务。</p>
<h2 id="更改字符集"><a href="#更改字符集" class="headerlink" title="更改字符集"></a>更改字符集</h2></li>
<li><p>更改默认字符集和密码</p>
<p>  mysql默认安装后，会出现中文乱码现象，需要更改字符集设置。</p>
<p>  root用户登录mysql，查看字符集信息：</p>
<pre><code>  show variables like &#39;character%&#39;;
  
  结果类似下面（这是改过字符集设置后的结果）
  
  mysql&gt; show variables like &#39;character%&#39;;
  
  +--------------------------+-----------------------------------------------------------+
  | Variable_name            | Value                                                     |
  +--------------------------+-----------------------------------------------------------+
  | character_set_client     | utf8                                                      |
  | character_set_connection | utf8                                                      |
  | character_set_database   | utf8                                                      |
  | character_set_filesystem | binary                                                    |
  | character_set_results    | utf8                                                      |
  | character_set_server     | utf8                                                      |
  | character_set_system     | utf8                                                      |
  | character_sets_dir       | /usr/local/mysql-5.7.20-macos10.12-x86_64/share/charsets/ |
  +--------------------------+-----------------------------------------------------------+
  8 rows in set (0.00 sec)
</code></pre>
<p>  打开终端，进入/etc，执行ls -a 查看有没有my.cnf文件，没有则创建my.cnf:</p>
<pre><code>  sudo vim /etc/my.cnf ，输入计算机管理员密码，创建my.cnf文件，并复制
  
  [client]
  default-character-set=utf8
  [mysqld]
  character-set-server=utf8
  
  按下esc按键，输入:wq保存退出即可。
  重启mysql服务，OK。
</code></pre>
</li>
</ul>
<h2 id="修改mysql密码"><a href="#修改mysql密码" class="headerlink" title="修改mysql密码"></a>修改mysql密码</h2><ul>
<li><p>修改root用户密码</p>
<pre><code>  mysql –u root 进入mysql
  update user set password=PASSWORD(‘123456’) where User=&#39;root&#39;;
</code></pre>
</li>
</ul>
<h2 id="允许远程访问"><a href="#允许远程访问" class="headerlink" title="允许远程访问"></a>允许远程访问</h2><ul>
<li><p>允许远程访问mysql</p>
<pre><code> mysql -u root –p
 mysql&gt;use mysql;
 mysql&gt;update user set host = &#39;%&#39; where user = &#39;root&#39;;
 
 查看结果：
 mysql&gt;select host, user from user;
</code></pre>
<h2 id="mac安装完mysql后用随即密码无法登陆，重置密码-20180828"><a href="#mac安装完mysql后用随即密码无法登陆，重置密码-20180828" class="headerlink" title="mac安装完mysql后用随即密码无法登陆，重置密码(20180828)"></a>mac安装完mysql后用随即密码无法登陆，重置密码(20180828)</h2></li>
<li><p>关闭mysql服务</p>
<pre><code>  苹果-&gt;系统偏好设置-&gt;最下边点mysql 在弹出页面中 关闭mysql服务（点击stop mysql server）
</code></pre>
</li>
<li><p>关闭密码验证</p>
<pre><code>  进入终端输入：cd /usr/local/mysql/bin/
  
  回车后 登录管理员权限 sudo su
  回车后输入以下命令来禁止mysql验证功能 ./mysqld_safe --skip-grant-tables &amp;
  回车后mysql会自动重启（偏好设置中mysql的状态会变成running）
</code></pre>
</li>
<li><p>设置密码</p>
<pre><code>  输入命令 ./mysql    
  回车后，输入命令 FLUSH PRIVILEGES; 
  回车后，输入命令 SET PASSWORD FOR &#39;root&#39;@&#39;localhost&#39; = PASSWORD(&#39;你的新密码&#39;);
  密码修改完成，可以成功登陆。
</code></pre>
</li>
</ul>
<h2 id="mac下卸载mysql-彻底卸载"><a href="#mac下卸载mysql-彻底卸载" class="headerlink" title="mac下卸载mysql(彻底卸载)"></a>mac下卸载mysql(彻底卸载)</h2><ul>
<li><p>mac下的mysql卸载没有卸载工具类，只能通过彻底删除的方式卸载：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有些文件可能不存在，会提示删除失败。</span><br><span class="line">删除命令可能会删除失败，在macos catalina下删除时，有一部分没生效，只能手动去对应目录下通过关键字检索删除了。</span><br><span class="line"></span><br><span class="line">sudo rm /usr/local/mysql</span><br><span class="line">sudo rm -rf /usr/local/mysql*</span><br><span class="line">sudo rm -rf /Library/StartupItems/MySQLCOM</span><br><span class="line">sudo rm -rf /Library/PreferencePanes/My*</span><br><span class="line">vim /etc/hostconfig and removed the line MYSQLCOM=-YES-rm -rf ~/Library/PreferencePanes/My*</span><br><span class="line">sudo rm -rf /Library/Receipts/mysql*   安装历史</span><br><span class="line">sudo rm -rf /Library/Receipts/MySQL*</span><br><span class="line">sudo rm -rf /var/db/receipts/com.mysql.* </span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>macOS下安装与卸载mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mac下远程Linux</title>
    <url>/2017/12/06/mac%E4%B8%8B%E8%BF%9C%E7%A8%8BLinux/</url>
    <content><![CDATA[<h2 id="MAC本地SSH"><a href="#MAC本地SSH" class="headerlink" title="MAC本地SSH"></a>MAC本地SSH</h2><ul>
<li><p>macos开启ssh</p>
<pre><code>  在MacOS输入命令ssh localhost得到
  ssh: connect to host localhost port 22: Connection refused
  解决方法是选择系统偏好设置-&gt;选择共享-&gt;点击远程登录
</code></pre>
</li>
</ul>
<h2 id="查看SSH状态"><a href="#查看SSH状态" class="headerlink" title="查看SSH状态"></a>查看SSH状态</h2><ul>
<li><p>查看ssh是否正常运行</p>
<pre><code>  ps -e | grep ssh
  或者
  ssh localhost
  
</code></pre>
</li>
<li><p>如果没有运行则运行(linux)</p>
<pre><code>  service sshd start    
  
</code></pre>
</li>
<li><p>端口号</p>
<pre><code>  SSH默认端口号：22
</code></pre>
</li>
</ul>
<h2 id="修改Linux默认SSH端口号"><a href="#修改Linux默认SSH端口号" class="headerlink" title="修改Linux默认SSH端口号"></a>修改Linux默认SSH端口号</h2><ul>
<li><p>修改Linux的SSH端口</p>
<pre><code>  Linux中，SSH配置文件一般在 /etc/ssh/
  ssh_config 文件就是其配置文件，找到port，去掉注释，修改22为其他端口
  重启SSH：
  /etc/rc.d/init.d/sshd restart
  或者
  service sshd restart
      
</code></pre>
</li>
</ul>
<h2 id="SSH远程登录命令"><a href="#SSH远程登录命令" class="headerlink" title="SSH远程登录命令"></a>SSH远程登录命令</h2><ul>
<li><p>远程登录命令格式</p>
<pre><code>  ssh root@10.210.100.100
  
  or:
  
  ssh -p 端口号 root@10.210.100.100
  
</code></pre>
</li>
<li><p>登出</p>
<pre><code>  exit
</code></pre>
</li>
</ul>
<h2 id="通过SCP传文件到远程服务器"><a href="#通过SCP传文件到远程服务器" class="headerlink" title="通过SCP传文件到远程服务器"></a>通过SCP传文件到远程服务器</h2><ul>
<li><p>传文件格式：</p>
<pre><code>  scp ~/local/file user@remote:~/file
</code></pre>
<p>  示例：</p>
<pre><code>  scp ~/测试文件.zip root@10.210.100.100:/home/ux/Desktop/
  
  scp -P 26716 /Users/ux/Downloads/test.zip root@173.91.221.111:/mysoft/
  
  左边是本机要上传文件地址：~/测试文件.zip
  右边是远程机器用户名ip和要上传到的路径：root@10.210.100.100:/home/ux/Desktop/
  
</code></pre>
</li>
<li><p>带端口</p>
<pre><code>  scp -P 22 /Users/ux/Downloads/MySQL.tar root@121。233.122.111
</code></pre>
</li>
</ul>
<h2 id="通过SCP从远程服务器复制文件到本地"><a href="#通过SCP从远程服务器复制文件到本地" class="headerlink" title="通过SCP从远程服务器复制文件到本地"></a>通过SCP从远程服务器复制文件到本地</h2><ul>
<li><p>复制文件到本地</p>
<pre><code>  scp ux@10.223.50.1:/usr/local/nginx/conf/nginx.conf /Users/ux/Downloads    
  
  从远程服务器10.223.50.1的/usr/local/nginx/conf/目录下复制nginx.conf到本机的Users/ux/Downloads    文件夹下
</code></pre>
</li>
</ul>
]]></content>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>mac下远程软件</title>
    <url>/2018/09/27/mac%E4%B8%8B%E8%BF%9C%E7%A8%8B%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="jump-desktop"><a href="#jump-desktop" class="headerlink" title="jump desktop"></a>jump desktop</h2><ul>
<li><p>jump desktop连接windows</p>
<pre><code>  直接连接即可，端口会默认3389
</code></pre>
</li>
</ul>
<h2 id="remote-desktop-manager"><a href="#remote-desktop-manager" class="headerlink" title="remote desktop manager"></a>remote desktop manager</h2><ul>
<li><p>创建连接</p>
<pre><code>  1.添加会话，选择Microsoft Remote Desktop(RDP)
  
  2.(Computer name)填写IP、(用户名)用户名、(密码)密码
  
  3.本地资源中&gt;&gt;本地设备和资源&gt;&gt;勾选硬盘和Redirect specific folders,并点击Configure选择要共享的文件夹
  
  4.保存即可
</code></pre>
</li>
</ul>
]]></content>
      <tags>
        <tag>jumpDesktop</tag>
      </tags>
  </entry>
  <entry>
    <title>mac下配置多jdk</title>
    <url>/2017/11/30/mac%E4%B8%8B%E9%85%8D%E7%BD%AE%E5%A4%9Ajdk/</url>
    <content><![CDATA[<h2 id="安装jdk"><a href="#安装jdk" class="headerlink" title="安装jdk"></a>安装jdk</h2><ul>
<li><p>jdk下载</p>
<pre><code>  jdk1.7和jdk1.8可以直接在oracle官网下载，jdk1.6有苹果维护，所以需要在苹果官网下载dmg版本的文件。
  
</code></pre>
</li>
<li><p>jdk1.7/jdk1.8下载地址</p>
<blockquote>
<p><a href="http://www.oracle.com/technetwork/java/javase/archive-139210.html">http://www.oracle.com/technetwork/java/javase/archive-139210.html</a></p>
</blockquote>
</li>
<li><p>jdk1.6下载地址(苹果官方)，亲测macOS sierra可用</p>
<blockquote>
<p><a href="https://support.apple.com/kb/DL1572?locale=en_US&amp;viewlocale=en_US">https://support.apple.com/kb/DL1572?locale=en_US&amp;viewlocale=en_US</a></p>
</blockquote>
</li>
<li><p>安装<br>  下载的dmg文件直接点击安装即可。默认安装位置在:</p>
<pre><code>  资源库/Java/JavaVirtualMachines下，多个版本都在这个目录下。
  英文路径是: /Library/Java/JavaVirtualMachines/
</code></pre>
<p>  在这个目录下，可用看到安装的jdk1.6,jdk1.7,jdk1.8:</p>
<pre><code>  UXdeMacPro:~ ux$ cd /Library/java/JavaVirtualMachines/
  UXdeMacPro:JavaVirtualMachines ux$ ls
  1.6.0.jdk        jdk1.7.0_80.jdk        jdk1.8.0_144.jdk
  
  
</code></pre>
</li>
<li><p>设置版本切换</p>
<p>   terminal&gt; cd ~<br>   ls -a<br>   查看有没有.bash_profile隐藏文件，如果没有，则创建，有则修改即可：<br>   vim . bash_profile<br>   按下i键进入编辑模式，<br>   粘贴以下内容：</p>
<pre><code>   # 设置 JDK 6
  export JAVA_6_HOME=`/usr/libexec/java_home -v 1.6` 
   
  # 设置 JDK 7 
  export JAVA_7_HOME=`/usr/libexec/java_home -v 1.7.0_80`
    
  # 设置 JDK 8  
  export JAVA_8_HOME=`/usr/libexec/java_home -v 1.8.0_144`
  # 可添加其他版本。。  
  
  #默认JDK 7 
  export JAVA_HOME=$JAVA_7_HOME  
  
  #alias命令动态切换JDK版本   
  alias jdk6=&quot;export JAVA_HOME=$JAVA_6_HOME&quot; 
  alias jdk7=&quot;export JAVA_HOME=$JAVA_7_HOME&quot;  
  alias jdk8=&quot;export JAVA_HOME=$JAVA_8_HOME&quot;
  
  
</code></pre>
</li>
<li><p>保存</p>
<pre><code> 按下esc按键，在输入:wq即可。如果提示权限不够，如果提示权限不够，则放弃保存，以root 权限操作即可 sudo vim .bash_profile,然后进行编辑。
</code></pre>
<p>  保存完 .bash_profile文件后，在terminal执行命令：</p>
<pre><code>  source ~/.bash_profile
  
</code></pre>
<p>  使配置文件生效。<br>  之后再执行 jdk6或者jdk7或者jdk8进行版本切换：</p>
<pre><code>  XdeMacBook-Pro:~ ux$ jdk6
  UXdeMacPro:~ ux$ java -version
  java version &quot;1.6.0_65&quot;
  Java(TM) SE Runtime Environment (build 1.6.0_65-b14-468)
  Java HotSpot(TM) 64-Bit Server VM (build 20.65-b04-468, mixed mode)
  UXdeMacPro:~ ux$ javac -version
  javac 1.6.0_65
  
  UXdeMacPro:~ ux$ jdk7
  UXdeMacPro:~ ux$ java -version
  java version &quot;1.7.0_80&quot;
  Java(TM) SE Runtime Environment (build 1.7.0_80-b15)
  Java HotSpot(TM) 64-Bit Server VM (build 24.80-b11, mixed mode)
  UXdeMacPro:~ ux$ javac -version
  javac 1.7.0_80
  
</code></pre>
<p>  随着这样切换可以在终端有效，但是重新打开终端，显示的还是默认的jdk1.7,所以貌似还要手动修改. bash_profile文件设置默认jdk。。。</p>
</li>
<li><p>如果不想以命令行的方式设置.bash_profile配置文件，则可以进入terminal，</p>
<pre><code>  cd ~
  ls -a
  如果没有.bash_profile文件，则创建：
  touch .bash_profile

  然后关闭terminal，打开文件管理器Finder,按下command+shift+.组合键，
  显示隐藏文件，进入 用户/ux/ 即可看到.bash_profile文件，以文本方式打开编辑保存即可。(注意：我的电脑用户名是ux,所以是进入 用户/ux/ 文件夹下。)
  最后在terminal执行：
  source ~/.bash_profile
</code></pre>
</li>
</ul>
<h2 id="macos下jdk默认安装路径查看"><a href="#macos下jdk默认安装路径查看" class="headerlink" title="macos下jdk默认安装路径查看"></a>macos下jdk默认安装路径查看</h2><ul>
<li><p>终端中查看命令：</p>
<pre><code>  /usr/libexec/java_home
  
  输出结果显示安装在：
  /Library/Java/JavaVirtualMachines/jdk1.8.0_291.jdk/Contents/Home
  

  
</code></pre>
</li>
</ul>
]]></content>
      <tags>
        <tag>mac下多版本jdk配置</tag>
      </tags>
  </entry>
  <entry>
    <title>mac快捷键</title>
    <url>/2017/11/20/mac%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h2 id="mac快捷键"><a href="#mac快捷键" class="headerlink" title="mac快捷键"></a>mac快捷键</h2><ul>
<li><p>command相关</p>
<pre><code>  Finder：
      （桌面上）command+N/command+方向键上
      
  新建窗口：
      （对应的应用中）command+N    
      
  保存删除新建拷贝复制文件：
      保存：command+S
      删除：command+delete
      粘贴：command+C
      拷贝：command+V
      剪切：command+X
      复制：
      （拷贝不包含粘贴，复制是直接粘贴，相当于win下的ctrl+v,ctrl+v连续执行）
      新建（文件夹）：command+shift+N
      
  快捷搜索程序：
      command+空格键
      
  关闭窗口：
      command+W（关闭窗口）
      command+Q(彻底关闭程序)
      
  光标位置切换：
      command+方向键左/右：定位到当前行首/末尾
      command+方向键上/下：定位到当前页首/尾
      
      
</code></pre>
</li>
<li><p>control</p>
<pre><code>  control+F2：快速定位到左上角菜单栏
  control+F3:快速定位到Dock栏
  control+F8：快速定位到右上角状态栏
  
  control+F4:快速定位到活跃窗口
  control+F5:快速定位到当前窗口的工具框（如输入框等）

  
  以上关于control的组合快捷键在系统偏好&gt;键盘&gt;快捷键&gt;键盘中定义
  
</code></pre>
</li>
<li><p>F1~F12标准功能</p>
<pre><code>  mac默认情况F1~F12是多媒体功能，在系统偏好设置&gt;键盘&gt;键盘&gt;勾选&quot;将F1、F2等键用作标准功能&quot;，勾选后，F1~F12就不会影响开发软件下的快捷组合键了。
  
      
      
</code></pre>
</li>
<li><p>触摸板</p>
<pre><code>  四指向上推：当前运行程序
  五指捏/合:所有程序页面打开/关闭
  拇指+其余四手指开/合：打开桌面
</code></pre>
</li>
<li><p>mac商店</p>
<pre><code>  mac商店中的应用有限制，比如网易云音乐，在网易官网下载的和在mac商店下载的对于快捷键的支持是不一样的，网易官网下载的比较好用。    

  command+option+i   chrome浏览器调试界面（win下的f12功能）

  command+shift+a   打开应用程序文件夹

  command+shift+h   Chrome浏览器主页

  command+L   浏览器地址栏

  command+ +/-   放大/缩小 浏览器页面
</code></pre>
</li>
</ul>
<h2 id="自带高清壁纸"><a href="#自带高清壁纸" class="headerlink" title="自带高清壁纸"></a>自带高清壁纸</h2><ul>
<li>自带高清壁纸<pre><code>  /Library/Screen Savers/Default Collections/
</code></pre>
</li>
</ul>
]]></content>
      <tags>
        <tag>mac快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title>mac相关</title>
    <url>/2017/12/18/mac%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h2 id="launchpad显示数量修改"><a href="#launchpad显示数量修改" class="headerlink" title="launchpad显示数量修改"></a>launchpad显示数量修改</h2><pre><code>调整Launchpad每列显示的数量：
defaults write com.apple.dock springboard-rows -int 8
    
调整Launchpad每行显示的数量：
defaults write com.apple.dock springboard-columns -int 7

重置Dock和Launchpad：
defaults write com.apple.dock ResetLaunchPad -bool TRUE;killall Dock

恢复默认：
defaults write com.apple.dock springboard-rows Default

defaults write com.apple.dock springboard-columns Default

killall Dock
</code></pre>
<h2 id="alfred访问通讯录提醒关闭"><a href="#alfred访问通讯录提醒关闭" class="headerlink" title="alfred访问通讯录提醒关闭"></a>alfred访问通讯录提醒关闭</h2><ul>
<li><p>手动签名即可</p>
<p>  sudo codesign -f -d -s - /Applications/Alfred\ 3.app/Contents/Frameworks/Alfred\ Framework.framework/Versions/A/Alfred\ Framework</p>
<blockquote>
<p><a href="http://blog.csdn.net/leiflyy/article/details/78489638">http://blog.csdn.net/leiflyy/article/details/78489638</a></p>
</blockquote>
<h2 id="macOS安装未知来源"><a href="#macOS安装未知来源" class="headerlink" title="macOS安装未知来源"></a>macOS安装未知来源</h2></li>
<li><p>命令</p>
<p>  macOS sierra在安全与隐私中默认并没有 任何来源 选项安装软件，所以对于破解软件来说，可能会报软件包损坏，导致无法安装破解软件。</p>
<p>  执行命令开启即可：</p>
<pre><code>  sudo spctl --master-disable
</code></pre>
<h2 id="mac下intellij-IDEA运行某些项目dock栏出现java小窗口"><a href="#mac下intellij-IDEA运行某些项目dock栏出现java小窗口" class="headerlink" title="mac下intellij IDEA运行某些项目dock栏出现java小窗口"></a>mac下intellij IDEA运行某些项目dock栏出现java小窗口</h2></li>
<li><p>gui隐藏方法</p>
<p>  在IDEA的tomcat配置页面的VM options选项中填写下列参数：</p>
<pre><code>      -Djava.awt.headless=true    
</code></pre>
</li>
<li><p>这破玩意为什么会弹出来</p>
<blockquote>
<p><a href="http://blog.csdn.net/chs007chs/article/details/52291003">http://blog.csdn.net/chs007chs/article/details/52291003</a></p>
</blockquote>
<h2 id="macos下apache"><a href="#macos下apache" class="headerlink" title="macos下apache"></a>macos下apache</h2></li>
<li><p>apche so模块位置</p>
<pre><code>  /usr/libexec/apache2/
</code></pre>
</li>
<li><p>apache conf位置</p>
<pre><code>  /etc/apache2/httpd.conf
</code></pre>
</li>
<li><p>macOS启动apache</p>
<pre><code>  sudo apachectl start
</code></pre>
<h2 id="mac自带高清壁纸"><a href="#mac自带高清壁纸" class="headerlink" title="mac自带高清壁纸"></a>mac自带高清壁纸</h2></li>
<li><p>位置</p>
</li>
</ul>
<p>/Library/Screen Savers/Default Collections/</p>
<h2 id="免费svnx下载地址"><a href="#免费svnx下载地址" class="headerlink" title="免费svnx下载地址"></a>免费svnx下载地址</h2><ul>
<li><p>地址</p>
<blockquote>
<p><a href="https://code.google.com/archive/p/svnx/downloads">https://code.google.com/archive/p/svnx/downloads</a></p>
</blockquote>
<h2 id="mac-high-sierra下字体模糊"><a href="#mac-high-sierra下字体模糊" class="headerlink" title="mac high sierra下字体模糊"></a>mac high sierra下字体模糊</h2><p>  defaults -currentHost write -globalDomain AppleFontSmoothing -int 1</p>
</li>
</ul>
<h2 id="mac下出现xcrun-error导致svn无法使用的解决办法"><a href="#mac下出现xcrun-error导致svn无法使用的解决办法" class="headerlink" title="mac下出现xcrun: error导致svn无法使用的解决办法"></a>mac下出现xcrun: error导致svn无法使用的解决办法</h2><pre><code>xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun
</code></pre>
<p>执行命令:</p>
<pre><code>xcode-select --install    
</code></pre>
<h2 id="mac磁盘索引"><a href="#mac磁盘索引" class="headerlink" title="mac磁盘索引"></a>mac磁盘索引</h2><pre><code>sudo mdutil -a -i on    
</code></pre>
<h2 id="软件提示”文件损坏，无法打开“"><a href="#软件提示”文件损坏，无法打开“" class="headerlink" title="软件提示”文件损坏，无法打开“"></a>软件提示”文件损坏，无法打开“</h2><pre><code>打开终端；
输入以下命令，回车；
sudo xattr -d com.apple.quarantine /Applications/xxxx.app
注意：/Applications/xxxx.app 换成你的App路径（推荐直接将.app文件拖入终端中自动生成路径，以防空格等转义字符手动复制或输入出现错误）
重启App即可。
</code></pre>
<p>​<br>​    </p>
<h2 id="达梦数据库DataGrip配置"><a href="#达梦数据库DataGrip配置" class="headerlink" title="达梦数据库DataGrip配置"></a>达梦数据库DataGrip配置</h2><pre><code>jdbc:dm://&#123;host::localhost&#125;?[:&#123;port::5236&#125;]
</code></pre>
<p>​    </p>
<h2 id="mac深色-黑暗-黑色-模式下navicat设置为浅色"><a href="#mac深色-黑暗-黑色-模式下navicat设置为浅色" class="headerlink" title="mac深色(黑暗/黑色)模式下navicat设置为浅色"></a>mac深色(黑暗/黑色)模式下navicat设置为浅色</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.通过命令找Navicat Premium的全名：</span><br><span class="line">osascript -e &#x27;id of app &quot;Navicat Premium&quot;&#x27;</span><br><span class="line">查找结果：</span><br><span class="line">com.prect.NavicatPremium15</span><br><span class="line"></span><br><span class="line">2：将com.prect.NavicatPremium15调整为浅色模式：</span><br><span class="line">defaults write com.prect.NavicatPremium15 NSRequiresAquaSystemAppearance -bool Yes </span><br><span class="line"></span><br><span class="line">终端：</span><br><span class="line">defaults write com.apple.Terminal NSRequiresAquaSystemAppearance -bool Yes</span><br><span class="line"></span><br><span class="line">docker:</span><br><span class="line">defaults write com.docker.docker NSRequiresAquaSystemAppearance -bool Yes</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>mac相关</tag>
      </tags>
  </entry>
  <entry>
    <title>mvc</title>
    <url>/2017/07/07/mvc/</url>
    <content><![CDATA[<h2 id="MVC图示"><a href="#MVC图示" class="headerlink" title="MVC图示"></a>MVC图示</h2><ul>
<li><p>MVC调用</p>
<p>  <img src="http://op05inpyd.bkt.clouddn.com/MVC.jpg"></p>
</li>
<li><p>MVC三层结构</p>
<p>  <img src="http://op05inpyd.bkt.clouddn.com/MVC%E4%B8%89%E5%B1%82.jpg"></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>mvc</tag>
      </tags>
  </entry>
  <entry>
    <title>mac连接数据库的代替方案</title>
    <url>/2017/11/29/mac%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BB%A3%E6%9B%BF%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="代替工具"><a href="#代替工具" class="headerlink" title="代替工具"></a>代替工具</h2><ul>
<li><p>工具</p>
<p>  Intellij IDEA</p>
</li>
<li><p>使用方式</p>
<pre><code>  IDEA工具栏&gt; View&gt;Tool windows&gt;Database
  调出数据库连接界面。
  点击+号，选择数据库类型，如图：
</code></pre>
<p>  <img src="http://op05inpyd.bkt.clouddn.com/IDEA%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%931.png"></p>
<pre><code>  填写数据库用户名，密码，url,点击下载相应的数据库驱动。
  点击test connection
  测试成功则表明连接成功，保存信息即可，测试结果如果失败，则表明信息不对，
  核查用户名，密码，url重新测试连接。如图：
</code></pre>
<p>  <img src="http://op05inpyd.bkt.clouddn.com/IDEA%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%933.png"></p>
</li>
<li><p>数据库url填写参考</p>
<pre><code>  mysql：
      
      jdbc:mysql://localhost:3306
      驱动类型：MySql
  
  DB2(该数据库在Windows服务器上):
          
      jdbc:db2://192.168.1.99:50000/tradecc
      驱动类型:DB2(LUW)
      (具体详见本地lib包：IDEA连接数据库)
      
      
      
      
      
  
</code></pre>
</li>
</ul>
]]></content>
      <tags>
        <tag>mac下连接数据库代替方案</tag>
      </tags>
  </entry>
  <entry>
    <title>navicat连接虚拟机的oracle</title>
    <url>/2017/07/28/navicat%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84oracle/</url>
    <content><![CDATA[<h2 id="navicat连接虚拟机的oracle"><a href="#navicat连接虚拟机的oracle" class="headerlink" title="navicat连接虚拟机的oracle"></a>navicat连接虚拟机的oracle</h2><h3 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明:"></a>环境说明:</h3><ul>
<li>虚拟机：VMware8</li>
<li>虚拟机系统：winxp</li>
<li>oracle版本：32位，Oracle Database 10g Enterprise Edition Release 10.2.0.1.0</li>
<li>navicat版本：64位，navicat premium 11.0.17</li>
</ul>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><ul>
<li><p>确定虚拟机的ip:VM&gt;edit&gt;virtual network</p>
<pre><code>  我的是NAT方式共享主机网络，ip是192.168.201.0(非真实)
  进xp系统，cmd下ipconfig:192.168.201.128
</code></pre>
</li>
<li><p>确定主机与虚拟机能互相访问(最主要的是主机能访问虚拟机)</p>
<pre><code>  主机cmd下ping虚拟机xp系统的ip:ping 192.168.201.128
  如果ping出现问题，手动关闭虚拟机xp系统的防火墙。
</code></pre>
</li>
<li><p>navicat连接oracle,这一步出现问题最多</p>
<pre><code>  navicat建立连接，填写ip为虚拟机xp系统的ip,服务名ORCL,
  用户名可以填SYSTEM，还有密码(安装oracle的时候设置的),

  点击连接测试，报无法加载OCI.dll 193错误，网上大多教程都是下载32位的basic-client,试了几次依旧报错，因为我的navicat是64位的，且版本是11，所以下载了：

  instantclient-basic-windows.x64-12.2.0.1.0
  instantclient-sqlplus-windows.x64-12.2.0.1.0

  这两个64位的，解压，将instantclient_12_2中的文件合并，
  打开navicat，工具&gt;选项&gt;OCI:选择刚刚instantclient_12_2中的
  oci.dll和sqlplus.exe,保存，重启navicat,连接oracle,OK了。
</code></pre>
</li>
</ul>
<p><strong>注意：navicat报错的时候，点开连接，里面有下载client的地址以及老版本的操作方式</strong></p>
<p><img src="http://op05inpyd.bkt.clouddn.com/navicat_oracle.png"><br><img src="http://op05inpyd.bkt.clouddn.com/navicat_oracle2.png"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>redis</title>
    <url>/2018/05/24/redis/</url>
    <content><![CDATA[<h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><p>可以承载每秒10W+的并发数。</p>
<ul>
<li>官网<blockquote>
<p><a href="https://redis.io/">https://redis.io/</a></p>
</blockquote>
</li>
<li>中文网<blockquote>
<p><a href="http://www.redis.cn/">http://www.redis.cn/</a></p>
</blockquote>
</li>
</ul>
<h3 id="两个需要用到的命令"><a href="#两个需要用到的命令" class="headerlink" title="两个需要用到的命令"></a>两个需要用到的命令</h3><ul>
<li>1.SETNX(一定要去看看链接介绍)<blockquote>
<p><a href="http://www.redis.cn/commands/setnx.html">http://www.redis.cn/commands/setnx.html</a></p>
</blockquote>
</li>
<li>2.GETSET(一定要去看看链接介绍)<blockquote>
<p><a href="http://www.redis.cn/commands/getset.html">http://www.redis.cn/commands/getset.html</a></p>
</blockquote>
</li>
</ul>
<h2 id="reids分布式session的应用"><a href="#reids分布式session的应用" class="headerlink" title="reids分布式session的应用"></a>reids分布式session的应用</h2><h2 id="redis分布式锁的应用"><a href="#redis分布式锁的应用" class="headerlink" title="redis分布式锁的应用"></a>redis分布式锁的应用</h2><blockquote>
<p><a href="https://blog.csdn.net/forezp/article/details/68957681">https://blog.csdn.net/forezp/article/details/68957681</a></p>
</blockquote>
<h2 id="redis缓存的应用"><a href="#redis缓存的应用" class="headerlink" title="redis缓存的应用"></a>redis缓存的应用</h2>]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>private</title>
    <url>/2018/01/29/private/</url>
    <content><![CDATA[<h3 id="按钮可执行性"><a href="#按钮可执行性" class="headerlink" title="按钮可执行性"></a>按钮可执行性</h3><pre><code>document.all.share.disabled=true;
document.all.share.disabled=false;
</code></pre>
<h3 id="获取gird的值："><a href="#获取gird的值：" class="headerlink" title="获取gird的值："></a>获取gird的值：</h3><pre><code>var projectsid = gridgetselectvalue(&quot;projectsid&quot;);

如果gird的名字是mygrid,则:

var projectsid = mygridgetselectvalue(&quot;projectsid&quot;);
</code></pre>
<h3 id="获取普通属性值："><a href="#获取普通属性值：" class="headerlink" title="获取普通属性值："></a>获取普通属性值：</h3><pre><code>如获取property=&quot;result&quot;的值：

var result = document.all.result.value;

获取后端Attribute传值：
&lt;%
    String openjspflag = (request.getAttribute(&quot;openjspflag&quot;) == null) ? &quot;0&quot; : request.getAttribute(&quot;openjspflag&quot;).toString();
%&gt;
</code></pre>
<h3 id="TD占位分割"><a href="#TD占位分割" class="headerlink" title="TD占位分割"></a>TD占位分割</h3><pre><code>&lt;table border=&quot;0&quot; width=&quot;100%&quot; class=&quot;searchzone&quot; &gt;
&lt;TR class=&quot;txttr&quot;&gt;
    
&lt;td colspan=&quot;2&quot;&gt;
        &lt;table border=&quot;0&quot; width=&quot;100%&quot; align=&quot;center&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;
            &lt;tr&gt;
                
                   &lt;td class=&quot;sr&quot; align=&quot;left&quot; style=&quot;width:1%&quot; nowrap&gt;部门：&lt;/td&gt;
                &lt;td  class=&quot;sr&quot; align=&quot;left&quot; style=&quot;width:15%&quot; nowrap&gt;
                    &lt;select:select property=&quot;departname&quot;  addspacerow=&quot;true&quot; style=&quot;width:90%&quot; styleClass=&quot;txt&quot; onchange=&quot;fillperson()&quot;&gt;
                         &lt;select:options collection=&quot;gird.factoryname&quot; property=&quot;departsid&quot; labelProperty=&quot;departname&quot; /&gt;
                    &lt;/select:select&gt;
                &lt;/td&gt;
    
                &lt;td class=&quot;sr&quot; align=&quot;left&quot; style=&quot;width:1%&quot; nowrap&gt;责任人：&lt;/td&gt;
                &lt;td  class=&quot;sr&quot; align=&quot;left&quot; style=&quot;width:15%;padding:0&quot; nowrap&gt;
                    &lt;select:select property=&quot;personname&quot;  addspacerow=&quot;true&quot; style=&quot;width:90%&quot; styleClass=&quot;txt&quot;&gt;
                         &lt;select:options collection=&quot;gird.factoryname&quot; property=&quot;personsid&quot; labelProperty=&quot;personname&quot; /&gt;
                    &lt;/select:select&gt;
                &lt;/td&gt;
                &lt;td width=&quot;30%&quot;&gt;&lt;/td&gt;
                &lt;td width=&quot;30%&quot;&gt;&lt;/td&gt;
                
            &lt;/tr&gt;
        &lt;/table&gt;
&lt;/td&gt;
    
&lt;/TR&gt;
&lt;/table&gt;
</code></pre>
<h3 id="TD占位分割标准版："><a href="#TD占位分割标准版：" class="headerlink" title="TD占位分割标准版："></a>TD占位分割标准版：</h3><pre><code>&lt;style type=&quot;text/css&quot;&gt;
table&#123;
    text-align:center;
    border-collapse:collapse;
&#125;
tr&#123;
    height:50px;
&#125;
.mytd&#123;
    border-right:1px solid red;
&#125;
&lt;/style&gt;
&lt;table width=&quot;100%&quot; border=&quot;1&quot; bordercolor=&quot;red&quot; align=&quot;center&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;
&lt;tr&gt;
    &lt;td colspan=&quot;2&quot;&gt;
        &lt;table border=&quot;0&quot; width=&quot;100%&quot; align=&quot;center&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;
            &lt;tr&gt;
                &lt;td class=&quot;mytd&quot; width=&quot;70%&quot;&gt;70%&lt;/td&gt;
                &lt;td width=&quot;30%&quot;&gt;30%&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/table&gt;
    &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;50%&lt;/td&gt;
    &lt;td&gt;50%&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
</code></pre>
<h3 id="textarea以及其readonly："><a href="#textarea以及其readonly：" class="headerlink" title="textarea以及其readonly："></a>textarea以及其readonly：</h3><pre><code>&lt;TR class=&quot;txttr&quot;&gt;
        &lt;td class=&quot;sr&quot; align=&quot;left&quot;  nowrap width=&quot;95%&quot;&gt;
            &lt;span  style=&quot;height:300px;display:block;vetical-align:top;float:left;&quot;&gt;任务内容&amp;nbsp&lt;/span&gt;
            &lt;!-- &lt;textarea id=&quot;taskcontent&quot; style=&quot;width:100%;height:300px;&quot;&gt;&lt;/textarea&gt; --&gt;
            &lt;html:textarea property=&quot;taskcontent&quot; rows=&quot;10&quot; style=&quot;width:100%&quot;/&gt;
        &lt;/td&gt;
&lt;/TR&gt;
</code></pre>
<hr>
<pre><code>&lt;td class=&quot;sr&quot; align=&quot;left&quot;  nowrap width=&quot;95%&quot;&gt;
            &lt;span style=&quot;height:30px;display:block;vetical-align:top;float:left;&quot;&gt;任务主题&amp;nbsp&lt;/span&gt;
            &lt;!-- &lt;input type=&quot;text&quot; id=&quot;taskname&quot; style=&quot;height:30px;width:100%&quot;&gt; --&gt;
            &lt;html:text property=&quot;taskname&quot;  maxlength=&quot;20&quot; readonly=&quot;false&quot; styleClass=&quot;txt&quot; style=&quot;width:100%&quot;/&gt;
        
&lt;/td&gt;
</code></pre>
<hr>
<pre><code>&lt;TR class=&quot;txttr&quot;&gt;
        &lt;td class=&quot;zw&quot; align=&quot;left&quot;  style=&quot;width:20%&quot; nowrap&gt;备注:&lt;/td&gt;
        &lt;td class=&quot;sr&quot; align=&quot;right&quot; style=&quot;width:80%&quot; nowrap&gt;
            &lt;html:textarea property=&quot;remark&quot; rows=&quot;10&quot; readonly=&quot;false&quot; style=&quot;width:100%;height:90px&quot;/&gt;
        &lt;/td&gt;
&lt;/TR&gt;
</code></pre>
<script>
    if("123000"==prompt("Please input password"))
    {
        alert("Right");
    }else{
        alert("Wrong");
        location="https://www.imux.space";
    }
</script>]]></content>
      <tags>
        <tag>private</tag>
      </tags>
  </entry>
  <entry>
    <title>restful</title>
    <url>/2018/05/26/restful/</url>
    <content><![CDATA[<h2 id="restful规范"><a href="#restful规范" class="headerlink" title="restful规范"></a>restful规范</h2><ul>
<li><p>规范简述</p>
<p>  GET -&gt; 查询操作<br>  POST -&gt; 添加/修改操作<br>  PUT -&gt; 修改操作<br>  DELETE -&gt;删除操作</p>
</li>
<li><p>REST</p>
<blockquote>
<p><a href="https://blog.csdn.net/qq_29115715/article/details/80090403">https://blog.csdn.net/qq_29115715/article/details/80090403</a></p>
</blockquote>
</li>
</ul>
]]></content>
      <tags>
        <tag>restful</tag>
      </tags>
  </entry>
  <entry>
    <title>shiro</title>
    <url>/2017/12/05/shiro/</url>
    <content><![CDATA[<h2 id="shiro认证的主要过程"><a href="#shiro认证的主要过程" class="headerlink" title="shiro认证的主要过程"></a>shiro认证的主要过程</h2><ul>
<li><p>通过apache shiro处理用户认证和权限问题</p>
<p>  首先需要自己编写UserRealm类并继承Realm，用以实现认证和授权操作</p>
<ul>
<li><p>身份认证</p>
<pre><code>  /**
   * 验证当前登录的用户
   *
   * @param authenticationToken
   * @return
   * @throws AuthenticationException
   */
  protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123;
      // 获取需要验证的用户名
      String userName = (String) authenticationToken.getPrincipal();
      //authenticationToken.getCredentials();//凭证信息，即：密码
      // 查询数据库中是否存在该用户名
      User user = this.userService.getUserByUserName(userName);
      if (user != null) &#123;
          // 存在,则为该用户授予角色和权限
          AuthenticationInfo authcInfo = new SimpleAuthenticationInfo(user.getUserName(), user.getPassword(), &quot;xx&quot;);
          return authcInfo;
      &#125;
      // 不存在
      return null;
  &#125;
</code></pre>
</li>
<li><p>权限控制</p>
<pre><code>  /**
   * 为当前登录的用户授予角色和权限
   *
   * @param principalCollection
   * @return
   */
  protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123;
      // 获取需要授权的用户名
      String userName = (String) principalCollection.getPrimaryPrincipal();
      // 创建授权对象
      SimpleAuthorizationInfo authzInfo = new SimpleAuthorizationInfo();
      // 查询当前用户名角色并授权
      authzInfo.setRoles(this.userService.getRolesByUserName(userName));
      // 查询当前用户名权限并授权
      authzInfo.setStringPermissions(this.userService.getPermissionByUserName(userName));
      return authzInfo;
  &#125;
</code></pre>
</li>
<li><p>controller中对应的代码</p>
<pre><code>  @RequestMapping(&quot;/login&quot;)
  public String login(User user, HttpServletRequest request) &#123;
      // 获取subject对象
      Subject subject = SecurityUtils.getSubject();
      // 实例化用户名密码令牌
      UsernamePasswordToken token = new UsernamePasswordToken(user.getUserName(), user.getPassword());
      //token.setRememberMe(false);
      try &#123;
          // 使用subject对象进行登陆
          subject.login(token);
          // 获取session
          Session session = subject.getSession();
          // 输出session
          //System.out.println(&quot;sessionId:&quot; + session.getId() + &quot;;sessionHost:&quot; + session.getHost() + &quot;;sessionTimeout:%s&quot; + session.getTimeout());
          session.setAttribute(&quot;info&quot;, &quot;session的数据&quot;);
          return &quot;redirect:success&quot;;
      &#125; catch (Exception e) &#123;
          // 验证失败
          e.printStackTrace();
          request.setAttribute(&quot;user&quot;, user);
          request.setAttribute(&quot;errorMsg&quot;, &quot;用户名或密码错误&quot;);
          return &quot;login&quot;;
      &#125;
  &#125;
</code></pre>
</li>
</ul>
</li>
<li><p>参考链接</p>
<blockquote>
<p><a href="http://blog.csdn.net/sinat_35767703/article/details/67633186">http://blog.csdn.net/sinat_35767703/article/details/67633186</a></p>
</blockquote>
<blockquote>
<p><a href="http://blog.csdn.net/he90227/article/details/38663553">http://blog.csdn.net/he90227/article/details/38663553</a></p>
</blockquote>
</li>
</ul>
<h2 id="shiro框架下获取当前登录用户名"><a href="#shiro框架下获取当前登录用户名" class="headerlink" title="shiro框架下获取当前登录用户名"></a>shiro框架下获取当前登录用户名</h2><ul>
<li><p>获取用户名（后端）</p>
<pre><code>   //当前登录用户ID
   String loginuser = (String)SecurityUtils.getSubject().getPrincipal();
</code></pre>
</li>
<li><p>获取用户名（前端）</p>
<p>  引入标签</p>
<pre><code>  &lt;%@ taglib prefix=&quot;shiro&quot; uri=&quot;http://shiro.apache.org/tags&quot; %&gt;
  &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
  &lt;%@ page isELIgnored=&quot;false&quot; %&gt;&lt;%--开启EL表达式--%&gt;
  
</code></pre>
<p>  使用shiro标签获取当前登录用户</p>
<pre><code>  &lt;shiro:principal/&gt;
</code></pre>
</li>
</ul>
<h2 id="shiro-ssm中遇到的问题"><a href="#shiro-ssm中遇到的问题" class="headerlink" title="shiro+ssm中遇到的问题"></a>shiro+ssm中遇到的问题</h2><ul>
<li><p>shiro+ssm在jdk7下正常启动运行，在jdk6下无法启动运行：</p>
<p>  控制台错误日志：</p>
<pre><code>  org.springframework.beans.factory.BeanCreationException: 
  Error creating bean with name &#39;shiroFilter&#39; defined in class path resource [spring-mybatis.xml]: 
  BeanPostProcessor before instantiation of bean failed; nested exception is org.springframework.beans.factory.BeanCreationException: 
  Error creating bean with name &#39;org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor#0&#39; defined in class 
  path resource [spring-mybatis.xml]: Cannot resolve reference to bean &#39;securityManager&#39; while setting bean property &#39;securityManager&#39;; 
  nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;securityManager&#39; defined 
  in class path resource [spring-mybatis.xml]: ........
  
</code></pre>
<p>  在控制台搜索error还可以找到以下关键信息：</p>
<pre><code>  Caused by: java.lang.UnsupportedClassVersionError: 
  org/aspectj/weaver/tools/PointcutDesignatorHandler : 
  Unsupported major.minor version 51.0 (unable to load class org.aspectj.weaver.tools.PointcutDesignatorHandler)

  由这段错误信息可以知道，aspectj没有被正确加载加载，原因是该版本不被支持，在pom.xml文件中找到aspectj：
   &lt;!-- aspectjweaver --&gt;
  &lt;dependency&gt;
      &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
      &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
      &lt;version&gt;1.8.10&lt;/version&gt;
  &lt;/dependency&gt;
  
  Unsupported major.minor version 51.0错误提示的原因：
  这段错误提示的根本原因是我们使用低版本的 JRE 去运行高版本 JDK 编译的 class 文件！，51是jdk7
</code></pre>
</li>
</ul>
]]></content>
      <tags>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>spring</title>
    <url>/2018/05/23/spring/</url>
    <content><![CDATA[<h2 id="spring注解"><a href="#spring注解" class="headerlink" title="spring注解"></a>spring注解</h2><ul>
<li><p>Spring的20+种常用注解</p>
<blockquote>
<p><a href="https://mp.weixin.qq.com/s/b8bKuoaJAgGdFx9nTaFpgg">https://mp.weixin.qq.com/s/b8bKuoaJAgGdFx9nTaFpgg</a></p>
</blockquote>
</li>
<li><p>spring4</p>
</li>
<li><p>RestController</p>
<pre><code>  @Controller
  @ResponseBody
  两个注解可以替换成
  @RestController
</code></pre>
</li>
<li><p>RequestMapping可以同时配置两个请求路径：</p>
<pre><code>  @RequestMapping(value = &#123;&quot;/hello&quot;,&quot;hi&quot;&#125;)
  
</code></pre>
</li>
<li><p>  指定请求类型以及获取请求参数的另一种写法</p>
<pre><code>      @RestController
      public class Test1 &#123;
          /*
           * http://localhost:8080/boot/hello/?id=3
           * required = false  参数时候为必须；defaultValue = &quot;0&quot;
           */
          @RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.POST)
          public String hello(@RequestParam(value = &quot;id&quot;, required = false, defaultValue = &quot;0&quot;) Integer myid) &#123;
          return &quot;id= &quot; + myid;
          &#125;
  
          //http://localhost:8080/boot/hello2/9
          @RequestMapping(value = &quot;/hello2/&#123;id&#125;&quot;, method = RequestMethod.POST)
          public String hello2(@PathVariable(value = &quot;id&quot;, required = false) Integer myid) &#123;
              return &quot;id= &quot; + myid;
          &#125;
      &#125;
  
</code></pre>
</li>
<li><p>RequestParam与PathVariable</p>
<pre><code>  RequestParam：获取请求参数
  PathVariable：获取路径变量
  
</code></pre>
<p>  <img src="http://ogy57hyu6.bkt.clouddn.com/pathVariable.png"></p>
</li>
<li><p>请求注解    </p>
<pre><code>  @RequestMapping
  *******分割线********
  @GetMapping
  @PostMapping
  @PutMapping
  @DeleteMapping    
   RequestMapping注解与下面几种的不同就是：下面几种注解直接指定了请求类型，是组合注解，
  如@GetMapping相当于@RequestMapping(method = RequestMethod.POST)
</code></pre>
</li>
</ul>
<h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><ul>
<li><p>为什么用IOC</p>
<p>  1.对象创建统一托管<br>  2.规范的声明周期管理<br>  3.灵活的依赖注入<br>  4.一直的获取对象</p>
</li>
<li><p>Spring IOC注入方式和场景</p>
<p>  <img src="http://ogy57hyu6.bkt.clouddn.com/SpringIOC%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F%E5%92%8C%E5%9C%BA%E6%99%AF.png"></p>
</li>
</ul>
<h2 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h2><ul>
<li><p>声明式事务-配置</p>
<p>  <img src="http://ogy57hyu6.bkt.clouddn.com/%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E9%85%8D%E7%BD%AE.png"></p>
</li>
<li><p>声明式事务-使用方式<br>  <img src="http://ogy57hyu6.bkt.clouddn.com/%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F.png"></p>
</li>
<li><p>声明式事务-事务回滚</p>
<p>  <img src="http://ogy57hyu6.bkt.clouddn.com/%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1-%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A.png"></p>
<p>  不当的try-catch可能使事务不能生效，如发生了异常但是做了try-catch,可能使一部分执行成功，一部分执行失败，违背事务初衷。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot下的邮件系统</title>
    <url>/2018/12/02/springboot%E4%B8%8B%E7%9A%84%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="邮件系统的实现条件"><a href="#邮件系统的实现条件" class="headerlink" title="邮件系统的实现条件"></a>邮件系统的实现条件</h2><h4 id="待续…"><a href="#待续…" class="headerlink" title="待续…"></a>待续…</h4><h2 id="邮件系统的实现过程"><a href="#邮件系统的实现过程" class="headerlink" title="邮件系统的实现过程"></a>邮件系统的实现过程</h2><h4 id="待续…-1"><a href="#待续…-1" class="headerlink" title="待续…"></a>待续…</h4>]]></content>
      <tags>
        <tag>邮件系统</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot</title>
    <url>/2018/04/24/springboot/</url>
    <content><![CDATA[<h2 id="命令小记"><a href="#命令小记" class="headerlink" title="命令小记"></a>命令小记</h2><ul>
<li><p>另一种部署jar方式：</p>
<pre><code>  java -jar -Dserver.port=8090 wxsell.jar
</code></pre>
</li>
<li><p>maven打包</p>
<pre><code>  mvn clean package -Dmaven.test.skip=true
</code></pre>
</li>
</ul>
<h2 id="springboot多数据源"><a href="#springboot多数据源" class="headerlink" title="springboot多数据源"></a>springboot多数据源</h2><ul>
<li>第二数据源<pre><code>  yml配置文件中：

      custom:
        datasource:
          names: ds1
          ds1:
            driver-class-name: com.mysql.jdbc.Driver
            url: jdbc:mysql://121.196.221.4:3306:test
            username: 123
            password: 123    
        
  service impl中相应的要使用第二数据源的方法中：

      @TargetDataSource(&quot;ds1&quot;)
      public void insert() &#123;
  
      &#125;
</code></pre>
</li>
</ul>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot与mybatis整合</title>
    <url>/2018/05/22/springboot%E4%B8%8Emybatis%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<h2 id="SpringBoot与mybatis整合"><a href="#SpringBoot与mybatis整合" class="headerlink" title="SpringBoot与mybatis整合"></a>SpringBoot与mybatis整合</h2><ol>
<li><p>maven引入mybatis包<strong>（第1步-总）</strong></p>
<pre><code>    &lt;!--mybatis--&gt;
 &lt;dependency&gt;
     &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
     &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
     &lt;version&gt;1.3.2&lt;/version&gt;
 &lt;/dependency&gt;
 
</code></pre>
</li>
<li><p>springboot启动类中设置扫描包位置<strong>（第2步-总）</strong></p>
<pre><code> //没有数据源时添加 exclude = &#123;DataSourceAutoConfiguration.class&#125;
 @SpringBootApplication
 @MapperScan(basePackages = &quot;com.imux.xwsell.dao&quot;)
 public class WxsellApplication &#123;
 
     public static void main(String[] args) &#123;
         SpringApplication.run(WxsellApplication.class, args);
     &#125;
 &#125;    
</code></pre>
</li>
</ol>
<h3 id="xml方式"><a href="#xml方式" class="headerlink" title="xml方式"></a>xml方式</h3><ul>
<li><p>xml方式</p>
<ol start="3">
<li>dao中写接口,与传统ssm无异<strong>（第3步-xml）</strong></li>
<li>resources/mapper下对应的xml文件中，指明namespace(即对应的dao接口)<strong>（第4步-xml）</strong></li>
<li>application.yml文件中配置mapper.xml文件夹位置（即resource/mapper文件夹的位置），如下：<strong>（第5步-xml）</strong><pre><code> ##mybatis xml方式mapper.xml文件夹位置配置
 #mybatis:
 #  mapper-locations: classpath:mapper/*.xml
</code></pre>
</li>
</ol>
</li>
</ul>
<h3 id="纯注解方式"><a href="#纯注解方式" class="headerlink" title="纯注解方式"></a>纯注解方式</h3><ul>
<li><p>纯注解方式</p>
<ol start="3">
<li>dao中写接口，每一个接口方法上写sql语句，并用对应的注解修饰如：<strong>（第3步-纯注解）</strong> @Insert(insert into user_info(user_name) vlues (#userName))<br> int insertByMap(Map&lt;String,Object&gt; map); @Select<br> @Result<hr>
 @Update<br> 等…</li>
</ol>
</li>
</ul>
<h3 id="由上面两种方式可以看出，xml方式一共需要5步，纯注解方式需要3步。"><a href="#由上面两种方式可以看出，xml方式一共需要5步，纯注解方式需要3步。" class="headerlink" title="由上面两种方式可以看出，xml方式一共需要5步，纯注解方式需要3步。"></a>由上面两种方式可以看出，xml方式一共需要5步，纯注解方式需要3步。</h3>]]></content>
      <tags>
        <tag>springboot与mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>svn</title>
    <url>/2017/11/29/svn/</url>
    <content><![CDATA[<h2 id="下载链接"><a href="#下载链接" class="headerlink" title="下载链接"></a>下载链接</h2><ul>
<li><p>macOS下的svn客户端svnx下载链接(免费)：</p>
<blockquote>
<p><a href="https://code.google.com/archive/p/svnx/downloads">https://code.google.com/archive/p/svnx/downloads</a></p>
</blockquote>
<p>  注意：这里说的svn和svn客户端是不同的东西。</p>
</li>
<li><p><strong>macos下的svn</strong></p>
<p>  参考文章：</p>
<blockquote>
<p><a href="http://blog.csdn.net/bruce128/article/details/52652230">http://blog.csdn.net/bruce128/article/details/52652230</a></p>
</blockquote>
<p>  macos下的svn貌似是系统自带的如果系统中没有，需要安装XCode,然后安装Command Line Tools</p>
</li>
<li><p>svn命令</p>
<pre><code>  查看svn版本：
      terminal运行
      svn --version

  检出项目：
      在terminal命令行工具，进入想要将文件检出到的文件夹，执行：
      svn co url
      该url是svn中项目地址。
      然后会提示输入用户名和密码。
          
</code></pre>
</li>
<li><p>提交什么的就交给svnx客户端吧。</p>
</li>
</ul>
<h2 id="windows下svn客户端tortoisesvn无法日志问题"><a href="#windows下svn客户端tortoisesvn无法日志问题" class="headerlink" title="windows下svn客户端tortoisesvn无法日志问题"></a>windows下svn客户端tortoisesvn无法日志问题</h2><ul>
<li><p>log message offline只显示离线日志</p>
<pre><code>  右键&gt; tortoisesvn&gt;settings&gt;saved Data&gt;clear
</code></pre>
<blockquote>
<p><a href="http://blog.csdn.net/baikeliang/article/details/49280753">http://blog.csdn.net/baikeliang/article/details/49280753</a></p>
</blockquote>
</li>
</ul>
]]></content>
      <tags>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title>tomcat</title>
    <url>/2017/04/29/tomcat/</url>
    <content><![CDATA[<h2 id="tomcat目录结构"><a href="#tomcat目录结构" class="headerlink" title="tomcat目录结构"></a>tomcat目录结构</h2><p><img src="http://op05inpyd.bkt.clouddn.com/tomcat_1.png"></p>
<h2 id="web项目发布到Tomcat的三种常用方式"><a href="#web项目发布到Tomcat的三种常用方式" class="headerlink" title="web项目发布到Tomcat的三种常用方式"></a>web项目发布到Tomcat的三种常用方式</h2><ul>
<li><p>将web项目直接放到tomcat的webapps目录下，tomcat会根据文件夹名称自动生成虚拟路径。<br>这种方式在开发中经常用到，一般有集成开发工具自动帮助我们将项目发布到webapps目录下。</p>
</li>
<li><p>在conf目录下创建Catalina目录，在此目录下新建localhost目录在localhost目录下新建xx.xml(建议xml的名字与项目名对应，当多个项目存在时，方便查找。)该xml基本配置如下：</p>
<pre><code>  &lt;#我是占位符#Context path=&quot;/项目名&quot; docBase=&quot;E:/xxxx/projectName&quot; reloadable=&quot;true&quot; /&gt;

  path:指定访问该Web应用的URL入口。 

  docBase 是项目实际路径，这里一般写一个绝对的磁盘路径，当然也可以写相对路径，
  相对路径是相对于tomcat安装目录的webapps目录的，通常设置虚拟目录的目的
  是将tomcat的安装和项目的保存分开，所以这里建议你使用磁盘绝对路径，并且
  这个磁盘路径不是在tomcat安装目录下。

  workDir 是指Tomcat解析Jsp转换为Java文件，并编译为class存放的文件夹，
  设置在项目文件夹里面，可以避免移植到其他地方首次读取jsp文件需要重新解析

  reloadable 如果这个属性设为true，tomcat服务器在运行状态下会监视在
  WEB-INF/classes和WEB-INF/lib目录下class文件的改动，如果监测到有class
  文件被更新的，服务器会自动重新加载Web应用。
</code></pre>
</li>
<li><p>配置tomcat 安装目录下的conf/server.xml</p>
<pre><code>  &lt;Host name=&quot;loaclhost&quot;&gt;标签里面添加  
  &lt;Context path=&quot;/aaaa&quot; docBase=&quot;C:\AAAA\BBBB&quot; /&gt;  
</code></pre>
</li>
</ul>
<h3 id="eclipse的tomcat插件"><a href="#eclipse的tomcat插件" class="headerlink" title="eclipse的tomcat插件"></a>eclipse的tomcat插件</h3><ul>
<li>插件下载，注意对应版本<blockquote>
<p><a href="http://www.eclipsetotale.com/tomcatPlugin.html">http://www.eclipsetotale.com/tomcatPlugin.html</a></p>
</blockquote>
</li>
</ul>
<h3 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h3><ul>
<li><p>解压安装</p>
<pre><code>  将下载的文件解压，放到eclipse的plugins目录下，再在eclipse的Preferences&gt;tomcat配置即可。
</code></pre>
</li>
</ul>
<h2 id="tomcat的三个端口"><a href="#tomcat的三个端口" class="headerlink" title="tomcat的三个端口"></a>tomcat的三个端口</h2><h3 id="8005"><a href="#8005" class="headerlink" title="8005"></a>8005</h3><ul>
<li><p>8005端口</p>
<pre><code>  &lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;
  
  关闭tomcat通信接口
</code></pre>
</li>
</ul>
<h3 id="8009"><a href="#8009" class="headerlink" title="8009"></a>8009</h3><ul>
<li><p>8009端口</p>
<pre><code>  &lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot;/&gt;
  
  与其他http服务器通信接口，用于http服务器集合
</code></pre>
</li>
</ul>
<h3 id="8080"><a href="#8080" class="headerlink" title="8080"></a>8080</h3><ul>
<li><p>8080端口</p>
<pre><code>  &lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt;
  
  建立http连接 用，如浏览器访问
</code></pre>
</li>
</ul>
<h3 id="同一台服务器多个tomcat"><a href="#同一台服务器多个tomcat" class="headerlink" title="同一台服务器多个tomcat"></a>同一台服务器多个tomcat</h3><ul>
<li>同一台服务器N个tomcat<pre><code>  每个Tomcat需要上门一套端口。
  如果多个Tomcat安装在同一台操作系统上，需要分配N组3个端口，共N*3个不同的端口。
  否则报错：
  java.net.BindException: Address already in use: JVM_Bind
      
  java.lang.Exception: Socket bind failed    
</code></pre>
</li>
</ul>
]]></content>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu命令</title>
    <url>/2017/05/15/ubuntu%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="ubuntu下安装mysql"><a href="#ubuntu下安装mysql" class="headerlink" title="ubuntu下安装mysql"></a>ubuntu下安装mysql</h2><ul>
<li><p>方式一：</p>
<pre><code>  1.sudo apt-get install mysql-server
  切换到root用户执sudo命令
  2.apt-get isntall mysql-client
  3.sudo apt-get install libmysqlclient-dev
</code></pre>
</li>
</ul>
<h2 id="文件夹权限修改"><a href="#文件夹权限修改" class="headerlink" title="文件夹权限修改"></a>文件夹权限修改</h2><ul>
<li><p>级联文件夹权限设置为所有用户</p>
<pre><code>  ux@adm-Aspire:/usr/mysoft$ sudo chmod 777 * -R
</code></pre>
</li>
</ul>
<h2 id="对文件夹的操作"><a href="#对文件夹的操作" class="headerlink" title="对文件夹的操作"></a>对文件夹的操作</h2><pre><code>    复制到制定目录
    sudo cp -a demo /usr/mysoft
    
    删除目录
    rm -rf demo
    
    unzip XX-Net-2.0.5.zip  
    
    重命名文件夹
    mv oldfileName newName
    
    解压rar文件
    unrar x 记事本.rar
</code></pre>
<h2 id="ubuntu安装JDK"><a href="#ubuntu安装JDK" class="headerlink" title="ubuntu安装JDK"></a>ubuntu安装JDK</h2><ul>
<li>安装步骤：<pre><code>  sudo mkdir /usr/lib/java8
  
  cd Downloads
  sudo tar zxvf jdk-8u111-linux-x64.tar.gz -C/usr/lib/java8
  
  cd /usr/lib/java8
  
  
  sudo gedit ~/.bashrc
  vi ~/.bashrc
  
  #set oracle jdk environment
  export JAVA_HOME=/usr/lib/java8/jdk1.8.0_111
  export JRE_HOME=$&#123;JAVA_HOME&#125;/jre
  export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib
  export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH
  
  source ~/.bashrc
  
  java -version
  
  http://jingyan.baidu.com/article/ad310e80ae6d971849f49ed3.html
  
  im-config
  
  Yes
  
  修改上面的ibus为fcitx.
  后重启电脑
  
  在终端中输入：fcitx-config-gtk3出现对话框如下
  
  sudo tar zxvf ideaIU-2016.2.5-no-jdk.tar.gz -C/usr/mysoft
</code></pre>
</li>
</ul>
<h2 id="安装IDEA"><a href="#安装IDEA" class="headerlink" title="安装IDEA"></a>安装IDEA</h2><pre><code>    ux@adm-Aspire:/usr$ cd /usr/mysoft/idea-IU-162.2228.15/bin
    ux@adm-Aspire:/usr/mysoft/idea-IU-162.2228.15/bin$ ls
    appletviewer.policy  idea64.vmoptions  idea.vmoptions    libyjpagent-linux64.so
    fsnotifier           idea.png          inspect.sh        libyjpagent-linux.so
    fsnotifier64         idea.properties   libbreakgen64.so  log.xml
    fsnotifier-arm       idea.sh           libbreakgen.so
    ux@adm-Aspire:/usr/mysoft/idea-IU-162.2228.15/bin$ ./idea.sh
    
</code></pre>
<h2 id="sudo无法解析主机名"><a href="#sudo无法解析主机名" class="headerlink" title="sudo无法解析主机名"></a>sudo无法解析主机名</h2><ul>
<li>解决方式：<pre><code>  解决方案
  sudo gedit /etc/hosts
</code></pre>
</li>
</ul>
<h2 id="电源管理"><a href="#电源管理" class="headerlink" title="电源管理"></a>电源管理</h2><ul>
<li><p>安装电源管理工具并配置</p>
<pre><code>  $ sudo apt-get install laptop-mode-tools
  
  gksu lmt-config-gui
</code></pre>
</li>
</ul>
]]></content>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu系统安装</title>
    <url>/2017/05/15/ubuntu%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h2><ul>
<li><p>所需材料：</p>
<pre><code>  ubuntu系统镜像
  制作ubuntu安装盘的工具
  windows下修改磁盘的工具
</code></pre>
</li>
<li><p>ubuntu系统镜像下载地址为:</p>
<blockquote>
<p><a href="http://cn.ubuntu.com/download/">http://cn.ubuntu.com/download/</a></p>
</blockquote>
</li>
<li><p>制作ubuntu安装盘的工具我们选择比较便捷的工具<br>Universal-USB-Installer.exe</p>
</li>
<li><p>windows下修改磁盘的工具，有多种选择，这里选择windows的装机工具大白菜或者用分区助手</p>
<blockquote>
<p><a href="http://bd.dabaicai.biz/">http://bd.dabaicai.biz/</a></p>
</blockquote>
</li>
</ul>
<h2 id="2-划分一块空间作为ubuntu的系统盘"><a href="#2-划分一块空间作为ubuntu的系统盘" class="headerlink" title="2.划分一块空间作为ubuntu的系统盘"></a>2.划分一块空间作为ubuntu的系统盘</h2><ul>
<li><p>先用windows下修改磁盘的工具进pe</p>
</li>
<li><p>找到磁盘管理软件（桌面有快捷图标），划分一个盘符，并将其设定为系统分区，是系统分区，不是逻辑分区。注意记住划分的盘符大小，后面有点儿用。—后面第四步：开始安装ubuntu系统会用到。（我是这么做的）</p>
<p>  或者直接选择一块盘符，删除分区试试，不进行格式化等操作了。（没实验，但原理上应该可行）</p>
</li>
</ul>
<h2 id="3-制作ubuntu安装盘"><a href="#3-制作ubuntu安装盘" class="headerlink" title="3.制作ubuntu安装盘"></a>3.制作ubuntu安装盘</h2><ul>
<li><p>制作ubuntu安装盘</p>
<p>  将U盘插入电脑usb接口，运行Universal-USB-Installer.exe，操作如下图所示<br>  <img src="http://op05inpyd.bkt.clouddn.com/ubuntu%E5%AE%89%E8%A3%85.png"><br>  选完这三项后，点击 Creat，耐心等待即可。</p>
</li>
</ul>
<h2 id="4-开始安装ubuntu系统"><a href="#4-开始安装ubuntu系统" class="headerlink" title="4.开始安装ubuntu系统"></a>4.开始安装ubuntu系统</h2><ul>
<li><p>安装ubuntu</p>
<p>  重启电脑，进入BIOS，将U盘设置为第一启动项，保存，退出，此时电脑会重启，进入ubuntu安装界面，<br>  选这第二项，安装ubuntu,然后根据提示，一步步作，<br>  在有一步中ubuntu会识别到你的windows系统，</p>
<p>  这一步选择其他/other,然后，然后选择你第二步第3条中创建的磁盘空间，</p>
<p>  双击，选择大小（不要占满你所创建的空间），选择挂载点为  /<br>  然后，再在剩余的空间上创建 交换空间 即swap,选择2GB或其他都行，看容量。<br>  最后，建议留一点空间以后备用，这个空间此时暂时不再划分。</p>
<p>  做完上述操作后，点击执行即可，等待系统安装完成。</p>
<p>  安装完成后可能出现无法连接wifi的情况，原因是没有无线网卡驱动，建议找个有线网络先联网，或者手机开热点用蓝牙分享热点给电脑用，然后在电脑的 系统设置》软件和更新》附加驱动里，选择无线网卡驱动即可。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>ubuntu系统安装</tag>
      </tags>
  </entry>
  <entry>
    <title>vue</title>
    <url>/2019/03/13/vue/</url>
    <content><![CDATA[<h2 id="vue基础知识"><a href="#vue基础知识" class="headerlink" title="vue基础知识"></a>vue基础知识</h2><ul>
<li><p>vue脚手架基础知识</p>
<p>  <img src="/2019/03/13/vue/vue%E8%84%9A%E6%89%8B%E6%9E%B6.png" alt="vue"></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>websocket</title>
    <url>/2018/05/22/websocket/</url>
    <content><![CDATA[<h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2>]]></content>
      <tags>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title>apache+tomcat实现负载均衡https</title>
    <url>/2017/10/12/windows%E4%B8%8Bapache+tomcat%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1https/</url>
    <content><![CDATA[<h2 id="apache2-4-tomcat6实现负载均衡（windows版本）"><a href="#apache2-4-tomcat6实现负载均衡（windows版本）" class="headerlink" title="apache2.4+tomcat6实现负载均衡（windows版本）"></a>apache2.4+tomcat6实现负载均衡（windows版本）</h2><h3 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h3><ul>
<li><p>apache2.4下载</p>
<blockquote>
<p><a href="http://httpd.apache.org/download.cgi">http://httpd.apache.org/download.cgi</a><br>找到Files for Microsoft Windows找到Apache Lounge，先下载安装vc_redist_x64 or vc_redist_x86<br>再下载httpd-2.4.28-Win64-VC15.zip 或httpd-2.4.28-Win32-VC15.zip </p>
</blockquote>
</li>
<li><p>tomcat6/7下载</p>
<p>  <strong>tomcat6</strong></p>
<blockquote>
<p><a href="http://archive.apache.org/dist/tomcat/tomcat-6/v6.0.29/bin/">http://archive.apache.org/dist/tomcat/tomcat-6/v6.0.29/bin/</a><br>  下载apache-tomcat-6.0.29-windows-x64.zip</p>
</blockquote>
<p>  <strong>tomcat7</strong></p>
<blockquote>
<p><a href="https://tomcat.apache.org/download-70.cgi">https://tomcat.apache.org/download-70.cgi</a><br>  下载7.0.82 64-bit Windows zip (pgp, md5, sha1)</p>
</blockquote>
</li>
</ul>
<h3 id="创建工作目录"><a href="#创建工作目录" class="headerlink" title="创建工作目录"></a>创建工作目录</h3><ul>
<li><p>创建目录结构</p>
<p>  D盘建立文件夹Apache24和tomcats</p>
<p>  tomcats下分别建tomcat1和tomcat2文件夹</p>
</li>
</ul>
<h3 id="安装apache2-4"><a href="#安装apache2-4" class="headerlink" title="安装apache2.4"></a>安装apache2.4</h3><ul>
<li><p>解压httpd-2.4.28-Win64-VC15.zip放置到Apache24下</p>
</li>
<li><p>打开Apache24\conf\httpd.conf</p>
<pre><code>  搜索并替换全部c:/Apache24为d:/Apache24
</code></pre>
</li>
<li><p>安装apache2.4</p>
<pre><code>  cmd管理员下执行 cd D:\Apache24\bin

  httpd.exe -k install -n apache2.4

  卸载命令是sc delete apache2.4 
</code></pre>
<p>  安装完成，执行Apache24\bin\ApacheMonitor.exe，右键&gt;start，启动apache2.4,浏览器输入localhost出现 it works! 则表明apache正常运行。</p>
</li>
</ul>
<h2 id="安装tomcat6"><a href="#安装tomcat6" class="headerlink" title="安装tomcat6"></a>安装tomcat6</h2><ul>
<li><p>将tomcat6解压并复制到tomcat1和tomcat2两个文件夹中（两个文件夹中的tomcat是一样的）</p>
<pre><code>  依次打开tomcat/bin/startup.bat,浏览器地址栏输入localhost:8080,出现tomcat界面，则表明tomcat正常运行。
</code></pre>
</li>
</ul>
<h2 id="Apache2-4和tomcat负载均衡配置"><a href="#Apache2-4和tomcat负载均衡配置" class="headerlink" title="Apache2.4和tomcat负载均衡配置"></a>Apache2.4和tomcat负载均衡配置</h2><ul>
<li><p>配置Apache24\conf\httpd.conf</p>
</li>
<li><p>去掉以下7个模块前的#注释：</p>
<pre><code>  LoadModule proxy_module modules/mod_proxy.so
  LoadModule proxy_ajp_module modules/mod_proxy_ajp.so
  LoadModule proxy_balancer_module modules/mod_proxy_balancer.so
  LoadModule proxy_http_module modules/mod_proxy_http.so
  LoadModule slotmem_shm_module modules/mod_slotmem_shm.so
  LoadModule socache_shmcb_module modules/mod_socache_shmcb.so
  LoadModule lbmethod_byrequests_module modules/mod_lbmethod_byrequests.so

  ---------------------------------------------------------------------
  找到(279行)：
  &lt;IfModule dir_module&gt;
      DirectoryIndex index.html
  &lt;/IfModule&gt;

  修改成
  &lt;IfModule dir_module&gt;
      DirectoryIndex index.html index.jsp
  &lt;/IfModule&gt;

  ----------------------------------------------------------------------
  
  文件最后添加(稍后tomcat里会做相关配置192.168.202在这里是本机ip，所以也可以写成127.0.0.1)：
  #ProxyRequests Off
  &lt;proxy balancer://cluster&gt;
  BalancerMember ajp://192.168.202.1:8011 loadfactor=1 route=tomcat1
  BalancerMember ajp://192.168.202.1:8012 loadfactor=1 route=tomcat2
  &lt;/proxy&gt;
  
  ------------------------------------------------------------------------
  
  # Virtual hosts
  #Include conf/extra/httpd-vhosts.conf
  改为
  # Virtual hosts
  Include conf/extra/httpd-vhosts.conf
</code></pre>
</li>
<li><p>httpd-vhosts.conf设置</p>
</li>
<li><p>打开Apache24\conf\extra\httpd-vhosts.conf（请提前做好备份，以便配置错误时可以恢复）</p>
<pre><code>  注释掉原有的&lt;VirtualHost *:80&gt;&lt;/VirtualHost&gt;两个代码块。

  添加

  &lt;VirtualHost *:80&gt;
      ServerAdmin webmaster@aa.com
      ServerName www.aa.com
      ServerAlias www.aa.com
      ProxyPass / balancer://cluster/ stickysession=JSESSIONID|jsessionid nofailover=On
      ProxyPassReverse / balancer://cluster/
  &lt;/VirtualHost&gt;

  ServerName www.aa.com可以通过修改windows的host文件来伪装。
  host文件位置：
  C:\Windows\System32\drivers\etc\host
  最后面添加    127.0.0.1       www.aa.com
</code></pre>
</li>
</ul>
<h2 id="配置tomcat1和tomcat2"><a href="#配置tomcat1和tomcat2" class="headerlink" title="配置tomcat1和tomcat2"></a>配置tomcat1和tomcat2</h2><ul>
<li><p>打开tomcat server.xml</p>
<pre><code>  tomcats\tomcat1\conf\server.xml

  找到&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;
  将tomcat1的port改为8006，tomcat的port改为8007

  --------------------------------------------------
  找到：
  
  &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; 
     connectionTimeout=&quot;20000&quot; 
     redirectPort=&quot;8443&quot; /&gt;

  将8080改为8081，tomcat2的改为8082

  -------------------------------------------------------
  
  找到

  &lt;Connector port=&quot;8011&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;

  将8009改为8011，tomcat2的改为8012

  (和apache中配置的对应：
  BalancerMember ajp://192.168.202.1:8011 loadfactor=1 route=tomcat1
  BalancerMember ajp://192.168.202.1:8012 loadfactor=1 route=tomcat2
  )

  -----------------------------------------------------------

  找到：

  &lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt;

  改为：

  &lt;Engine name=&quot;Standalone&quot; defaultHost=&quot;localhost&quot; jvmRoute=&quot;tomcat1&quot;&gt;

  tomcat2中的改为：

  &lt;Engine name=&quot;Standalone&quot; defaultHost=&quot;localhost&quot; jvmRoute=&quot;tomcat2&quot;&gt;

  这里同样时和
  BalancerMember ajp://192.168.202.1:8011 loadfactor=1 route=tomcat1
  BalancerMember ajp://192.168.202.1:8012 loadfactor=1 route=tomcat2
  对应的。

  -----------------------------------------------------------------

  找到

  &lt;!--
  &lt;Cluster className=&quot;org.apache.catalina.ha.tcp.SimpleTcpCluster&quot;/&gt;
  --&gt;  

  在其下方添加

  &lt;Cluster className=&quot;org.apache.catalina.ha.tcp.SimpleTcpCluster&quot;  channelSendOptions=&quot;6&quot;&gt;
  &lt;Manager className=&quot;org.apache.catalina.ha.session.BackupManager&quot;
           expireSessionsOnShutdown=&quot;false&quot;
           notifyListenersOnReplication=&quot;true&quot;
           mapSendOptions=&quot;6&quot;/&gt;
  &lt;Channel className=&quot;org.apache.catalina.tribes.group.GroupChannel&quot;&gt;
      &lt;Membership className=&quot;org.apache.catalina.tribes.membership.McastService&quot;
          address=&quot;228.0.0.4&quot;
          port=&quot;45564&quot;
          frequency=&quot;500&quot;
          dropTime=&quot;3000&quot;/&gt;
      &lt;Receiver className=&quot;org.apache.catalina.tribes.transport.nio.NioReceiver&quot;
          address=&quot;auto&quot;
          port=&quot;5001&quot;
          selectorTimeout=&quot;100&quot;
          maxThreads=&quot;6&quot;/&gt;
      &lt;Sender className=&quot;org.apache.catalina.tribes.transport.ReplicationTransmitter&quot;&gt;
          &lt;Transport className=&quot;org.apache.catalina.tribes.transport.nio.PooledParallelSender&quot;/&gt;
      &lt;/Sender&gt;
      &lt;Interceptor className=&quot;org.apache.catalina.tribes.group.interceptors.TcpFailureDetector&quot;/&gt;
      &lt;Interceptor className=&quot;org.apache.catalina.tribes.group.interceptors.MessageDispatch15Interceptor&quot;/&gt;
      &lt;Interceptor className=&quot;org.apache.catalina.tribes.group.interceptors.ThroughputInterceptor&quot;/&gt;
  &lt;/Channel&gt;

  &lt;Valve className=&quot;org.apache.catalina.ha.tcp.ReplicationValve&quot;
      filter=&quot;.*/.gif;.*/.js;.*/.jpg;.*/.png;.*/.htm;.*/.html;.*/.css;.*/.txt;&quot;/&gt;
      &lt;ClusterListener className=&quot;org.apache.catalina.ha.session.ClusterSessionListener&quot;/&gt;
  &lt;/Cluster&gt;

  注意：tomcat2中的port=&quot;5001&quot;应该为5002
</code></pre>
</li>
<li><p>测试</p>
<p>  至此，apache2.4和tomcat的负载均衡配置完毕。</p>
<p>  测试：</p>
<p>  将test_war.war放到tomcat1和tomcat2的webapps目录下，启动apache,再启动tomcat1和tomcat2,浏览器输入localhost/test_war/index.jsp,观察两个tomcat命令框的输出文字，会发现，浏览器多次访问，则由两个tomcat接替处理。</p>
</li>
</ul>
<h2 id="HTTPS的配置"><a href="#HTTPS的配置" class="headerlink" title="HTTPS的配置"></a>HTTPS的配置</h2><p>上面已经配置并测试了apache2.4和tomcat的负载均衡，下面将继续配置https</p>
<ul>
<li><p>打开apache2.4的配置文件</p>
<pre><code>  找到
  #LoadModule ssl_module modules/mod_ssl.so

  将其前面的注释#去掉，改为：
  #LoadModule ssl_module modules/mod_ssl.so

  ------------------------------------------------

  找到
  # Secure (SSL/TLS) connections
  #Include conf/extra/httpd-ssl.conf

  改为

  # Secure (SSL/TLS) connections
  Include conf/extra/httpd-ssl.conf
</code></pre>
</li>
<li><p>打开Apache24\conf\extra\httpd-ssl.conf</p>
<pre><code>  找到

  &lt;VirtualHost _default_:443&gt;

  添加

  ProxyPass / balancer://cluster/ stickysession=JSESSIONID|jsessionid nofailover=On
  ProxyPassReverse / balancer://cluster/

  变成

  &lt;VirtualHost _default_:443&gt;
  #   General setup for the virtual host
  DocumentRoot &quot;d:/Apache24/htdocs&quot;
  ServerName localhost:443
  ServerAdmin admin@example.com
  ErrorLog &quot;d:/Apache24/logs/error.log&quot;
  TransferLog &quot;d:/Apache24/logs/access.log&quot;
  ProxyPass / balancer://cluster/ stickysession=JSESSIONID|jsessionid nofailover=On
  ProxyPassReverse / balancer://cluster/

  -------------------------------------------------------

  将证书复制到apache\conf下
  server.crt
  server.csr
  server.key
</code></pre>
</li>
<li><p>启动apache2.4,依次启动tomcat1和tomcat2,浏览器输入<a href="https://localhost/test_war/index.jsp%E5%8F%91%E7%8E%B0https%E8%AE%BF%E9%97%AE%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E3%80%82">https://localhost/test_war/index.jsp发现https访问可以进行。</a></p>
</li>
</ul>
<h2 id="https证书获取方式"><a href="#https证书获取方式" class="headerlink" title="https证书获取方式"></a>https证书获取方式</h2><ul>
<li><p>自制证书</p>
<p>  待续…</p>
</li>
<li><p>申请证书</p>
<p>  待续…</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>负载均衡1</tag>
      </tags>
  </entry>
  <entry>
    <title>windows下discuz论坛</title>
    <url>/2017/12/26/windows%E4%B8%8Bdiscuz%E8%AE%BA%E5%9D%9B/</url>
    <content><![CDATA[<h2 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h2><ul>
<li><p>discuz产品包</p>
<p>  下载地址(utf-8版)</p>
<blockquote>
<p><a href="http://www.comsenz.com/downloads/install/discuzx">http://www.comsenz.com/downloads/install/discuzx</a></p>
</blockquote>
</li>
<li><p>Windows下PHP集成环境XAMPP</p>
<blockquote>
<p><a href="http://rj.baidu.com/soft/detail/25759.html?ald">http://rj.baidu.com/soft/detail/25759.html?ald</a></p>
</blockquote>
</li>
<li><p>MySQL</p>
<blockquote>
<p>链接:<a href="https://pan.baidu.com/s/1kVcjybd">https://pan.baidu.com/s/1kVcjybd</a>  密码:eura</p>
</blockquote>
</li>
<li><p>163邮箱</p>
<p>  注册163邮箱，开启SMTP服务。</p>
</li>
</ul>
<h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><ul>
<li><p>部署</p>
<p>  安装完mysql和XAMPP后，将下载好的Discuz_X3.2_SC_UTF8.zip解压，将解压后的upload文件夹改名为bbs或其它想要的命名，并拷贝到xampp安装目录下的htdocs文件夹下，如</p>
<p>  C:\xampp\htdocs</p>
<p>  运行xampp-control.exe，启动mysql和apache服务，<br>  浏览器访问localhost/bbs,进行论坛的初始化工作（设置数据库连接，数据表的命名规则，以及论坛管理员的账号信息）</p>
</li>
<li><p>邮件服务(用于用户邮箱验证以及找回密码)</p>
<p>  以管理员账号登录论坛，点击管理中心，选择站长&gt;邮件设置</p>
<p>  1.邮件发送方式选择SOCKET连接SMTP服务器<br>  2.添加SMTP服务器:</p>
<pre><code>  SMTP服务器：smtp.163.com    
  端口：25
  验证：勾选
  发信人邮件地址：m173371@163.com
  SMTP身份验证用户名：m173371@163.com
  SMTP身份验证密码：m173371@163.com邮箱的密码
  
</code></pre>
<p>  3.邮件头的分隔符</p>
<pre><code>  选择：使用LF作为分隔符（通常为Unix/Linux主机）
  
</code></pre>
<p>  4.收件人地址…和屏蔽邮件…选是或否（这里选是）</p>
<p>  5.提交</p>
<p>  6.选择检测按钮，进行邮件发送检测：</p>
<pre><code>  测试发件人：m173371@163.com
  
  测试收件人：9036。。。@qq.com
  
  点击建设邮件发送设置按钮，如果邮件正常接收，这表示设置OK.
</code></pre>
</li>
</ul>
<h2 id="discuz首页logo去除"><a href="#discuz首页logo去除" class="headerlink" title="discuz首页logo去除"></a>discuz首页logo去除</h2><ul>
<li><p>后台管理中去除图片引用（可以不进行这一步操作，直接进行下一步修改源码操作也能达到目的）</p>
<pre><code>  后台管理中心&gt;界面&gt;风格管理&gt;编辑&gt;站点logo&gt;logo.png
  
</code></pre>
</li>
<li><p>代码中去除图片显示</p>
<pre><code>  bbs\template\default\common\header.htm 
  找到125行，即h2标签中的内容：
  
      &lt;div class=&quot;hdc cl&quot;&gt;
          &lt;!--&#123;eval $mnid = getcurrentnav();&#125;--&gt;
          &lt;h2&gt;&lt;!--&#123;if !isset($_G[&#39;setting&#39;][&#39;navlogos&#39;][$mnid])&#125;--&gt;&lt;a href=&quot;&#123;if $_G[&#39;setting&#39;][&#39;domain&#39;][&#39;app&#39;][&#39;default&#39;]&#125;http://&#123;$_G[&#39;setting&#39;][&#39;domain&#39;][&#39;app&#39;][&#39;default&#39;]&#125;/&#123;else&#125;./&#123;/if&#125;&quot; title=&quot;$_G[&#39;setting&#39;][&#39;bbname&#39;]&quot;&gt;&#123;$_G[&#39;style&#39;][&#39;boardlogo&#39;]&#125;&lt;/a&gt;&lt;!--&#123;else&#125;--&gt;$_G[&#39;setting&#39;][&#39;navlogos&#39;][$mnid]&lt;!--&#123;/if&#125;--&gt;&lt;/h2&gt;
          &lt;!--&#123;template common/header_userstatus&#125;--&gt;
      &lt;/div&gt;
      
      注释掉这一句：
      &#123;$_G[&#39;style&#39;][&#39;boardlogo&#39;]&#125;
</code></pre>
</li>
</ul>
<h2 id="底部信息去掉"><a href="#底部信息去掉" class="headerlink" title="底部信息去掉"></a>底部信息去掉</h2><ul>
<li><p>去掉页面底部全部信息</p>
<pre><code>      找到bbs\template\default\common\footer.htm
      找到&lt;div id=&quot;ft&quot; class=&quot;wp cl&quot;&gt;（第87行）
      
      删除&lt;div id=&quot;ft&quot; class=&quot;wp cl&quot;&gt;中的如下两个标签中的内容：
      &lt;div id=&quot;frt&quot;&gt;&lt;/div&gt;
      &lt;p&gt;&lt;/p&gt;
</code></pre>
</li>
</ul>
<h2 id="页签title去除"><a href="#页签title去除" class="headerlink" title="页签title去除"></a>页签title去除</h2><ul>
<li><p>去除页签title</p>
<pre><code>      bbs\template\default\common\header_common.htm
      
      搜索Powered by Discuz（或者直接在第6行找）
      
</code></pre>
</li>
</ul>
<h2 id="右下角其它信息去除"><a href="#右下角其它信息去除" class="headerlink" title="右下角其它信息去除"></a>右下角其它信息去除</h2><ul>
<li><p>去除右下角其它信息</p>
<pre><code>  搜索&lt;div id=&quot;ft&quot; class=&quot;wp cl&quot;&gt;(57行)
  找到&lt;div id=&quot;ft&quot; class=&quot;wp cl&quot;&gt;中的下面这个span标签：
  &lt;span id=&quot;debuginfo&quot;&gt;
  删除&lt;span id=&quot;debuginfo&quot;&gt;标签中的下面这段代码：
  , Processed in $_G[debuginfo][time] second(s), $_G[debuginfo][queries] queries
</code></pre>
</li>
</ul>
<h2 id="用户头像调用方式"><a href="#用户头像调用方式" class="headerlink" title="用户头像调用方式"></a>用户头像调用方式</h2><ul>
<li>头像加载方式<br>  后台&gt;站长&gt;UCenter设置&gt;头像调用方式<pre><code>  使用动态地址调用头像
  使用静态地址调用头像
</code></pre>
</li>
</ul>
<h2 id="用户密码长度设置"><a href="#用户密码长度设置" class="headerlink" title="用户密码长度设置"></a>用户密码长度设置</h2><ul>
<li><p>后台&gt;全局&gt;注册与访问控制</p>
<pre><code>  找到：
  密码最小长度
  修改为自定义长度即可。
  
</code></pre>
</li>
<li><p>或者在代码中修改(太麻烦，不好找)</p>
<p>  1.打开static/js/register.js<br>  搜索(297行)：</p>
<pre><code>  function checkpassword(id1, id2) &#123;
  中的
  if($(id1).value.length &lt; pwlength) 
  
  pwlength就是密码长度
  
</code></pre>
<p>  2….找不到…</p>
</li>
<li><p>通过数据库表改密码长度</p>
<pre><code>  表：pre_common_setting
  字段值：pwlength    
  select * from pre_common_setting where skey = &#39;pwlength&#39;;
</code></pre>
</li>
</ul>
<h2 id="discuz更新缓存"><a href="#discuz更新缓存" class="headerlink" title="discuz更新缓存"></a>discuz更新缓存</h2><ul>
<li><p>更新缓存（解决配置信息更新等）    </p>
<p>  后台&gt;工具&gt;更新缓存</p>
</li>
</ul>
<h2 id="修改用户名长度"><a href="#修改用户名长度" class="headerlink" title="修改用户名长度"></a>修改用户名长度</h2><ul>
<li><p>修改注册类和用户名检查提示</p>
<ul>
<li><p>打开 /source/class/class_member.php 文件</p>
<pre><code>  $usernamelen = dstrlen($username);  
  if($usernamelen &lt; 3) &#123;  
      showmessage(&#39;profile_username_tooshort&#39;);  
  &#125; elseif($usernamelen &gt; 15) &#123;  
      showmessage(&#39;profile_username_toolong&#39;);  
  &#125; 
   
</code></pre>
</li>
<li><p>打开 /source/module/forum/forum_ajax.php 文件</p>
<pre><code>  if($usernamelen &lt; 3) &#123;  
      showmessage(&#39;profile_username_tooshort&#39;, &#39;&#39;, array(), array(&#39;handle&#39; =&gt; false));  
  &#125; elseif($usernamelen &gt; 15) &#123;  
      showmessage(&#39;profile_username_toolong&#39;, &#39;&#39;, array(), array(&#39;handle&#39; =&gt; false));  
  &#125;
  
</code></pre>
</li>
<li><p>打开文件 uc_client/model/user.php</p>
<pre><code>  function check_username($username) &#123;  
      $guestexp = &#39;\xA1\xA1|\xAC\xA3|^Guest|^\xD3\xCE\xBF\xCD|\xB9\x43\xAB\xC8&#39;;  
      $len = $this-&gt;dstrlen($username);  
      if($len &gt; 15 || $len &lt; 3 || preg_match(&quot;/\s+|^c:\\con\\con|[%,\*\&quot;\s\&lt;\&gt;\&amp;]|$guestexp/is&quot;, $username)) &#123;  
          return FALSE;  
      &#125; else &#123;  
          return TRUE;  
      &#125;  
  &#125;
</code></pre>
</li>
<li><p>打开文件 static/js/register.js</p>
<pre><code>  if(unlen &lt; 3 || unlen &gt; 15) &#123;  
      errormessage(id, unlen &lt; 3 ? &#39;用户名不得小于 3 个字符&#39; : &#39;用户名不得超过 15 个字符&#39;);  
      return;  
  &#125;
  
</code></pre>
</li>
</ul>
</li>
<li><p>修改语言包提示语句</p>
<ul>
<li><p>打开 /source/language/lang_message.php 文件</p>
<pre><code>  &#39;profile_username_toolong&#39; =&gt; &#39;抱歉，您的用户名超过 15 个字符，请输入一个较短的用户名&#39;,
  
</code></pre>
</li>
<li><p>打开 /source/language/mobile/lang_template.php 文件</p>
<pre><code>  &#39;reg_username&#39; =&gt; &#39;用户名必须为大于3位小于15位&#39;,      
  &#39;registerinputtip&#39; =&gt; &#39;用户名：3-15位&#39;,  
  
</code></pre>
</li>
</ul>
</li>
<li><p>参考链接</p>
<blockquote>
<p><a href="http://blog.csdn.net/lih062624/article/details/68940617">http://blog.csdn.net/lih062624/article/details/68940617</a>    </p>
</blockquote>
</li>
</ul>
]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>windows下安装apache2.4</title>
    <url>/2017/12/12/windows%E4%B8%8B%E5%AE%89%E8%A3%85apache2-4/</url>
    <content><![CDATA[<h2 id="Windows下安装apache2-4"><a href="#Windows下安装apache2-4" class="headerlink" title="Windows下安装apache2.4"></a>Windows下安装apache2.4</h2><h3 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h3><ul>
<li>apache2.4下载</li>
</ul>
<blockquote>
<p><a href="http://httpd.apache.org/download.cgi">http://httpd.apache.org/download.cgi</a></p>
</blockquote>
<p>找到Files for Microsoft Windows找到Apache Lounge，</p>
<p>先下载安装vc_redist_x64 or vc_redist_x86</p>
<p>再下载httpd-2.4.28-Win64-VC15.zip 或httpd-2.4.28-Win32-VC15.zip </p>
<h3 id="创建工作目录"><a href="#创建工作目录" class="headerlink" title="创建工作目录"></a>创建工作目录</h3><ul>
<li><p>创建目录结构</p>
<p>  D盘建立文件夹Apache24</p>
</li>
</ul>
<h3 id="安装apache2-4"><a href="#安装apache2-4" class="headerlink" title="安装apache2.4"></a>安装apache2.4</h3><ul>
<li><p>解压httpd-2.4.28-Win64-VC15.zip放置到Apache24下</p>
</li>
<li><p>打开Apache24\conf\httpd.conf</p>
<pre><code>  搜索并替换全部c:/Apache24为d:/Apache24
</code></pre>
</li>
<li><p>安装apache2.4</p>
<pre><code>  cmd管理员下执行 cd D:\Apache24\bin

  httpd.exe -k install -n apache2.4

  卸载命令是sc delete apache2.4 
</code></pre>
<p>  安装完成，执行Apache24\bin\ApacheMonitor.exe，右键&gt;start，启动apache2.4,浏览器输入localhost出现 it works! 则表明apache正常运行。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>apache2.4</tag>
      </tags>
  </entry>
  <entry>
    <title>windows下安装weblogic</title>
    <url>/2017/11/28/windows%E4%B8%8B%E5%AE%89%E8%A3%85weblogic/</url>
    <content><![CDATA[<h2 id="下载weblogic安装包"><a href="#下载weblogic安装包" class="headerlink" title="下载weblogic安装包"></a>下载weblogic安装包</h2><ul>
<li><p>下载地址</p>
<blockquote>
<p><a href="http://www.oracle.com/technetwork/cn/middleware/ias/downloads/wls-main-091116-zhs.html">http://www.oracle.com/technetwork/cn/middleware/ias/downloads/wls-main-091116-zhs.html</a></p>
</blockquote>
<pre><code>  本例以下载安装 Oracle WebLogic Server 10.3.6  通用 (997 MB)包为例。
</code></pre>
</li>
</ul>
<h2 id="安装jdk"><a href="#安装jdk" class="headerlink" title="安装jdk"></a>安装jdk</h2><ul>
<li><p>安装jdk</p>
<pre><code>  安装weblogic前需要先安装JDK，本次以jdk1.7，64位版本为例子。
</code></pre>
</li>
</ul>
<h2 id="安装weblogic"><a href="#安装weblogic" class="headerlink" title="安装weblogic"></a>安装weblogic</h2><ul>
<li><p>开始安装weblogic</p>
<pre><code>  将wls1036_generic.jar复制到jdk安装路径的bin目录下
  如：C:\mysoft\Java7x64\jdk1.7.0_80\bin
  
  然后打开cmd(管理员权限)，cd C:\mysoft\Java7x64\jdk1.7.0_80\bin
  然后执行命令：
  
  Java -jar wls1036_generic.jar
  
  等待weblogic界面的出现，一步步安装即可。
</code></pre>
</li>
</ul>
<h2 id="部署程序"><a href="#部署程序" class="headerlink" title="部署程序"></a>部署程序</h2><ul>
<li><p>部署应用程序</p>
<pre><code>  运行weblogic服务，打开console,登录weblogic服务，选择 部署&gt;安装&gt;选择要部署的程序包，完成，即可。weblogic默认端口7001。
  
  （注：该部署方式是路径引用）
</code></pre>
</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><p>参考链接</p>
<blockquote>
<p><a href="https://jingyan.baidu.com/article/59a015e3568379f795886567.html">https://jingyan.baidu.com/article/59a015e3568379f795886567.html</a></p>
</blockquote>
</li>
<li><p>Apache配置weblogic模块相关</p>
<blockquote>
<p><a href="https://docs.oracle.com/cd/E21764_01/web.1111/e16435/apache.htm#PLGWL407">https://docs.oracle.com/cd/E21764_01/web.1111/e16435/apache.htm#PLGWL407</a></p>
</blockquote>
</li>
</ul>
<h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><ul>
<li><p>weblogic wls1036_generic.jar包 网盘链接</p>
<pre><code>  链接:https://pan.baidu.com/s/1bINsAi  密码:bwfx

  

  
</code></pre>
</li>
</ul>
]]></content>
      <tags>
        <tag>windows下安装weblogic</tag>
      </tags>
  </entry>
  <entry>
    <title>windows下的多版本JDK切换配置</title>
    <url>/2017/04/26/windows%E4%B8%8B%E7%9A%84%E5%A4%9A%E7%89%88%E6%9C%ACJDK%E5%88%87%E6%8D%A2%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="windows下多JDK安装"><a href="#windows下多JDK安装" class="headerlink" title="windows下多JDK安装"></a>windows下多JDK安装</h2><h3 id="系统下仅安装有一个JDK时"><a href="#系统下仅安装有一个JDK时" class="headerlink" title="系统下仅安装有一个JDK时"></a>系统下仅安装有一个JDK时</h3><pre><code>C:\Program Files\Java\jdk1.6.0_22\lib;.  CLASSPATH
C:\Program Files\Java\jdk1.6.0_21\bin;  PATH
C:\Program Files\Java\jdk1.6.0_21  JAVA_HOME
</code></pre>
<h3 id="同一系统中存在多个JDK版本时"><a href="#同一系统中存在多个JDK版本时" class="headerlink" title="同一系统中存在多个JDK版本时"></a>同一系统中存在多个JDK版本时</h3><p>由于实际需要，可能在我们的PC中安装有多个版本的JDK，并在需要是随时切换版本，考虑到切换版本时需要更改环境变量配置，因此我们可以这样做：</p>
<ul>
<li><p>我的电脑(windows10企业版)下同时安装有jdk1.8.0_102和jdk1.6.0_43两个版本(分别在不同的目录文件夹下)</p>
</li>
<li><p>首先，配置两个 <strong>子JAVA_HOME</strong> </p>
<pre><code>  JAVA_HOME8
  
  C:\mysoft\Java\jdk1.8.0_102
  
  JAVA_HOME6
  
  C:\mysoft\Java6\jdk1.6.0_43
</code></pre>
</li>
<li><p>然后，配置一个 <strong>JAVA_HOME</strong> 并引用上面配置的 <strong>子JAVA_HOME</strong> 中的一个</p>
<pre><code>  JAVA_HOME
  
  %JAVA_HOME6%
</code></pre>
</li>
<li><p>PATH和CLASSPATH环境变量配置</p>
<pre><code>  CLASSPATH
  %JAVA_HOME%\lib;.

  PATH
  %JAVA_HOME%\bin;

  可选：PATH下：%JAVA_HOME%\jre\bin;
</code></pre>
</li>
</ul>
<p><strong>仅仅做到上面的几步是不够的</strong></p>
<p>上述步骤完成后，有可能会发下，dos命令下<br>java -vrsion和javac -version的版本不一致，因为在path变量中，会先加载C:\Windows\System32下的java.exe,如下如：</p>
<p><img src="http://op05inpyd.bkt.clouddn.com/jdk_1.png"><br><img src="http://op05inpyd.bkt.clouddn.com/jdk_2.png"></p>
<p>windows/System32下的java.exe</p>
<p><img src="http://op05inpyd.bkt.clouddn.com/jdk_3.png"></p>
<p>所以，需要将PATH变量中的%JAVA_HOME%\bin;放在Oracle默认变量之前。<br>至此，每当需要切换JDK版本时，只需要改 <strong>JAVA_HOME</strong> 中所引用的 <strong>子JAVA_HOME名称</strong> 即可。</p>
]]></content>
      <tags>
        <tag>JDK</tag>
      </tags>
  </entry>
  <entry>
    <title>wx小商城</title>
    <url>/2019/03/11/wx%E5%B0%8F%E5%95%86%E5%9F%8E/</url>
    <content><![CDATA[<h2 id="部署简记"><a href="#部署简记" class="headerlink" title="部署简记"></a>部署简记</h2><h2 id="关于本机开发调试"><a href="#关于本机开发调试" class="headerlink" title="关于本机开发调试"></a>关于本机开发调试</h2><p>1.jar的打包</p>
<pre><code>使用maven的package即可，在litemall-master/litemall-all/target下生成一个litemall-all-0.1.0-exec.jar文件，使用下面命令即可将litemall-all-*-exec.jar拷贝到deploy文件夹下，并重命名为litemall.jar

cp -f ./litemall-all/target/litemall-all-*-exec.jar ./deploy/litemall/litemall.jar
</code></pre>
<p>2.前端代码的打包</p>
<pre><code>安装node依赖
cnpm install

启动前端本地开发环境
cnpm run dev

打包前端代码【生产环境prod】
cnpm run build:prod
【打包后会生成一个dist的文件夹，将dist文件夹部署到tomcat即可】
</code></pre>
<h2 id="关于linux上部署"><a href="#关于linux上部署" class="headerlink" title="关于linux上部署"></a>关于linux上部署</h2><h3 id="远程服务器java8和tomcat安装位置"><a href="#远程服务器java8和tomcat安装位置" class="headerlink" title="远程服务器java8和tomcat安装位置"></a>远程服务器java8和tomcat安装位置</h3><p>1.java8安装位置</p>
<pre><code>usr/lib/java8
</code></pre>
<p>2.tomcat9位置    (端口8081)</p>
<pre><code>/root/mysoft/apache-tomcat-9.0.17
    
</code></pre>
<h3 id="启动后端jar命令"><a href="#启动后端jar命令" class="headerlink" title="启动后端jar命令"></a>启动后端jar命令</h3><pre><code>1.只在当前登录用户下有效，用户退出，jar进程终止

java -jar litemall.jar

2.后台运行jar
nohup java -jar litemall.jar    
</code></pre>
<h3 id="启动tomcat命令"><a href="#启动tomcat命令" class="headerlink" title="启动tomcat命令"></a>启动tomcat命令</h3><pre><code>进入到tomcat下的bin执行命令

1.启动：sh start.sh    
2，停止：sh shutdown.sh
</code></pre>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><pre><code>litemall-admin/config/下的
dep.env.js    
dep.env.js    
dep.env.js    
中的BASE_API: &#39;&quot;http://94.191.47.85:8080/admin&quot;&#39;
最好写成域名或ip形式，生产环境不建议写成localhost，因为前后端是分离部署的
</code></pre>
<h2 id="linux上配置开发环境"><a href="#linux上配置开发环境" class="headerlink" title="linux上配置开发环境"></a>linux上配置开发环境</h2><h3 id="后台启动jar-node命令"><a href="#后台启动jar-node命令" class="headerlink" title="后台启动jar/node命令"></a>后台启动jar/node命令</h3><pre><code>nohup java -jar shareniu.jar &amp;
nohup npm run dev &gt; /dev/null &amp;
</code></pre>
<h3 id="查看后代进程"><a href="#查看后代进程" class="headerlink" title="查看后代进程"></a>查看后代进程</h3><pre><code>ps -aux
</code></pre>
<h3 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h3><pre><code>kill -9 进程PID    
</code></pre>
<h3 id="安装nvm，通过nvm安装npm"><a href="#安装nvm，通过nvm安装npm" class="headerlink" title="安装nvm，通过nvm安装npm"></a>安装nvm，通过nvm安装npm</h3><pre><code>curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh | bash

nvm --version

nvm ls-remote

nvm install v6.10.2
</code></pre>
<blockquote>
<p><a href="https://www.cnblogs.com/tgxh/p/6796062.html">https://www.cnblogs.com/tgxh/p/6796062.html</a></p>
</blockquote>
<h3 id="node报错："><a href="#node报错：" class="headerlink" title="node报错："></a>node报错：</h3><pre><code>npm rebuild node-sass
</code></pre>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_37404604/article/details/80202979">https://blog.csdn.net/weixin_37404604/article/details/80202979</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title>关于生活</title>
    <url>/2018/12/12/%E5%85%B3%E4%BA%8E%E7%94%9F%E6%B4%BB/</url>
    <content><![CDATA[<h2 id="关于杭州"><a href="#关于杭州" class="headerlink" title="关于杭州"></a>关于杭州</h2><p>杭州，两年前对于我来说，一个完全陌生的城市，两年后的今天，有期待也有失落。</p>
<p>毕业时的迷茫，是我踏进了杭州这座完全陌生的城市，感受着杭州这座城市的酷热与火辣，同时也怀揣着期待，期待更好的明天。</p>
<p>两年弹指一挥间，生活也渐渐轻松了许多，没有刚毕业时的恐惧与彷徨，但是期待少了许多。</p>
<p>2016年刚踏入这座城市，每天上下班30公路的路程，登着一辆二手山地车坚持了半年，半年后换了一辆二手电动单车，并不觉得多么心酸，因为觉得一切都值得。那大概就是青春的朝气吧。</p>
<p>转眼2018年底了，买了张健身卡，觉得应该为自己的健康负责了，应该提升一下自己了。朝气蓬勃的样子，才有味道。（2018年12月12日.记）</p>
]]></content>
      <tags>
        <tag>关于生活</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式与集群</title>
    <url>/2018/05/21/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h2 id="分布式概念描述"><a href="#分布式概念描述" class="headerlink" title="分布式概念描述"></a>分布式概念描述</h2><ul>
<li><p>概念</p>
<p>  旨在支持应用程序和服务的开发，可以利用物理架构由多个自治的处理元素，不共享主内存，但通过网络发送消息合作。——Leslie Lamport</p>
</li>
<li><pre><code>分布式的三个特点与
</code></pre>
</li>
</ul>
<pre><code>*     多节点                    
*  消息通信
*  不共享内存
</code></pre>
<ul>
<li><p>三个容易混淆的概念</p>
<ul>
<li>分布式系统（distributed ststem）</li>
<li>集群（cluster）</li>
<li>分布式计算（distributed computing）</li>
</ul>
</li>
<li><p>分布式系统是多节点的，集群也是多节点的，但是区别在于节点的功能</p>
<p>  如：卖家端和卖家端是分布式的；</p>
<p>  如果卖家端部署在对台服务器上，那么卖家端是集群；</p>
<p>  <strong>简单说就是 功能不同是分布式，功能相同是集群。</strong></p>
</li>
</ul>
<h2 id="分布式系统与集群的区别"><a href="#分布式系统与集群的区别" class="headerlink" title="分布式系统与集群的区别"></a>分布式系统与集群的区别</h2><ul>
<li><p>区别</p>
<p>  分布式系统强调的是不同的功能模块的节点；<br>  集群是相同业务功能模块的节点；<br>  分布式系统中的每个节点都可以做集群。<br>  集群并不一定是分布式的。</p>
</li>
<li><p>水平扩展</p>
<p>  集群</p>
</li>
<li><p>垂直扩展</p>
<p>  分布式</p>
</li>
</ul>
<h2 id="session理论"><a href="#session理论" class="headerlink" title="session理论"></a>session理论</h2><ul>
<li><p>广义session</p>
<p>  <strong>会话控制：</strong></p>
<p>  http协议是无状态的，对于同一个url请求并没有上下文关系，当用户完成登录后，就要有一个机制保存用户的登录状态和信息，在后续的请求中，能够验证用户的身份和检查用户信息。</p>
<p>  <strong>可以理解为一种保存key-value的机制：</strong></p>
<p>  session机制中的关键点:<br>  1.如何设置和获取key<br>  2.如何保存和正确获取多赢的value</p>
<p>  从key的方面看：</p>
<p>  会话会有两种比较常规的方式，sessionId和token;</p>
<p>  <strong>sessionId:</strong></p>
<p>  客户端请求服务端时，服务端通过setCookie就可以在http头里面设置sessionId这个key和对应的value的值，而客户端的cookie会将它保存住，在后续的请求中，会自动带上。</p>
<p>  <strong>token:</strong></p>
<p>  使用token时，需要手动在http head头里或者url里面设置token这个字段，服务器收到请求后，再从head头里或者url取出token进行验证（对安全要求严格是，会配合签名和token一起使用）。</p>
<p>  无论是session还是token,它们都是全局唯一的，一个用户一个标识。它的本质就是一个key,key对应的value就是用户的信息。无论key还是value,一方没有保持住，我们就无法分别用户身份、获取用户信息。</p>
</li>
</ul>
<h3 id="处理分布式session问题"><a href="#处理分布式session问题" class="headerlink" title="处理分布式session问题"></a>处理分布式session问题</h3><ul>
<li><p>处理分布式session问题</p>
<p>  <strong>session保持不住：</strong></p>
<p>  如浏览器禁用cookie，分布式系统中session问题–多个应用服务器时，持有的用户session没有同步多个服务器。</p>
<p>  此时可以用一个专门的服务去保存用户的session信息，其它服务需要用户的session信息时，都通过这个专门的服务去获取。这个服务通常是用redis集群或者主从复制去做的。当然，微小型项目或者开发测试时，单机版也可以。</p>
<p>  登录时设置好key保存用户信息，登出时让value失效即可。</p>
</li>
<li><p>chrome浏览器下查看cookie：</p>
<p>  command+option+i：</p>
<p>  上方Application&gt;左侧Cookies</p>
</li>
<li><p>狭义session    </p>
<p>  httpsession</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>分布式与集群</tag>
      </tags>
  </entry>
  <entry>
    <title>决胜Spring源码</title>
    <url>/2021/06/05/%E5%89%91%E6%8C%87Java%E8%87%AA%E7%A0%94%E6%A1%86%E6%9E%B6,%E5%86%B3%E8%83%9CSpring%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<h2 id="1-Spring整体架构"><a href="#1-Spring整体架构" class="headerlink" title="1.Spring整体架构"></a>1.Spring整体架构</h2><ul>
<li><p>核心架构：</p>
<blockquote>
<p><img src="/2021/06/05/%E5%89%91%E6%8C%87Java%E8%87%AA%E7%A0%94%E6%A1%86%E6%9E%B6,%E5%86%B3%E8%83%9CSpring%E6%BA%90%E7%A0%81/001spring%E6%9E%B6%E6%9E%84%E5%9B%BE1.png"></p>
</blockquote>
</li>
<li><p>重点研究：</p>
<blockquote>
<p><img src="/2021/06/05/%E5%89%91%E6%8C%87Java%E8%87%AA%E7%A0%94%E6%A1%86%E6%9E%B6,%E5%86%B3%E8%83%9CSpring%E6%BA%90%E7%A0%81/002spring%E6%9E%B6%E6%9E%84%E5%9B%BE2.png"></p>
</blockquote>
</li>
<li><p>spring基础核心模块：</p>
<blockquote>
<p><img src="/2021/06/05/%E5%89%91%E6%8C%87Java%E8%87%AA%E7%A0%94%E6%A1%86%E6%9E%B6,%E5%86%B3%E8%83%9CSpring%E6%BA%90%E7%A0%81/003spring%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%971.png"></p>
</blockquote>
<blockquote>
<p><img src="/2021/06/05/%E5%89%91%E6%8C%87Java%E8%87%AA%E7%A0%94%E6%A1%86%E6%9E%B6,%E5%86%B3%E8%83%9CSpring%E6%BA%90%E7%A0%81/004spring%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%972.png"></p>
</blockquote>
<blockquote>
<p><img src="/2021/06/05/%E5%89%91%E6%8C%87Java%E8%87%AA%E7%A0%94%E6%A1%86%E6%9E%B6,%E5%86%B3%E8%83%9CSpring%E6%BA%90%E7%A0%81/005spring%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%973.png"></p>
</blockquote>
<blockquote>
<p><img src="/2021/06/05/%E5%89%91%E6%8C%87Java%E8%87%AA%E7%A0%94%E6%A1%86%E6%9E%B6,%E5%86%B3%E8%83%9CSpring%E6%BA%90%E7%A0%81/006spring%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%974.png"></p>
</blockquote>
</li>
<li><p>ASpectJ：</p>
<blockquote>
<p><img src="/2021/06/05/%E5%89%91%E6%8C%87Java%E8%87%AA%E7%A0%94%E6%A1%86%E6%9E%B6,%E5%86%B3%E8%83%9CSpring%E6%BA%90%E7%A0%81/007AspectJ.png"></p>
</blockquote>
</li>
<li><p>软件版本标记含义：</p>
<blockquote>
<p><img src="/2021/06/05/%E5%89%91%E6%8C%87Java%E8%87%AA%E7%A0%94%E6%A1%86%E6%9E%B6,%E5%86%B3%E8%83%9CSpring%E6%BA%90%E7%A0%81/008%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC.png"><br><img src="/2021/06/05/%E5%89%91%E6%8C%87Java%E8%87%AA%E7%A0%94%E6%A1%86%E6%9E%B6,%E5%86%B3%E8%83%9CSpring%E6%BA%90%E7%A0%81/009%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC2.png"></p>
</blockquote>
</li>
<li><p>spring学习路线和目标：</p>
<blockquote>
<p><img src="/2021/06/05/%E5%89%91%E6%8C%87Java%E8%87%AA%E7%A0%94%E6%A1%86%E6%9E%B6,%E5%86%B3%E8%83%9CSpring%E6%BA%90%E7%A0%81/010spring%E5%AD%A6%E4%B9%A0%E5%BB%BA%E8%AE%AE.png"><br><img src="/2021/06/05/%E5%89%91%E6%8C%87Java%E8%87%AA%E7%A0%94%E6%A1%86%E6%9E%B6,%E5%86%B3%E8%83%9CSpring%E6%BA%90%E7%A0%81/011%E8%87%AA%E7%A0%94%E6%9E%B6%E6%9E%84%E7%AE%80%E5%9B%BE1.png"></p>
</blockquote>
</li>
<li><p>泛型：</p>
<blockquote>
<p><img src="/2021/06/05/%E5%89%91%E6%8C%87Java%E8%87%AA%E7%A0%94%E6%A1%86%E6%9E%B6,%E5%86%B3%E8%83%9CSpring%E6%BA%90%E7%A0%81/012%E6%B3%9B%E5%9E%8B.png"><br>spring-aop里面的一些文具<br>实现了AOP20%的技术，满足了80%的需求，剩余20%的需求，通过spring AspectJ完成。</p>
</blockquote>
</li>
</ul>
<h2 id="2-Spring中的设计模式"><a href="#2-Spring中的设计模式" class="headerlink" title="2.Spring中的设计模式"></a>2.Spring中的设计模式</h2><h2 id="3-反射"><a href="#3-反射" class="headerlink" title="3.反射"></a>3.反射</h2><p>4-1</p>
<h2 id="4-注解"><a href="#4-注解" class="headerlink" title="4.注解"></a>4.注解</h2><h3 id="4-1注解背后的底层实现"><a href="#4-1注解背后的底层实现" class="headerlink" title="4.1注解背后的底层实现"></a>4.1注解背后的底层实现</h3><p>类加载信息：<br>-XX:+TraceClassLoading</p>
<h2 id="5-IOC"><a href="#5-IOC" class="headerlink" title="5.IOC"></a>5.IOC</h2><p>ioc是工厂模式和反射机制的结合</p>
<h2 id="springMVC"><a href="#springMVC" class="headerlink" title="springMVC"></a>springMVC</h2>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>spring源码</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/2017/04/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><ul>
<li><p>线程的生命周期(线程生命周期2.png)</p>
<p>  <img src="/2017/04/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F2.png" alt="多线程"></p>
</li>
<li><p>线程各个状态</p>
<p>  <strong>就绪状态</strong><br>  创建线程对象后，调用了线程的start()方法（此时线程只是进入了线程队列，等待获取CPU服务（cpu可能正在执行其他程序），具备运行条件，但是并不一定已经开始运行了）</p>
<p>  <strong>运行状态</strong><br>  处于就绪咋混个太的线程，一旦线程获取到CPU的服务之后，就进入到了运行状态，开始执行run()方法里面的逻辑。</p>
<p>  <strong>终止</strong><br>  线程的run()方法执行完毕，或者人为线程调用了stop()方法（该做法已经被淘汰），线程便进入终止状态。</p>
<p>  <strong>阻塞</strong><br>  一个正在执行的线程在某些情况下，由于某种原因而暂时让出了CPU资源，暂停了自己的执行，便进入了阻塞状态，如调用 sleep()方法。</p>
<p>  <strong>关于sleep()与wait()的补充说明</strong></p>
<p>  sleep暂停线程，但是监控状态仍然保持，结束后会自动恢复；<br>  sleep是线程类(Thread)的方法，wait是Object类的方法；<br>  sleep不释放对象锁，wait放弃对象锁。<br>  wait后进入等待锁定池，对此对象发出<strong>notify或notifyAll()<strong>方法后获得对象锁进入</strong>运行状态</strong></p>
<h2 id="线程的分类"><a href="#线程的分类" class="headerlink" title="线程的分类"></a>线程的分类</h2></li>
<li><p>用户线程</p>
<p>  运行在前台，执行具体的任务。<br>  如：程序的主线程，连接网络的子线程等都是用户线程。</p>
</li>
<li><p>守护线程</p>
<p>  运行在后台，为其他前台线程（用户线程）服务。</p>
</li>
<li><p>守护线程的特点：</p>
<p>  一旦所有用户线程都结束运行，守护线程也会随JVM一起结束工作。</p>
</li>
<li><p>守护线程的应用：</p>
<p>  如：数据库连接池中的监测线程（如，监测连接个数与连接超时情况）；<br>  JVM虚拟机启动后的监测线程（如：监测虚拟机内存使用情况、监测程序中持有情况）。<br>  最常见的守护线程：垃圾回收线程。</p>
</li>
<li><p>设置守护线程</p>
<p>  可以通过调用Thread类的setDaemon(true)方法来设置当前的线程为守护线程。</p>
<p>  <strong>注意：</strong></p>
<p>  1.setDaemon(true)必须在start()方法之前调用，否则会抛出IllegalThreadStateException异常。<br>  即：守护线程的设置一定要放在线程的启动之前。</p>
<p>  2.在守护线程中产生的新线程也是守护线程；</p>
<p>  3.不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑。</p>
<p>  原因：一旦所有用户线程都结束运行，守护线程也会随JVM一起结束工作，如果用户线程都结束了，守护线程的读写操作或计算逻辑岂不是要跪…</p>
<h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2></li>
<li><p>1.继承Thread类</p>
<pre><code>  class MyThread extends Thread&#123;
      ......
      @Override
      public void run()&#123;
          ......
      &#125;
  &#125;
  
  MyThread mt = new MyThread();//创建线程
  mt.start();//启动线程
</code></pre>
</li>
<li><p>2.实现Runnable接口</p>
<pre><code>  class MyThread implements Runnable&#123;
  
      ......
      @Override
      public void run()&#123;
          ......
      &#125;
  &#125;
  
  MyThread mt = new MyThread();
  Thread td = new Thread(mt);//创建线程
  td.start();//启动线程
</code></pre>
</li>
<li><p><strong>对比总结</strong></p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">无论用哪种方法，都要new一个Thread类对象，用Thread类的start方法来启动线程。</span><br></pre></td></tr></table></figure>
<p>  ​    </p>
</li>
</ul>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>微信点餐系统总结</title>
    <url>/2018/05/27/%E5%BE%AE%E4%BF%A1%E7%82%B9%E9%A4%90%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="springboot部署"><a href="#springboot部署" class="headerlink" title="springboot部署"></a>springboot部署</h2><ul>
<li><p>jar方式部署</p>
<p>  直接安装运行jar即可</p>
</li>
<li><p>war方式部署到tomcat</p>
<p>  <strong>war部署到tomcat的坑:</strong></p>
<pre><code>  1.修改启动类，继承SpringBootServletInitializer并重写configure方法：
  
      package com.imux.wxsell;

      import org.mybatis.spring.annotation.MapperScan;
      import org.springframework.boot.SpringApplication;
      import org.springframework.boot.autoconfigure.SpringBootApplication;
      import org.springframework.boot.builder.SpringApplicationBuilder;
      import org.springframework.boot.web.servlet.support.SpringBootServletInitializer;
      
      //没有数据源时添加 exclude = &#123;DataSourceAutoConfiguration.class&#125;
      @SpringBootApplication
      //@MapperScan(basePackages = &quot;com.imux.xwsell.dao&quot;)//mybatis接口包
      public class WxsellApplication extends SpringBootServletInitializer &#123;
      
          /**重写configure方法--外部tomcat部署*/
          @Override
          protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123;
              return application.sources(WxsellApplication.class);
          &#125;
      
          public static void main(String[] args) &#123;
              SpringApplication.run(WxsellApplication.class, args);
          &#125;
  &#125;
  
  --------------------------------------------------------------------------------------------------
  
  2.修改pom.xml文件
  
  &lt;packaging&gt;jar&lt;/packaging&gt;
  改为：
  &lt;packaging&gt;war&lt;/packaging&gt;
  
  --------------------------------------------------------------------------------------------------
  
  3.屏蔽内嵌tomcat
  
   &lt;!--去除内嵌tomcat--&gt;
  &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
  &lt;/dependency&gt;
  
  --------------------------------------------------------------------------------------------------
  
  4.由于本项目中使用了websocket,并且在WebSocketConfig中将ServerEndpointExporter指定给Spring管理，当使用外部tomcat容器时，部署后ServerEndpoint是需要Tomcat直接管理才能生效的，所以会报错误信息：&lt;&lt;&lt;Failed to register @ServerEndpoint class&gt;&gt;&gt;,解决方法：
  
  将：WebSocketConfig.java类中的内容全部注释掉即可：
   
      /*
      @Component
      public class WebSocketConfig &#123;
      
          @Bean
          public ServerEndpointExporter serverEndpointExporter() &#123;
              
              return new ServerEndpointExporter();
          &#125;
      &#125;
      */
 
</code></pre>
</li>
<li><p>参考文档</p>
<pre><code>springboot官方文档：
 
</code></pre>
<blockquote>
<p><a href="https://docs.spring.io/spring-boot/docs/2.0.1.RELEASE/reference/html/howto-traditional-deployment.html#howto-create-a-deployable-war-file">https://docs.spring.io/spring-boot/docs/2.0.1.RELEASE/reference/html/howto-traditional-deployment.html#howto-create-a-deployable-war-file</a></p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/qq_21144985/article/details/72921104">https://blog.csdn.net/qq_21144985/article/details/72921104</a></p>
</blockquote>
</li>
</ul>
]]></content>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>微信开发</title>
    <url>/2017/04/01/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h2 id="开发环境接入"><a href="#开发环境接入" class="headerlink" title="开发环境接入"></a>开发环境接入</h2><h3 id="准备外网映射工具"><a href="#准备外网映射工具" class="headerlink" title="准备外网映射工具"></a>准备外网映射工具</h3><p>按照微信公众平台的开发者文档要求，验证消息的确来自微信服务器时需要用到URL<br>可参考ngrok工具:</p>
<blockquote>
<p><a href="http://ngrok.2bdata.com/#introduction">http://ngrok.2bdata.com/#introduction</a></p>
</blockquote>
<p>进行下载配置(我的ngrok程序放在了F盘根目录下了)：</p>
<pre><code>每次用的时候都需要启动cmd命令端
f:
cd ngrok

ngrok -config=ngrok.cfg -subdomain xxx 8080

运行结果就是：

Tunnel Status                 online
Version                       1.7/1.7
Forwarding                    http://xxx.tunnel.2bdata.com -&gt; 127.0.0.1:8080
                              http://xxx.tunnel.2bdata.com/
Forwarding                    https://xxx.tunnel.2bdata.com -&gt; 127.0.0.1:8080
Web Interface                 127.0.0.1:4040
# Conn                        0
Avg Conn Time                 0.00ms
</code></pre>
<h3 id="验证消息的确来自微信服务器"><a href="#验证消息的确来自微信服务器" class="headerlink" title="验证消息的确来自微信服务器"></a>验证消息的确来自微信服务器</h3><p>根据微信开发者文档要求</p>
<pre><code>signature：微信加密签名，signature结合了开发者填写的token参数和请求中的timestamp参数、nonce参数。
timestamp：时间戳
nonce：    随机数
echostr：随机字符串

开发者通过检验signature对请求进行校验（下面有校验方式）。若确认此次GET请求来自微信服务器，
请原样返回echostr参数内容，则接入生效，成为开发者成功，否则接入失败。加密/校验流程如下：

1）将token、timestamp、nonce三个参数进行字典序排序
2）将三个参数字符串拼接成一个字符串进行sha1加密
3）开发者获得加密后的字符串可与signature对比，标识该请求来源于微信
</code></pre>
<p>部分参考代码：</p>
<pre><code>/**
 * 校验工具类
 */
public class checkUtil &#123;
    private static String token = &quot;uxawsenyweixin&quot;;

    //检验方法
    public static boolean checkSignature(String signature, String timestamp, String nonce) throws AesException &#123;
        String[] array = new String[]&#123;token, timestamp, nonce&#125;;
        //排序
        Arrays.sort(array);
        //拼接字符串
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i &lt; array.length; i++) &#123;
            sb.append(array[i]);
        &#125;
        String str = sb.toString();
        //SHA1加密
        String sha1Str = getSHA1(str);
        return sha1Str.equals(signature);

    &#125;

    //加密方法getSHA1实现
    public static String getSHA1(String str) throws AesException &#123;
        try &#123;
            // SHA1签名生成
            MessageDigest md = MessageDigest.getInstance(&quot;SHA-1&quot;);
            md.update(str.getBytes());
            byte[] digest = md.digest();

            StringBuffer hexstr = new StringBuffer();
            String shaHex = &quot;&quot;;
            for (int i = 0; i &lt; digest.length; i++) &#123;
                shaHex = Integer.toHexString(digest[i] &amp; 0xFF);
                if (shaHex.length() &lt; 2) &#123;
                    hexstr.append(0);
                &#125;
                hexstr.append(shaHex);
            &#125;
            return hexstr.toString();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            throw new AesException(AesException.ComputeSignatureError);
        &#125;
    &#125;

&#125;
</code></pre>
<p>文本转XML</p>
<pre><code>/**
 * 文本对象转成xml
 *
 * @param textMessage
 * @return
 */
public static String textMessageToXml(TextMessage textMessage) &#123;
    XStream xStream = new XStream();
    xStream.alias(&quot;xml&quot;, textMessage.getClass());
    return xStream.toXML(textMessage);
&#125;
</code></pre>
<p>xml转文本(map)</p>
<pre><code>/**
 * xml转map
 *
 * @param request
 * @return
 * @throws IOException
 * @throws DocumentException
 */
public static Map&lt;String, String&gt; xmlToMap(HttpServletRequest request) throws IOException, DocumentException &#123;
    Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
    SAXReader reader = new SAXReader();
    //读取xml中的数据
    InputStream input = request.getInputStream();
    Document document = reader.read(input);
    //获取根元素
    Element root = document.getRootElement();
    List&lt;Element&gt; list = root.elements();
    //遍历list并存进map
    for (Element e : list) &#123;
        map.put(e.getName(), e.getText());
    &#125;
    input.close();
    return map;

&#125;
</code></pre>
<p>完整参考代码见：</p>
<p><a href="https://git.coding.net/uxaw/weixin-v0.1.git">https://git.coding.net/uxaw/weixin-v0.1.git</a></p>
<h3 id="BAE"><a href="#BAE" class="headerlink" title="BAE"></a>BAE</h3><p>uxawsen.duapp.com<br><a href="http://weixin1230.duapp.com/weixin_war/weixinServlet">http://weixin1230.duapp.com/weixin_war/weixinServlet</a></p>
]]></content>
      <tags>
        <tag>&lt;font</tag>
        <tag>size=2&gt;微信&lt;/font&gt;</tag>
      </tags>
  </entry>
  <entry>
    <title>搬瓦工</title>
    <url>/2017/10/17/%E6%90%AC%E7%93%A6%E5%B7%A5/</url>
    <content><![CDATA[<h2 id="购买服务器"><a href="#购买服务器" class="headerlink" title="购买服务器"></a>购买服务器</h2><ul>
<li>vps</li>
</ul>
<h2 id="安装centos6-x64"><a href="#安装centos6-x64" class="headerlink" title="安装centos6 x64"></a>安装centos6 x64</h2><h2 id="安装shadowsocks"><a href="#安装shadowsocks" class="headerlink" title="安装shadowsocks"></a>安装shadowsocks</h2><ul>
<li><p>安装shadowsocks</p>
<blockquote>
<p><a href="https://github.com/teddysun/shadowsocks_install">https://github.com/teddysun/shadowsocks_install</a></p>
</blockquote>
</li>
</ul>
<h2 id="配置ss多账号"><a href="#配置ss多账号" class="headerlink" title="配置ss多账号"></a>配置ss多账号</h2><ul>
<li><p>参考文章：</p>
<blockquote>
<p><a href="http://blog.csdn.net/allfun/article/details/53350214">http://blog.csdn.net/allfun/article/details/53350214</a><br><a href="https://github.com/shadowsocks/shadowsocks/wiki/Configure-Multiple-Users">https://github.com/shadowsocks/shadowsocks/wiki/Configure-Multiple-Users</a></p>
</blockquote>
</li>
<li><p>连接centos6服务器</p>
</li>
<li><p>编辑shadowsocks.json文件</p>
<pre><code>  vi /etc/shadowsocks.json
  注：shadowsocks.json可能不存在，所以搜索不到。
  
  ###配置文件路径（201804新配置）
  /etc/shadowsocks-python
</code></pre>
</li>
<li><p>添加</p>
<pre><code>  &#123;
      &quot;server&quot;: &quot;0.0.0.0&quot;,
      &quot;port_password&quot;: &#123;
          &quot;8381&quot;: &quot;foobar1&quot;,
          &quot;8382&quot;: &quot;foobar2&quot;,
          &quot;8383&quot;: &quot;foobar3&quot;,
          &quot;8384&quot;: &quot;foobar4&quot;
      &#125;,
      &quot;timeout&quot;: 300,
      &quot;method&quot;: &quot;aes-256-cfb&quot;
  &#125;

  注：
  server：服务器IP
  port_password：自己设定的服务器端口和密码
  timeout：超时断开，以秒为单位
  method：default: &quot;aes-256-cfb&quot;,加密方式
  fast_open：是否使用TCP）

  然后按下ESC
  :(冒号)
  输入wq!，回车，就保存了
</code></pre>
</li>
<li><p>VI命令</p>
<pre><code>  按ESC键    跳到命令模式，然后
  :w        保存文件但不退出vi
  :w file   将修改另外保存到file中，不退出vi
  :w!       强制保存，不推出vi
  :wq       保存文件并退出vi
  :wq!      强制保存文件，并退出vi
  q:        不保存文件，退出vi
  :q!       不保存文件，强制退出vi
  :e!       放弃所有修改，从上次保存文件开始再编辑
</code></pre>
</li>
<li><p>启动ss/停止运行ss</p>
<pre><code>  开始：
      ssserver -c /etc/shadowsocks.json -d start
  结束：
      ssserver -c /etc/shadowsocks.json -d stop
</code></pre>
</li>
</ul>
<h2 id="SSH端口修改"><a href="#SSH端口修改" class="headerlink" title="SSH端口修改"></a>SSH端口修改</h2><ul>
<li><p>安装完centos后默认SSH端口并不是22，可以进行SSH端口修改</p>
<pre><code>  vi /etc/ssh/sshd_config
  
  修改为：
  Port 300000
  
  修改好后，执行下面命令重启SSH。
  /etc/init.d/sshd restart
</code></pre>
</li>
</ul>
<h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><ul>
<li><p>防火墙</p>
<pre><code>  service iptables status #查看防火墙状态
  service iptables restart #重启防火墙
  service iptables save #保存
</code></pre>
</li>
<li><p>提示防火墙模块未加载</p>
<pre><code>  modprobe  ip_tables  #加载ip_tables模块
  modprobe  iptable_filter  #加载iptable_filter模块
  lsmod | grep iptable  #查看模块，有模块即解决了
</code></pre>
</li>
<li><p>防火墙规则</p>
<pre><code>  命令模式修改防火墙：
  iptables -F #清理iptables规则
  #允许4400端口
  iptables -A INPUT -p tcp --dport 4400 -j ACCEPT
  iptables -A OUTPUT -p tcp --sport 4400 -j ACCEPT
  # 允许本地回环 127.0.0.1
  iptables -A INPUT -i lo -p all -j ACCEPT

  或直接修改防火墙规则文件：
  vi /etc/sysconfig/iptables
  
  保存
  service iptables save
</code></pre>
</li>
</ul>
<ul>
<li><p>关闭防火墙 </p>
<p>  1） 永久性生效，重启后不会复原</p>
<pre><code>  开启： chkconfig iptables on

  关闭： chkconfig iptables off
</code></pre>
<p>  2） 即时生效，重启后复原</p>
<pre><code>  开启： service iptables start
  
  关闭： service iptables stop
  
  查看防火墙状态（哪些端口在规则里）： service iptables status
</code></pre>
</li>
<li><p>iptables文件</p>
<pre><code>  nl /etc/sysconfig/iptables
</code></pre>
</li>
</ul>
]]></content>
      <tags>
        <tag>搬瓦工vps</tag>
      </tags>
  </entry>
  <entry>
    <title>杂记</title>
    <url>/2017/05/04/%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="鉴别iphone"><a href="#鉴别iphone" class="headerlink" title="鉴别iphone"></a>鉴别iphone</h2><ul>
<li><p>鉴别iphone</p>
<pre><code>  机子到手后如何验机
  1.新机开机后，会有一个感叹号（没有感叹号的证明机子不是未激活的），点击感叹号以后可以看到手机imei，官网查询一下是否未激活
  2.电脑下载爱思助手这个软件，然后连接手机到电脑，打开设备信息，看看是否电池充电次数为0
  3.官网确认未激活，电池确认没充电过，再用闪光灯检查手机的充电口和耳机口（官方售后喜欢这么检查，所以借鉴一下）
  备注：未激活的意思是机子还没使用过的意思，电池充电次数是充电过几次的意思
</code></pre>
</li>
</ul>
<h2 id="windows创建计划任务"><a href="#windows创建计划任务" class="headerlink" title="windows创建计划任务"></a>windows创建计划任务</h2><h3 id="创建定时重启任务"><a href="#创建定时重启任务" class="headerlink" title="创建定时重启任务"></a>创建定时重启任务</h3><ul>
<li><p><strong>定时重启</strong></p>
<p>  windows搜索框搜索”计划任务”，(或者在控制面板（选择小图标显示）-管理工具-任务计划程序)，点击运行，结果如下图</p>
</li>
<li><p><strong>选择创建基本任务</strong>(计划任务1.png):</p>
</li>
</ul>
<p><img src="/2017/05/04/%E6%9D%82%E8%AE%B0/%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A11.png" alt="杂记"></p>
<ul>
<li><strong>选择启动程序</strong>(计划任务2.png):</li>
</ul>
<p><img src="/2017/05/04/%E6%9D%82%E8%AE%B0/%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A12.png" alt="杂记"></p>
<ul>
<li><strong>选择System32\shutdown.exe</strong>(计划任务3.png):</li>
</ul>
<p><img src="/2017/05/04/%E6%9D%82%E8%AE%B0/%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A13.png" alt="杂记"></p>
<ul>
<li><strong>添加参数-r,代表重启，-s代表关机</strong>(计划任务4.png):</li>
</ul>
<p><img src="/2017/05/04/%E6%9D%82%E8%AE%B0/%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A14.png" alt="杂记"></p>
<h3 id="创建定时唤醒任务"><a href="#创建定时唤醒任务" class="headerlink" title="创建定时唤醒任务"></a>创建定时唤醒任务</h3><ul>
<li><p><strong>创建定时唤醒，利用定时执行程序唤醒休眠中的计算机，注意，是休眠中的计算机</strong></p>
</li>
<li><p>填写任务名称，选择最高权限(可选)（定时唤醒1.png）</p>
</li>
</ul>
<p><img src="/2017/05/04/%E6%9D%82%E8%AE%B0/%E5%AE%9A%E6%97%B6%E5%94%A4%E9%86%921.png" alt="杂记"></p>
<ul>
<li>新建触发器，设定执行时间，选择执行任务时间为每天（定时唤醒2.png）</li>
</ul>
<p><img src="/2017/05/04/%E6%9D%82%E8%AE%B0/%E5%AE%9A%E6%97%B6%E5%94%A4%E9%86%922.png" alt="杂记"></p>
<ul>
<li>新建操作，选择要执行的程序（定时唤醒3.png）</li>
</ul>
<p><img src="/2017/05/04/%E6%9D%82%E8%AE%B0/%E5%AE%9A%E6%97%B6%E5%94%A4%E9%86%923.png" alt="杂记"></p>
<ul>
<li>设置条件，勾选 唤醒计算机执行此任务（定时唤醒4.png）</li>
</ul>
<p><img src="/2017/05/04/%E6%9D%82%E8%AE%B0/%E5%AE%9A%E6%97%B6%E5%94%A4%E9%86%924.png" alt="杂记"></p>
<ul>
<li>在设置选项勾选如图所示(可选)。（定时唤醒5.png）</li>
</ul>
<p><img src="/2017/05/04/%E6%9D%82%E8%AE%B0/%E5%AE%9A%E6%97%B6%E5%94%A4%E9%86%925.png" alt="杂记"></p>
<h2 id="远程"><a href="#远程" class="headerlink" title="远程"></a>远程</h2><p>可以选择使用teamviewer</p>
<blockquote>
<p><a href="https://www.teamviewer.com/zhCN/">https://www.teamviewer.com/zhCN/</a></p>
</blockquote>
<p><strong>注意：</strong></p>
<p>为避免电脑长时间休眠等因素导致软件停止运行</p>
<ul>
<li>首先，将电脑的电源选项改为从不休眠</li>
<li>然后，我的电脑-右键-管理-服务-找到teamviewer-双击，找到恢复选项，改为如下图(teamviewer.png)：</li>
</ul>
<p><img src="/2017/05/04/%E6%9D%82%E8%AE%B0/teamviewer.png" alt="杂记"></p>
<p>这样做是为了防止teamviewer服务停止运行后，能够重新启动服务，如果连续两次启动失败，那么重新启动计算机（前提是，已经将teamviewer设置为随计算机启动）。</p>
<h2 id="PE装机U盘4G文件"><a href="#PE装机U盘4G文件" class="headerlink" title="PE装机U盘4G文件"></a>PE装机U盘4G文件</h2><ul>
<li><p>首先把U盘格式化成NTFS格式(这样U盘就能复制超过4G的镜像文件了)</p>
</li>
<li><p>然后再用装机工具制作装机盘（如大白菜），制作装机盘时可选HDD-FAT32，并不会改变U盘的NTFS格式。</p>
</li>
</ul>
<h2 id="WPS弹窗永久关闭"><a href="#WPS弹窗永久关闭" class="headerlink" title="WPS弹窗永久关闭"></a>WPS弹窗永久关闭</h2><ul>
<li><p>找到WPS安装目录下的wtoolex目录，将其中的wpsnotify.exe替换为txt改变格式为exe的同名文件</p>
</li>
<li><p>为防止wps自动更新/自动更新wpsnotify.exe，同时也将updateself.exe，wpsupdate.exe替换为自己创建的空白exe同名文件</p>
</li>
<li><p>个人不喜欢WPS的云，所以将wpscloudsvr.exe也替换了</p>
</li>
</ul>
<p><img src="/2017/05/04/%E6%9D%82%E8%AE%B0/wps%E5%BC%B9%E7%AA%971.png" alt="杂记"></p>
<p><img src="/2017/05/04/%E6%9D%82%E8%AE%B0/wps%E5%BC%B9%E7%AA%972.png" alt="杂记"></p>
<h3 id="IDEA代码类型提示关闭"><a href="#IDEA代码类型提示关闭" class="headerlink" title="IDEA代码类型提示关闭"></a>IDEA代码类型提示关闭</h3><ul>
<li>在settings&gt;Editor&gt;General&gt;Appearance下找到show Parameter取消勾选即可</li>
</ul>
<p><img src="/2017/05/04/%E6%9D%82%E8%AE%B0/IDEA.png" alt="杂记"></p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><ul>
<li><p>google DNS</p>
<pre><code>  8.8.8.8
  8.8.4.4
</code></pre>
</li>
<li><p>OpenDNS</p>
<pre><code>  208.67.222.222
  208.67.220.220
</code></pre>
</li>
<li><p>台湾中华电讯DNS</p>
<pre><code>  168.95.192.1
  168.95.192.2
</code></pre>
</li>
<li><p>香港宽频DNS</p>
<pre><code>  203.80.96.9
  203.80.96.10
</code></pre>
</li>
</ul>
<h2 id="查看所有进程占用端口"><a href="#查看所有进程占用端口" class="headerlink" title="查看所有进程占用端口"></a>查看所有进程占用端口</h2><ul>
<li><p>查看所有进程占用端口</p>
<pre><code>  netstat –ano
</code></pre>
</li>
<li><p>查看指定端口占用</p>
<pre><code>  netstat -ano|findstr &quot;8080&quot;    
</code></pre>
</li>
</ul>
<h2 id="Windows下mysql-1045错误编码"><a href="#Windows下mysql-1045错误编码" class="headerlink" title="Windows下mysql 1045错误编码"></a>Windows下mysql 1045错误编码</h2><ul>
<li><p>Access denied for user ‘root‘@’localhost’ (using password:YES)</p>
<pre><code>  1.停止mysql服务
  2.打开MySQL目录下的my.ini文件，在文件的最后添加一行“skip-grant-tables”，保存并关闭文件
  3.启动mysql服务，cmd下登录mysql
  mysql -u root -p
  不输密码直接回车
  重置mysql的root密码，然后重启mysql服务
  update user set password=PASSWORD(&quot;123456&quot;) where user=&#39;root&#39;;
  
</code></pre>
</li>
<li><p>window下mysql启动/停止命令</p>
<p>  启动</p>
<pre><code>  net start mysql
  
</code></pre>
<p>  停止</p>
<pre><code>  net stop mysql
  
</code></pre>
<p>  重启</p>
<pre><code>  windows下mysql没有restart命令，只能先停止再启动。
</code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>iphone</tag>
        <tag>计划任务</tag>
        <tag>远程</tag>
        <tag>PE装机4G大文件</tag>
        <tag>WPS</tag>
      </tags>
  </entry>
  <entry>
    <title>算法专题</title>
    <url>/2021/06/05/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98%E8%AF%BE(Java%E7%89%88)%EF%BC%8CGoogle%E9%9D%A2%E8%AF%95%E5%AE%98%E5%B8%A6%E4%BD%A0%E9%AB%98%E8%B4%A8%E9%87%8F%E5%88%B7%E9%A2%98/</url>
    <content><![CDATA[<h2 id="算法面试专题课-Java版-，Google面试官带你高质量刷题"><a href="#算法面试专题课-Java版-，Google面试官带你高质量刷题" class="headerlink" title="算法面试专题课(Java版)，Google面试官带你高质量刷题"></a>算法面试专题课(Java版)，Google面试官带你高质量刷题</h2><h3 id="算法网站"><a href="#算法网站" class="headerlink" title="算法网站"></a>算法网站</h3><pre><code>leetcode.com
hackerearth.com
codesignal.com
</code></pre>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>算法专题</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL基础</title>
    <url>/2016/12/20/SQL%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>SQL: 结构化查询语言(Structured Query Language)</p>
<h2 id="mysql配置程序"><a href="#mysql配置程序" class="headerlink" title="mysql配置程序"></a>mysql配置程序</h2><p>F:\mysql\server\bin\MySQLInstanceConfig.exe</p>
<h2 id="数据库的删除命令"><a href="#数据库的删除命令" class="headerlink" title="数据库的删除命令"></a>数据库的删除命令</h2><p>drop 表索引，表的存储过程，表结构和数据  都会删除</p>
<p>delete 删除部分表记录(可以配合where条件)</p>
<p>truncate 删除表的所有记录 </p>
<h2 id="SQL语法"><a href="#SQL语法" class="headerlink" title="SQL语法"></a>SQL语法</h2><ol>
<li>SQL语句可以在单行或多行书写，以分号结尾</li>
<li>可使用空格和缩进来增强语句的可读性</li>
<li>MySQL不区别大小写，建议关键字使用大写<br>如SELECT*FROM booktable;</li>
</ol>
<h2 id="SQL语句分类"><a href="#SQL语句分类" class="headerlink" title="SQL语句分类"></a>SQL语句分类</h2><pre><code>1. DDL（Data Definition Language）：数据定义语言，用来定义数据库对象：库、表、列等；
  &gt; 创建、删除、修改：库、表结构！！！
DDL：数据库或表的结构操作(*****)

2. DML（Data Manipulation Language）：数据操作语言，用来定义数据库记录（数据）；
  &gt; 增、删、改：表记录
DML：对表的记录进行更新（增、删、改）(*****)

3. DCL（Data Control Language）：数据控制语言，用来定义访问权限和安全级别；
DCL：对用户的创建，及授权！

4. DQL*****（Data Query Language）：数据查询语言，用来查询记录（数据）。
DQL：对表的记录的查询（*****，难点）
</code></pre>
<h2 id="DML-对表的记录进行更新（增、删、改）"><a href="#DML-对表的记录进行更新（增、删、改）" class="headerlink" title="DML(对表的记录进行更新（增、删、改）)"></a>DML(对表的记录进行更新（增、删、改）)</h2><h3 id="1-插入数据"><a href="#1-插入数据" class="headerlink" title="1. 插入数据"></a>1. 插入数据</h3><pre><code>* INTERT INTO 表名(列名1,列名2, ...) VALUES(列值1, 列值2, ...);
   &gt; 在表名后给出要插入的列名，其他没有指定的列等同与插入null值。所以插入记录总是插入一行，不可能是半行。
   &gt; 在VALUES后给出列值，值的顺序和个数必须与前面指定的列对应
* INTERT INTO 表名 VALUES(列值1, 列值2)
   &gt; 没有给出要插入的列，那么表示插入所有列。
   &gt; 值的个数必须是该表列的个数。
</code></pre>
<h3 id="2-修改数据"><a href="#2-修改数据" class="headerlink" title="2. 修改数据"></a>2. 修改数据</h3><pre><code>* UPDATE 表名 SET 列名1=列值1, 列名2=列值2, ... [WHERE 条件]
* 条件(条件可选的)：
   &gt; 条件必须是一个boolean类型的值或表达式：UPDATE t_person SET gender=&#39;男&#39;, age=age+1 WHERE sid=&#39;1&#39;;
   &gt; 运算符：=、!=、&lt;&gt;、&gt;、&lt;、&gt;=、&lt;=、BETWEEN...AND、IN(...)、IS NULL、NOT、OR、AND

例句：
WHERE age &gt;= 18 AND age &lt;= 80
WHERE age BETWEEN 18 AND 80

WHERE name=&#39;zhangSan&#39; OR name=&#39;liSi&#39;
WHERE name IN (&#39;zhangSan&#39;, &#39;liSi&#39;)
WHERE age IS NULL, 不能使用等号
WHERE age IS NOT NULL
</code></pre>
<h2 id="DQL-数据查询语言，用来查询记录（数据）"><a href="#DQL-数据查询语言，用来查询记录（数据）" class="headerlink" title="DQL:数据查询语言，用来查询记录（数据）"></a>DQL:数据查询语言，用来查询记录（数据）</h2><h3 id="一、-基本查询"><a href="#一、-基本查询" class="headerlink" title="一、    基本查询"></a>一、    基本查询</h3><p><strong>1.    字段(列)控制</strong></p>
<pre><code>1) 查询所有列
   SELECT * FROM 表名;
   SELECT * FROM emp;
   --&gt; 其中“*”表示查询所有列

2) 查询指定列
   SELECT 列1 [, 列2, ... 列N] FROM 表名;
   SELECT empno, ename, sal, comm FROM 表名;

3) 完全重复的记录只一次
   当查询结果中的多行记录一模一样时，只显示一行。一般查询所有列时很少会有这种情况，但只查询一列（或几列）时，这总可能就大了！
   SELECT DISTINCT * | 列1 [, 列2, ... 列N] FROM 表名;
   SELECT DISTINCT sal FROM emp;
   --&gt; 保查询员工表的工资，如果存在相同的工资只显示一次！

4) 列运算
   I 数量类型的列可以做加、减、乘、除运算
     SELECT sal*1.5 FROM emp;
     SELECT sal+comm FROM emp;

   II 字符串类型可以做连续运算
     SELECT CONCAT(&#39;$&#39;, sal) FROM emp;

   III 转换NULL值
     有时需要把NULL转换成其它值，例如com+1000时，如果com列存在NULL值，那么NULL+1000还是NULL，而我们这时希望把NULL当前0来运算。
     SELECT IFNULL(comm, 0)+1000 FROM emp;
     --&gt; IFNULL(comm, 0)：如果comm中存在NULL值，那么当成0来运算。

   IV 给列起别名
     你也许已经注意到了，当使用列运算后，查询出的结果集中的列名称很不好看，这时我们需要给列名起个别名，这样在结果集中列名就显示别名了
     SELECT IFNULL(comm, 0)+1000 AS 奖金 FROM emp;
   --&gt; 其中AS可以省略
例句：
查询指定列
SELECT empno,ename,sal 工资,comm FROM emp;

查询不重复记录
SELECT DISTINCT job,sal,ename FROM emp;

查询结果做运算
SELECT*,sal*2 实际工资 FROM emp;

IFNULL条件转换NULL值
SELECT*,sal+IFNULL(comm,0) 实际绩效工资 FROM emp;

CONCAT字符串连接
SELECT CONCAT(&quot;我是&quot;,ename) FROM emp;
SELECT CONCAT(&#39;我是&#39;,ename) FROM emp;

用IS NOT NULL做NULL条件判断，不能用!=NULL或&lt;&gt;NULL
SELECT*FROM emp WHERE comm IS NOT NULL;

给列起别名
SELECT ename AS 姓名,job AS 工作岗位 FROM emp;
或
SELECT ename 姓名,job 工作岗位 FROM emp;
</code></pre>
<p><strong>2.条件控制</strong></p>
<pre><code>1) 条件查询
    与前面介绍的UPDATE和DELETE语句一样，SELECT语句也可以使用WHERE子句来控制记录。
    * SELECT empno,ename,sal,comm FROM emp WHERE sal &gt; 10000 AND comm IS NOT NULL;
    * SELECT empno,ename,sal FROM emp WHERE sal BETWEEN 20000 AND 30000;
    * SELECT empno,ename,job FROM emp WHERE job IN (&#39;经理&#39;, &#39;董事长&#39;);
2) 模糊查询
    当你想查询姓张，并且姓名一共两个字的员工时，这时就可以使用模糊查询
    * SELECT * FROM emp WHERE ename LIKE &#39;张_&#39;;
    --&gt; 模糊查询需要使用运算符：LIKE，其中_匹配一个任意字符，注意，只匹配一个字符而不是多个。
    --&gt; 上面语句查询的是姓张，名字由两个字组成的员工。
    * SELECT * FROM emp WHERE ename LIKE &#39;___&#39;; /*姓名由3个字组成的员工*/

    如果我们想查询姓张，名字几个字可以的员工时就要使用“%”了。
    SELECT * FROM emp WHERE ename LIKE &#39;张%&#39;;
    --&gt; 其中%匹配0~N个任意字符，所以上面语句查询的是姓张的所有员工。
    SELECT * FROM emp WHERE ename LIKE &#39;%阿%&#39;;
    --&gt; 千万不要认为上面语句是在查询姓名中间带有阿字的员工，因为%匹配0~N个字符，所以姓名以阿开头和结尾的员工也都会查询到。
    SELECT * FROM emp WHERE ename LIKE &#39;%&#39;;
--&gt; 这个条件等同与不存在，但如果姓名为NULL的查询不出来！

例句：
条件查询

按工资范围查询
SELECT*FROM emp WHERE sal &gt;= 2000 AND sal &lt;=20000;
SELECT*FROM emp WHERE sal BETWEEN 2000 AND 20000;

按职位查询
SELECT * FROM emp WHERE job IN(&#39;销售员&#39;,&#39;经理&#39;) ORDER BY job;
关键字：IN  或  NOT IN

模糊查询

姓张，且为两个字
SELECT*FROM emp WHERE ename LIKE &#39;张_&#39;;

姓张，字数不限
SELECT*FROM emp WHERE ename LIKE&#39;张%&#39;;

查询以 牛 字结尾的姓名
SELECT*FROM emp WHERE ename LIKE &#39;%牛&#39;;

查询姓名中带 牛 字的，无论是开头，中间，还是结尾带 牛 字的，都会被查询出来
SELECT*FROM emp WHERE ename LIKE&#39;%牛%&#39;;
</code></pre>
<h3 id="二、-排序"><a href="#二、-排序" class="headerlink" title="二、    排序"></a>二、    排序</h3><pre><code>1) 升序
      SELECT * FROM WHERE emp ORDER BY sal ASC;
      --&gt; 按sal排序，升序！
      --&gt; 其中ASC是可以省略的
2) 降序
      SELECT * FROM WHERE emp ORDER BY comm DESC;
      --&gt; 按comm排序，降序！
      --&gt; 其中DESC不能省略
3) 使用多列作为排序条件
      SELECT * FROM WHERE emp ORDER BY sal ASC, comm DESC;
      --&gt; 使用sal升序排，如果sal相同时，使用comm的降序排

例句：
按sal升序排列，若sal相同，按comm降序排列
SELECT*FROM emp ORDER BY sal ASC,comm DESC;
</code></pre>
<h3 id="三、聚合函数-用来做某列的纵向运算的"><a href="#三、聚合函数-用来做某列的纵向运算的" class="headerlink" title="三、聚合函数(用来做某列的纵向运算的)"></a>三、聚合函数(用来做某列的纵向运算的)</h3><pre><code> 聚合函数用来做某列的纵向运算，在条件中不能出现聚合函数。
1) COUNT
      SELECT COUNT(*) FROM emp;
      --&gt; 计算emp表中所有列都不为NULL的记录的行数
      SELECT COUNT(comm) FROM emp;
      --&gt; 云计算emp表中comm列不为NULL的记录的行数
2) MAX
      SELECT MAX(sal) FROM emp;
      --&gt; 查询最高工资
3) MIN
      SELECT MIN(sal) FROM emp;
      --&gt; 查询最低工资
4) SUM
      SELECT SUM(sal) FROM emp;
      --&gt; 查询工资合
5) AVG
      SELECT AVG(sal) FROM emp;
      --&gt; 查询平均工资
      
例句：
查询总人数(注意，下句中数字1和*的意思相同，都表示所有。不论是1还是2，3等，都一样的意思)
SELECT COUNT(*) FROM emp;
SELECT COUNT(1) FROM emp;

查询工资sal总额
SELECT SUM(sal) FROM emp;

查询平均工资
SELECT AVG(sal) FROM emp;
查询最高工资的员工
SELECT MAX(sal),ename FROM emp;

查询最低工资的员工
SELECT MIN(sal),ename FROM emp;

查询以上所有
SELECT COUNT(*) 总人数,COUNT(sal) 工资总和,AVG(sal) 平均工资,MAX(sal) 最高工资,MIN(sal) 最低工资 FROM emp;
</code></pre>
<h3 id="三、-分组查询"><a href="#三、-分组查询" class="headerlink" title="三、    分组查询"></a>三、    分组查询</h3><pre><code>分组查询是把记录使用某一列进行分组，然后查询组信息。
例如：查看所有部门的记录数。
    SELECT deptno, COUNT(*) FROM emp GROUP BY deptno;
    --&gt; 使用deptno分组，查询部门编号和每个部门的记录数
    SELECT job, MAX(SAL) FROM emp GROUP BY job;
    --&gt; 使用job分组，查询每种工作的最高工资

  组条件
  以部门分组，查询每组记录数。条件为记录数大于3
  SELECT deptno, COUNT(*) 
FROM emp 
GROUP BY deptno HAVING COUNT(*) &gt; 3;

关键字的先后顺序：
select
from
where         （分组前）条件关键字
group by      分组关键字
having        (分组)后置条件关键字
order by      排序关键字

例句：

查询各部门人数
SELECT deptno 部门编号,COUNT(*) 总人数 
FROM emp 
GROUP BY deptno;

查询各岗位人数
SELECT job 工作岗位,COUNT(*) 人数 
FROM emp 
GROUP BY job;

查询各岗位中工资大于20000的人数-------------------(分组前的条件)
SELECT job,COUNT(*) 人数 
FROM emp 
WHERE sal&gt;=2000 
GROUP BY job;

查询各岗位中工资大于2000，且人数不少于3---------------(分组后的条件)
SELECT job 工作岗位,COUNT(*) 
FROM emp 
WHERE sal&gt;=2000 
GROUP BY job HAVING COUNT(*)&gt;=3;
</code></pre>
<h2 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h2><pre><code>在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与合计函数一起使用。
</code></pre>
<h3 id="四、-limit子句-方言"><a href="#四、-limit子句-方言" class="headerlink" title="四、    limit子句(方言)"></a>四、    limit子句(方言)</h3><pre><code>LIMIT用来限定查询结果的起始行，以及总行数。
注意：mysql记录下标从0计数

    例如：查询起始行为第5行，一共查询3行记录
    SELECT * FROM emp LIMIT 4, 3;
    --&gt; 其中4表示从第5行开始，其中3表示一共查询3行。即第5、6、7行记录。

    select * from emp limit 0, 5;

    1. 一页的记录数：10行
    2. 查询第3页
    select * from emp limit 20, 10;

   (当前页-1) * 每页记录数
   (3-1) * 10

查询第17页，每页8条记录
(17-1) * 8, 8

例句：
查询第3页，每页4条记录  
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (3-1）*4=8,即，从第9行记录开始查询，第9行下标为8
SELECT * FROM stu LIMIT 8,4;
</code></pre>
<h3 id="五、-多表查询"><a href="#五、-多表查询" class="headerlink" title="五、    多表查询"></a>五、    多表查询</h3><pre><code>多表查询分类：
    * 合并结果集(了解)
    * 连接查询
    * 子查询
</code></pre>
<p><strong>合并结果集</strong></p>
<pre><code>合并结果集
    * 要求被合并的表(实际是被合并的结果集)中，列的类型和列数相同（上下合并，而不是横向合并）
    * UNION，去除重复行
    * UNION ALL，不去除重复行

SELECT * FROM cd
UNION ALL
SELECT * FROM ab;

例句：

不去除重复行
SELECT deptno FROM emp
UNION ALL
SELECT deptno FROM dept;

去除重复行
SELECT deptno FROM emp
UNION
SELECT deptno FROM dept;
</code></pre>
<p><strong>内链接（内连接多表查询）</strong></p>
<pre><code>    * 方言：SELECT * FROM 表1 别名1, 表2 别名2 WHERE 别名1.xx=别名2.xx
    * 标准：SELECT * FROM 表1 别名1 INNER JOIN 表2 别名2 ON 别名1.xx=别名2.xx
    * 自然：SELECT * FROM 表1 别名1 NATURAL JOIN 表2 别名2
* 内连接查询出的所有记录都满足条件。

内连接查询的语句逻辑可以参考下面SQL语句推导：
SELECT *
FROM emp,dept;

下列三种SQL语句，建议使用标准版语句，便于数据库的更换；
例句：

标准版（通用）SQL语句
查询每个员工的姓名，工资，部门名称
SELECT e.ename,e.sal,d.dname
FROM emp e INNER JOIN dept d
ON e.deptno=d.deptno;

mysql方言版
查询每个员工的姓名，工资，部门名称
SELECT e.ename,e.sal,d.dname
FROM emp e,dept d
WHERE e.deptno=d.deptno;

自然版
查询每个员工的姓名，工资，部门名称
SELECT e.ename,e.sal,d.dname
FROM emp e NATURAL JOIN dept d
</code></pre>
<p><strong>外连接(外连接多表查询)</strong></p>
<pre><code>外连接有一主一次，左外即左表为主
如下面例子：即emp为主，那么主表中所有的记录无论满足条件与否，都会被打印出来。
当不满足条件是，右表部门使用NULL来补位。

左外连接
查询所有员工的姓名，薪水，所属部门(部门名称)
SELECT e.ename,e.sal,d.dname
FROM emp e LEFT OUTER JOIN dept d
ON e.deptno=d.deptno;

------------用IFNULL做判断后的假名------------------
SELECT e.ename,e.sal,IFNULL(d.dname,&#39;无部门&#39;) AS dname
FROM emp e LEFT OUTER JOIN dept d
ON e.deptno=d.deptno;

右外连接emp
查询所有部门中员工的姓名，薪水，所属部门(部门名称)
SELECT e.ename,e.sal,d.dname
FROM emp e RIGHT OUTER JOIN dept d
ON e.deptno=d.deptno;

全连接
查询所有部门的所有员工的姓名，薪水，所属部门(部门名称)---利用左外连接和右外连接 进行合并结果集 完成全外连接查询（因为mysql不支持全连接查询）

SELECT e.ename,e.sal,d.dname
FROM emp e LEFT OUTER JOIN dept d
ON e.deptno=d.deptno
UNION
SELECT e.ename,e.sal,d.dname
FROM emp e RIGHT OUTER JOIN dept d
ON e.deptno=d.deptno;
</code></pre>
<p><strong>子查询</strong></p>
<pre><code>子查询：一条查询语句中有多个SELECT关键字，就是子查询(也叫嵌套查询)

1.    出现的位置：
select后也可以有，但是不规范，所以不用
    * where后作为条件存在
    * from后作为表存在(多行多列)

  2. 条件
    * (***)单行单列：SELECT * FROM 表1 别名1 WHERE 列1 [=、&gt;、&lt;、&gt;=、&lt;=、!=] (SELECT 列 FROM 表2 别名2 WHERE 条件)
    * (**)多行单列：SELECT * FROM 表1 别名1 WHERE 列1 [IN, ALL, ANY] (SELECT 列 FROM 表2 别名2 WHERE 条件)
    * (*)单行多列：SELECT * FROM 表1 别名1 WHERE (列1,列2) IN (SELECT 列1, 列2 FROM 表2 别名2 WHERE 条件)
* (***)多行多列：SELECT * FROM 表1 别名1 , (SELECT ....) 别名2 WHERE 条件

例句：
1.    查询本公司工资最高的员工信息
        select* from emp 
where sal=
(select max(sal) from emp);

2.    查询emp表中职位和部门与殷天正一样的所有员工的姓名，部门，工作岗位
SELECT b.ename,b.deptno,b.job FROM emp b WHERE (deptno,job) IN
(SELECT deptno,job FROM emp WHERE ename=&#39;殷天正&#39;)     

3．查询员工中工资比30部门中所有人工资高的员工的姓名，工资
SELECT a.ename,a.sal FROM emp a
WHERE sal &gt; ALL
(SELECT MAX(sal) FROM emp WHERE deptno=&#39;30&#39;)

3.    查询员工中工资比任何一个30部门中工资高的员工的姓名，工作岗位，工资
SELECT a.ename,a.job,a.sal FROM emp a
WHERE sal&gt; ANY
(SELECT sal FROM emp WHERE deptno=&#39;30&#39;)
</code></pre>
<h2 id="员工表练习"><a href="#员工表练习" class="headerlink" title="员工表练习"></a>员工表练习</h2><ul>
<li><p>员工表建表SQL：</p>
<blockquote>
<p><a href="http://op05inpyd.bkt.clouddn.com/%E5%91%98%E5%B7%A5%E8%A1%A8%E5%BB%BA%E8%A1%A8SQL.sql">http://op05inpyd.bkt.clouddn.com/%E5%91%98%E5%B7%A5%E8%A1%A8%E5%BB%BA%E8%A1%A8SQL.sql</a></p>
</blockquote>
</li>
<li><p>员工表查询练习SQL:</p>
<blockquote>
<p><a href="http://op05inpyd.bkt.clouddn.com/%E5%91%98%E5%B7%A5%E8%A1%A8SQL%E5%AD%A6%E4%B9%A0.sql">http://op05inpyd.bkt.clouddn.com/%E5%91%98%E5%B7%A5%E8%A1%A8SQL%E5%AD%A6%E4%B9%A0.sql</a></p>
</blockquote>
</li>
</ul>
<h2 id="多表查询练习之学生表"><a href="#多表查询练习之学生表" class="headerlink" title="多表查询练习之学生表"></a>多表查询练习之学生表</h2><ul>
<li><p>参考博客：</p>
<blockquote>
<p><a href="http://www.cnblogs.com/qixuejia/p/3637735.html">http://www.cnblogs.com/qixuejia/p/3637735.html</a></p>
</blockquote>
</li>
<li><p>建表SQL</p>
<blockquote>
<p><a href="http://op05inpyd.bkt.clouddn.com/%E5%AD%A6%E7%94%9F%E8%A1%A8%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%BB%BA%E8%A1%A8%E8%AF%AD%E5%8F%A5.sql">http://op05inpyd.bkt.clouddn.com/%E5%AD%A6%E7%94%9F%E8%A1%A8%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%BB%BA%E8%A1%A8%E8%AF%AD%E5%8F%A5.sql</a></p>
</blockquote>
</li>
<li><p>学生表多表查询练习：</p>
</li>
<li><p><strong>SQL文件链接：</strong></p>
<blockquote>
<p><a href="http://op05inpyd.bkt.clouddn.com/%E5%AD%A6%E7%94%9F%E8%A1%A8%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0%E7%AD%94%E6%A1%88%E8%AF%AD%E5%8F%A5.sql">http://op05inpyd.bkt.clouddn.com/%E5%AD%A6%E7%94%9F%E8%A1%A8%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0%E7%AD%94%E6%A1%88%E8%AF%AD%E5%8F%A5.sql</a></p>
</blockquote>
</li>
<li><p>SQL语句</p>
<p>  2017/9/22 9:54:52 (改)</p>
<pre><code>  1、查询“001”课程比“002”课程成绩高的所有学生的学号
  
  --------------子查询版-------------------------------
  SELECT a.sid 学生编号
  FROM 
  (SELECT sid,score FROM sc WHERE cid=&#39;1&#39;)a,
  (SELECT sid,score FROM sc WHERE cid=&#39;2&#39;)b
  WHERE a.score&gt;b.score AND a.sid=b.sid

  -----------------非子查询版---------------------------
  SELECT a.*
  FROM sc AS a
  LEFT JOIN sc AS b ON a.Sid = b.Sid AND a.Cid = &#39;1&#39; AND b.Cid=&#39;2&#39;
  WHERE  a.score&gt;b.score

  2、查询平均成绩大于60分的同学的学号和平均成绩
  
  SELECT sid,a.score FROM 
  (SELECT sid,AVG(score) score FROM sc GROUP BY sid)a
  WHERE a.score&gt;60;

  -----------------非子查询版---------------------------
  SELECT sid,AVG(SCORE) 
  FROM sc  
  GROUP BY sid
  HAVING AVG(SCORE) &gt;60;

  3、查询所有同学的学号、姓名、选课数、总成绩
  
  SELECT a.sid,a.sname,b.num,c.sumscore
  FROM student a,
  (SELECT sid,COUNT(cid) num FROM sc GROUP BY sid) b,
  (SELECT sid,SUM(score) sumscore FROM sc GROUP BY sid) c
  WHERE a.sid=b.sid AND b.sid=c.sid;

  -----------------非子查询版---------------------------
  SELECT a.sid,a.sname,COUNT(b.Cid),SUM(b.score)
  FROM student AS a
  LEFT JOIN sc AS b ON a.Sid = b.Sid
  GROUP BY a.Sid;

  4、查询姓“叶”的老师的个数
  
  SELECT COUNT(*) 个数 FROM teacher
  WHERE Tname LIKE &#39;叶%&#39;;

  -----------------或-----------------------------------
  SELECT COUNT(1) 个数 FROM teacher
  WHERE Tname LIKE &#39;叶%&#39;;
  
  5、查询没学过“叶平”老师课的同学的学号、姓名
  
  有误：    SELECT a.sid ,b.sname FROM sc a,student b
      WHERE cid !=
      (SELECT cid FROM course WHERE tid = 
      (SELECT tid FROM teacher WHERE tname=&#39;叶平&#39;))
      AND a.sid=b.sid GROUP BY sid;

  -------------------------改----------------------------------
  SELECT Sid,Sname FROM student
  WHERE sid NOT IN(
  SELECT a.Sid
  FROM student AS a
  LEFT JOIN sc AS b ON b.Sid = a.Sid
  LEFT JOIN course AS c ON c.Cid = b.Cid 
  INNER JOIN teacher AS d ON d.Tid = c.Tid AND d.Tname =&#39;叶平&#39;
  )

  6、查询学过“001”并且也学过编号“002”课程的同学的学号、姓名
  SELECT a.sid,c.sname FROM student c,
  (SELECT sid FROM sc WHERE cid=1)a,
  (SELECT sid FROM sc WHERE cid=2)b
  WHERE a.sid = b.sid AND c.sid=b.sid
  
  7、查询学过“叶平”老师所教的所有课的同学的学号、姓名
  
  SELECT a.sid,sname FROM sc a,student b WHERE cid = 
  (SELECT cid FROM course WHERE tid = 
  (SELECT tid FROM teacher WHERE tname=&#39;叶平&#39;))
  AND a.sid=b.sid
  
  8、查询课程编号“002”的成绩比课程编号“001”课程低的所有同学的学号、姓名
  
  SELECT a.sid,sname FROM student c,
  (SELECT sid,score FROM sc WHERE cid=&#39;1&#39;)a,
  (SELECT sid,score FROM sc WHERE cid=&#39;2&#39;)b
  WHERE a.score&gt;b.score AND a.sid  = b.sid AND c.sid=b.sid
  
  9、查询所有课程成绩小于60分的同学的学号、姓名
  
  SELECT b.sid,a.sname FROM student a,
  (SELECT sid FROM sc WHERE score &lt;60)b
  WHERE a.sid=b.sid GROUP BY sname
  
  10、查询没有学全所有课的同学的学号、姓名
  SELECT a.sid,sname FROM student b,
  (SELECT sid,COUNT(cid) anum  FROM sc GROUP BY sid)a
  WHERE a.anum&lt;
  (SELECT COUNT(cname)bnum FROM course)
  AND a.sid=b.sid
</code></pre>
</li>
</ul>
<h3 id="MySql的备份与恢复数据库"><a href="#MySql的备份与恢复数据库" class="headerlink" title="MySql的备份与恢复数据库"></a>MySql的备份与恢复数据库</h3><pre><code>mysqldump -uroot -p123 exam&gt;C:\mydb1.sql
</code></pre>
<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p><strong>存储过程的优点</strong></p>
<pre><code>增强SQL语句的功能和灵活性；
实现较快的执行速度；
减少网络流量。
</code></pre>
<p><strong>创建存储过程</strong></p>
<h2 id="查询中拼接字符串"><a href="#查询中拼接字符串" class="headerlink" title="查询中拼接字符串"></a>查询中拼接字符串</h2><ul>
<li><p>拼接列与字符串</p>
<pre><code>  select username,password,CONCAT(username,&quot;@test.com&quot;) as email from pre_ucenter_members
</code></pre>
</li>
</ul>
<p>未完待续…..</p>
]]></content>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>面试总结20180410</title>
    <url>/2018/04/10/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%9320180410/</url>
    <content><![CDATA[<h1 id="2018"><a href="#2018" class="headerlink" title="2018"></a>2018</h1><h2 id="项目情况"><a href="#项目情况" class="headerlink" title="项目情况"></a>项目情况</h2><ul>
<li>项目介绍</li>
</ul>
<h2 id="JavaSE"><a href="#JavaSE" class="headerlink" title="JavaSE"></a>JavaSE</h2><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><ul>
<li><p>集合概述</p>
</li>
<li><p>list与set的异同</p>
</li>
<li><p>hashtable与hashmap异同</p>
<p>  以上三点可以从下图简要分析(集合总结2.png):</p>
<p>  <img src="/2018/04/10/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%9320180410/%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%932.png"><br>  <strong>map的key不能重复,value可以重复</strong></p>
</li>
</ul>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><ul>
<li><p>JVM</p>
<p>  JVM是Java Virtual Machine（Java虚拟机）的缩写，</p>
<p>  JVM是一种用于<strong>计算设备的规范</strong>，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。</p>
<p>  Java虚拟机包括<strong>一套字节码指令集</strong>、<strong>一组寄存器</strong>、<strong>一个栈</strong>、<strong>一个垃圾回收堆</strong>和<strong>一个存储方法域</strong>。 </p>
<p>  JVM屏蔽了与具体操作系统平台相关的信息，使Java程序只需生成在Java虚拟机上运行的目标代码（字节码）,就可以在多种平台上不加修改地运行。</p>
<p>  JVM在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。</p>
<blockquote>
<p><a href="http://www.cnblogs.com/sunada2005/p/3577799.html">http://www.cnblogs.com/sunada2005/p/3577799.html</a></p>
</blockquote>
</li>
<li><p>JVM调优</p>
<pre><code>  JVM三大性能调优参数：–Xmx -Xms –Xss
  
  –Xmx -Xms是对堆的性能调优参数，一般两个设置是一样的，
      如果不一样，当Heap(堆)不够用，会发生内存抖动。一般都调大这两个参数，并且两个大小一样。
      
  ----------------------------------------------------------------------------------------------
  -Xss是对每一个线程栈的性能调优参数,影响堆栈调用的深度。是指设定每个线程的堆栈大小。这个就要依据你的程序，看一个线程大约需要占用多少内存，可能会有多少线程同时运行等。
  
  -Xmx：代表最大堆。是指设定程序运行期间最大可占用的内存大小。如果程序运行需要占用更多的内存，超出了这个设置值，就会抛出OutOfMemory异常。
  
  -Xms：代表最小堆(初始堆大小)。是指设定程序启动时占用内存大小。一般来讲，大点，程序会启动的快一点，但是也可能会导致机器暂时间变慢。
  
  -Xmn：代表新生代(Young Gen)。
  
  上三个参数的设置都是默认以Byte为单位的，也可以在数字后面添加[k/K]或者[m/M]来表示KB或者MB。而且，超过机器本身的内存大小也是不可以的，否则就等着机器变慢而不是程序变慢了。
</code></pre>
<p>  jvm调优总结：</p>
<blockquote>
<p><a href="https://www.cnblogs.com/ceshi2016/p/8447989.html">https://www.cnblogs.com/ceshi2016/p/8447989.html</a></p>
</blockquote>
</li>
<li><p><strong>借助于示例理解：</strong></p>
<pre><code>  对于JVM内存配置参数：
  -Xmx10240m -Xms10240m -Xmn5120m -XXSurvivorRatio=3
  其最小内存值和Survivor区总大小分别是（）
  
  10240m，2048m
  
  --------------------------------------解析----------------------------------------------------
  -Xmx10240m：代表最大堆
  -Xms10240m：代表最小堆(初始堆大小)
  -Xmn5120m： 代表新生代(Young Gen)
  -XXSurvivorRatio=3：代表Eden:Survivor = 3    
  根据Generation-Collection算法(目前大部分JVM采用的算法)，一般根据对象的生存周期将堆内存分为若干不同的区域，
  一般情况将新生代分为Eden+两块Survivor；    
  计算Survivor大小， Eden:Survivor = 3，总大小为5120,3x+x+x=5120  x=1024
  
  所以,2x=1024*2=2048,即Survivor区总大小是2048，
  -Xms初始堆大小,即最小内存值为10240m
  
  (ps:新生代大部分要回收，采用Copying算法，快！
  老年代 大部分不需要回收，采用Mark-Compact算法)
</code></pre>
</li>
<li><p>JVM调优相关1.png</p>
<p>  <img src="/2018/04/10/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%9320180410/JVM%E8%B0%83%E4%BC%98%E7%9B%B8%E5%85%B31.png"><br>  <img src="/2018/04/10/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%9320180410/jvm%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%9F%9F.jpeg"></p>
</li>
</ul>
<blockquote>
<p><a href="https://www.nowcoder.com/questionTerminal/970cdaaa4a114cbf9fef82213a7dabca">https://www.nowcoder.com/questionTerminal/970cdaaa4a114cbf9fef82213a7dabca</a></p>
</blockquote>
<ul>
<li><p>垃圾回收</p>
<blockquote>
<p><a href="https://blog.csdn.net/aijiudu/article/details/72991993">https://blog.csdn.net/aijiudu/article/details/72991993</a></p>
</blockquote>
</li>
</ul>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><ul>
<li><p>线程和进程</p>
<p>  1.进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同</p>
<p>  2.进程中包含线程</p>
<p>  3.举例：</p>
<p>  开个QQ，开了一个进程；开了迅雷，开了一个进程。<br>  在QQ的这个进程里，传输文字开一个线程、传输语音开了一个线程、弹出对话框又开了一个线程。</p>
</li>
<li><p>线程创建方式</p>
<ul>
<li><p>1.继承Thread类</p>
<pre><code>  class MyThread extends Thread&#123;
      ......
      @Override
      public void run()&#123;
          ......
      &#125;
  &#125;
  
  MyThread mt = new MyThread();//创建线程
  mt.start();//启动线程
</code></pre>
</li>
<li><p>2.实现Runnable接口</p>
<pre><code>  class MyThread implements Runnable&#123;
  
      ......
      @Override
      public void run()&#123;
          ......
      &#125;
  &#125;
  
  MyThread mt = new MyThread();
  Thread td = new Thread(mt);//创建线程
  td.start();//启动线程
</code></pre>
</li>
<li><p><strong>对比总结</strong></p>
<pre><code>  无论用哪种方法，都要new一个Thread类对象，用Thread类的start方法来启动线程。
</code></pre>
</li>
</ul>
</li>
<li><p><strong>线程生命周期(线程生命周期2.png)</strong></p>
<p>  <img src="/2018/04/10/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%9320180410/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F2.png"></p>
</li>
<li><p>线程各个状态</p>
<p>  <strong>就绪状态</strong><br>  创建线程对象后，调用了线程的start()方法（此时线程只是进入了线程队列，等待获取CPU服务（cpu可能正在执行其他程序），具备运行条件，但是并不一定已经开始运行了）</p>
<p>  <strong>运行状态</strong><br>  处于就绪状态的线程，一旦线程获取到CPU的服务之后，就进入到了运行状态，开始执行run()方法里面的逻辑。</p>
<p>  <strong>终止</strong><br>  线程的run()方法执行完毕，或者人为线程调用了stop()方法（该做法已经被淘汰），线程便进入终止状态。</p>
<p>  <strong>阻塞</strong><br>  一个正在执行的线程在某些情况下，由于某种原因而暂时让出了CPU资源，暂停了自己的执行，便进入了阻塞状态，如调用 sleep()方法。</p>
<h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3></li>
<li><p>JDK7和JDK8的异同（JDK8的新特性）</p>
</li>
</ul>
<h2 id="框架部分"><a href="#框架部分" class="headerlink" title="框架部分"></a>框架部分</h2><ul>
<li><p>springmvc的单例模式</p>
<blockquote>
<p><a href="https://blog.csdn.net/qianyiyiding/article/details/77104736">https://blog.csdn.net/qianyiyiding/article/details/77104736</a></p>
</blockquote>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/21733226">https://zhuanlan.zhihu.com/p/21733226</a></p>
</blockquote>
<p>  即：spring MVC中的controller是单例模式，但是是多线程，各个线程之间不影响！</p>
<p>  设置为多例模式：@Scope(“prototype”)</p>
<pre><code>  @RestController
  @RequestMapping(value = &quot;hello&quot;)
  @Scope(&quot;prototype&quot;)
  public class HelloController &#123;
</code></pre>
<blockquote>
<p><a href="https://blog.csdn.net/qianyiyiding/article/details/77104736">https://blog.csdn.net/qianyiyiding/article/details/77104736</a></p>
</blockquote>
</li>
<li><p>mybatis与hibernate异同</p>
</li>
<li><p>Spring的AOP与IOC</p>
<pre><code>  spring是J2EE应用程序的开源框架，是轻量级的IoC和AOP的容器框架，可以单独使用，也可以和其他框架组合使用
</code></pre>
<p>  AOP：</p>
<pre><code>  java面向对象思想的拓展，将系统中非核心的业务提取出来，进行单独处理。比如事务、日志和安全等体现java的灵活。
  
  spring中面向切面的实现有两种方式，一种是动态代理，一种是CGLIB，动态代理必须要提供接口，而CGLIB实现是继承。
  
  **关于IoC和DI**
</code></pre>
<blockquote>
<p><a href="https://www.iteye.com/blog/jinnianshilongnian-1413846">https://www.iteye.com/blog/jinnianshilongnian-1413846</a></p>
</blockquote>
<p>  <strong>IOC与DI：</strong></p>
<pre><code>  1）（IOC）控制反转：组件**依赖关系**的创建和管理置于spring容器，由容器控制，而不是由代码直接控制，将控制权转向了容器。
  
  2）（DI）依赖注入:组件之间的依赖关系由容器在运行期决定 ，由容器动态的将某种依赖关系注入到组件之中，实现的程序的解耦。 
  
  spring中有三种注入方式，一种是set注入，一种是接口注入，另一种是构造方法注入。
  
  IoC是什么 之●为何是反转，哪些方面反转了：
  
  有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；
  而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，
  对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。
</code></pre>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/90939765">https://zhuanlan.zhihu.com/p/90939765</a></p>
</blockquote>
<h2 id="spring-websocket-api"><a href="#spring-websocket-api" class="headerlink" title="spring websocket api"></a>spring websocket api</h2><ul>
<li>Spring 4.0的websocket的支持</li>
</ul>
<blockquote>
<p><a href="http://wiselyman.iteye.com/blog/2003336">http://wiselyman.iteye.com/blog/2003336</a></p>
</blockquote>
</li>
<li><p>SSM概述(SSM概述.png)：</p>
<p>  <img src="/2018/04/10/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%9320180410/SSM%E6%A6%82%E8%BF%B0.png"></p>
</li>
</ul>
<h2 id="数据库部分"><a href="#数据库部分" class="headerlink" title="数据库部分"></a>数据库部分</h2><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ul>
<li><p>数据库索引(创建索引.jpg)</p>
<p>  <img src="/2018/04/10/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%9320180410/%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95.jpg"></p>
<h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3></li>
<li><p>自己添加：</p>
<pre><code>  jdbc
  
  多看
  SQL进阶
  java基础    
</code></pre>
</li>
</ul>
<h2 id="servlet与CGI"><a href="#servlet与CGI" class="headerlink" title="servlet与CGI"></a>servlet与CGI</h2><ul>
<li><p>servlet与CGI(Common Gateway Interface 公共网关接口)</p>
<pre><code>  Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。
  (1)加载：容器通过类加载器使用servlet类对应的文件加载servlet
  (2)创建：通过调用servlet构造函数创建一个servlet对象
  (3)初始化：调用init方法初始化
  (4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求
  (5)卸载：调用destroy方法让servlet自己释放其占用的资源
</code></pre>
<h2 id="JSP九大内置对象"><a href="#JSP九大内置对象" class="headerlink" title="JSP九大内置对象"></a>JSP九大内置对象</h2></li>
<li><p>JSP九大内置对象</p>
<ul>
<li><p>内置对象特点:</p>
<pre><code>  1.由JSP规范提供,不用编写者实例化
  2.通过Web容器实现和管理
  3.所有JSP页面均可使用
  4.只有在脚本元素的表达式或代码段中才可使用(&lt;%=使用内置对象%&gt;或&lt;%使用内置对象%&gt;)
</code></pre>
</li>
<li><p>常用内置对象:</p>
<pre><code>  1.输出输入对象:request对象、response对象、out对象
  2.通信控制对象:pageContext对象、session对象、application对象
  3.Servlet对象:page对象、config对象
  4.错误处理对象:exception对象    
</code></pre>
<h2 id="String、StringBuffer、StringBuilder"><a href="#String、StringBuffer、StringBuilder" class="headerlink" title="String、StringBuffer、StringBuilder"></a>String、StringBuffer、StringBuilder</h2></li>
</ul>
</li>
<li><p>区别</p>
<pre><code>  String：适用于少量的字符串操作的情况
  StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况
  StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况
</code></pre>
</li>
<li><p>从JVM角度分析String慢的原因</p>
<pre><code>  那么JVM就会像上面说的那样，不断的创建、回收对象来进行这个操作了。速度就会很慢。
</code></pre>
</li>
<li><p>StringBuffer与StringBuilder</p>
<pre><code>  StringBuilder是线程不安全的，而StringBuffer是线程安全的
  StringBuffer        JDK1.0出现
  StringBuilder   JDK1.5出现
</code></pre>
<h2 id="mybatis缓存"><a href="#mybatis缓存" class="headerlink" title="mybatis缓存"></a>mybatis缓存</h2></li>
<li><p>一级缓存和二级缓存</p>
<pre><code>  mybatis的一级缓存:
  　　MyBatis会在表示会话的SqlSession对象中建立一个简单的缓存，将每次查询到的结果结果缓存起来，
  当下次查询的时候，如果判断先前有个完全一样的查询，会直接从缓存中直接将结果取出，返回给用户，
  不需要再进行一次数据库查询了。
  
  　　MyBatis会在一次会话的SqlSession对象中创建一个本地缓存(local cache)，
  对于每一次查询，都会尝试*根据查询的条件*去本地缓存中查找是否在缓存中，如果在缓存中，
  就直接从缓存中取出，然后返回给用户；否则，从数据库读取数据，将查询结果存入缓存并返回给用户。
  
  　　一级缓存是SqlSession级别的缓存。在操作数据库时需要构造 sqlSession对象，
  　　在对象中有一个(内存区域)数据结构（HashMap）用于存储缓存数据。
  　　不同的sqlSession之间的缓存数据区域（HashMap）是互相不影响的。
  
  　　一级缓存的作用域是同一个SqlSession，在同一个sqlSession中两次执行相同的sql语句，
  　　第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。
  　　当一个sqlSession结束后该sqlSession中的一级缓存也就不存在了。Mybatis默认开启一级缓存。
  
  　　二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，
  　　多个SqlSession去操作数据库得到数据会存在二级缓存区域，多个SqlSession可以共用二级缓存，
  　　二级缓存是跨SqlSession的。
  
  　　二级缓存是多个SqlSession共享的，其作用域是mapper的同一个namespace，
  　　不同的sqlSession两次执行相同namespace下的sql语句且向sql中传递参数也相同即最终执行相同的sql语句，
  　　第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。
  　　Mybatis默认没有开启二级缓存需要在setting全局参数中配置开启二级缓存。
</code></pre>
</li>
<li><p>参考</p>
<blockquote>
<p><a href="https://www.cnblogs.com/little-fly/p/6251451.html">https://www.cnblogs.com/little-fly/p/6251451.html</a><br><a href="http://www.jb51.net/article/116961.htm">http://www.jb51.net/article/116961.htm</a></p>
</blockquote>
</li>
</ul>
<h1 id="2019"><a href="#2019" class="headerlink" title="2019"></a>2019</h1><h2 id="spring中使用了哪些设计模式？"><a href="#spring中使用了哪些设计模式？" class="headerlink" title="spring中使用了哪些设计模式？"></a>spring中使用了哪些设计模式？</h2><blockquote>
<p><a href="https://juejin.im/entry/5c6611a2f265da2de1658a13">https://juejin.im/entry/5c6611a2f265da2de1658a13</a>    </p>
</blockquote>
<h2 id="JDK动态代理和CGLIB动态代理"><a href="#JDK动态代理和CGLIB动态代理" class="headerlink" title="JDK动态代理和CGLIB动态代理"></a>JDK动态代理和CGLIB动态代理</h2><blockquote>
<p><a href="https://juejin.im/post/5c3e9c37f265da61263862f1">https://juejin.im/post/5c3e9c37f265da61263862f1</a><br><a href="https://juejin.im/post/5bbff7daf265da0aef4e330c">https://juejin.im/post/5bbff7daf265da0aef4e330c</a></p>
</blockquote>
<h2 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020</h2><h3 id="1-Java-的类加载器相关"><a href="#1-Java-的类加载器相关" class="headerlink" title="1.Java 的类加载器相关"></a>1.Java 的类加载器相关</h3><ul>
<li><p>1.Java 的类加载器的种类都有哪些?</p>
<pre><code>  1、根类加载器(Bootstrap)                --C++写的 ，看不到源码
  2、扩展类加载器（Extension）            --加载位置 ：jre\lib\ext 中
  3、系统(应用)类加载器(System\App)    --加载位置 ：classpath 中
  4、自定义加载器(必须继承 ClassLoader)
</code></pre>
</li>
<li><p>2.类什么时候被初始化?</p>
<pre><code>  1）创建类的实例，也就是 new 一个对象
  2）访问某个类或接口的静态变量，或者对该静态变量赋值
  3）调用类的静态方法
  4）反射（Class.forName(&quot;com.lyj.load&quot;)）
  5）初始化一个类的子类（会首先初始化子类的父类）
  6）JVM 启动时标明的启动类，即文件名和类名相同的那个类
  
  只有这 6 中情况才会导致类的类的初始化。
  
  类的初始化步骤：
  
      1）如果这个类还没有被加载和链接，那先进行加载和链接
      2）假如这个类存在直接父类，并且这个类还没有被初始化
      （注意：在一个类加载器中，类只能初始化一次），那就初始化直接的父类（不适用于接口）
      3)加入类中存在初始化语句（如 static 变量和static 块），那就依次执行这些初始化语句。
</code></pre>
</li>
<li><p>3.Java 类加载体系之ClassLoader和双亲委托机制</p>
<pre><code>  java 是一种类型安全的语言，它有四类称为安全沙箱机制的安全机制来保证语言的安全性，
  这四类安全沙箱分别是：
  
  1）类加载体系
  2）.class 文件检验器
  3）内置于 Java 虚拟机（及语言）的安全特性 
  4）安全管理器及Java API 
  
  这里主要讲解类的加载体系：
  java 程序中的 .java 文件编译完会生成 .class 文件，而 .class 文件
  就是通过被称为类加载器的ClassLoader加载的，而 ClassLoder 在加载过程中会
  使用“双亲委派机制”来加载 .class 文件，先上图：
</code></pre>
<p>  <img src="/2018/04/10/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%9320180410/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%BD%93%E7%B3%BB1.png"></p>
<pre><code>  1.BootStrapClassLoader:启动类加载器,该ClassLoader是jvm在启动时创建的,
  用于加载 $JAVA_HOME$/jre/lib 下面的类库（或者通过参数-Xbootclasspath指定）。
  由于启动类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，
  所以不能直接通过引用进行操作。
  
  2.ExtClassLoader:扩展类加载器,该ClassLoader是在sun.misc.Launcher里
  作为一个内部类ExtClassLoader定义的（即 sun.misc.Launcher$ExtClassLoader）,
  ExtClassLoader 会加载 $JAVA_HOME/jre/lib/ext 下的类库
  （或者通过参数-Djava.ext.dirs 指定）。
  
  3.AppClassLoader:应用程序类加载器，该ClassLoader同样是在sun.misc.Launcher里
  作为一个内部类AppClassLoader 定义的（即 sun.misc.Launcher$AppClassLoader）,
  AppClassLoader 会加载java环境变量CLASSPATH所指定的路径下的类库,而CLASSPATH所指定的路径 
  可以通过System.getProperty(&quot;java.class.path&quot;)获取；当然，该变量也可以覆盖，
  可以使用参数-cp，例如：java -cp 路径 （可以指定要执行的 class 目录）。
  
  4.CustomClassLoader:自定义类加载器，该ClassLoader 是指我们自定义的ClassLoader，
  比如tomcat的StandardClassLoader 属于这一类；当然，大部分情况下使用AppClassLoader
  就足够了。
</code></pre>
<p>  ​<br>  前面谈到了ClassLoader 的几类加载器，而ClassLoader使用双亲委派机制来加载class文件的。</p>
</li>
<li><p>ClassLoader的双亲委派机制是这样的（这里先忽略掉自定义类加载器 CustomClassLoader）:</p>
<pre><code>  1）当AppClassLoader加载一个class时,它首先不会自己去尝试加载这个类,而是把类加载请求委派给父类加载器ExtClassLoader去完成。
  
  2）当ExtClassLoader加载一个class时,它首先也不会自己去尝试加载这个类,而是把类加载请求委派给
  BootStrapClassLoader去完成。
  3）如果BootStrapClassLoader加载失败（例如在$JAVA_HOME$/jre/lib 里未查找到该class）,
  会使用ExtClassLoader来尝试加载；
  4）若 ExtClassLoader也加载失败,则会使用AppClassLoader来加载,如果AppClassLoader
  也加载失败,则会报出异常ClassNotFoundException。
</code></pre>
</li>
<li><p>下面贴下ClassLoader 的loadClass(String name, boolean resolve)的源码：</p>
<pre><code>  protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve)
  throws ClassNotFoundException &#123;
      // 首先找缓存是否有 class
      Class c = findLoadedClass(name);
      if (c == null) &#123;
          //没有判断有没有父类
          try &#123;
                  if (parent != null) &#123;
                      //有的话，用父类递归获取 class
                      c = parent.loadClass(name, false);
                  &#125; else &#123;
                      //没有父类。通过这个方法来加载
                      c = findBootstrapClassOrNull(name);
                  &#125;
          &#125; catch (ClassNotFoundException e) &#123;
                  // ClassNotFoundException thrown if class not found
                  // from the non-null parent class loader
          &#125;
          if (c == null) &#123;
              // 如果还是没有找到，调用 findClass(name)去找这个类
              c = findClass(name);
          &#125;
      &#125;
      if (resolve) &#123;
          resolveClass(c);
      &#125;
      return c;
  &#125;
  
  代码很明朗：首先找缓存（findLoadedClass），没有的话就判断有没有 parent，
  有的话就用 parent 来递归的 loadClass，然而 ExtClassLoader 并没有设置 parent，
  则会通过 findBootstrapClassOrNull 来加载 class，而findBootstrapClassOrNull 
  则会通过 JNI 方法”private native Class findBootstrapClass(String name)“来
  使用 BootStrapClassLoader 来加载 class。
  
  然后如果parent未找到class,则会调用findClass来加载class,findClass是一个
  protected 的空方法,可以覆盖它以便自定义class加载过程。
  另外,虽然ClassLoader加载类是使用loadClass方法,但是鼓励用ClassLoader的子类重写
  findClass(String)，而不是重写 loadClass，这样就不会覆盖了类加载默认的双亲委派机制。
</code></pre>
</li>
<li><p>4.双亲委派托机制为什么安全</p>
<pre><code>  举个例子,ClassLoader加载的class文件来源很多,比如编译器编译生成的class、或者网络下载的字节码。
  而一些来源的class 文件是不可靠的,比如我可以自定义一个java.lang.Integer类来覆盖jdk中默认的 
  Integer类,例如下面这样：
  
  package java.lang;
  public class Integer &#123;
      public Integer(int value) &#123;
          System.exit(0);
      &#125;
  &#125;
  
  初始化这个Integer 的构造器是会退出JVM，破坏应用程序的正常进行，如果使用双亲委派机制的话
  该Integer类永远不会被调用，以为委托BootStrapClassLoader加载后会加载JDK中的Integer类
  而不会加载自定义的这个，可以看下下面这测试个用例：
  
  public static void main(String... args) &#123;
      Integer i = new Integer(1);
      System.err.println(i); 
   &#125;

   执行时 JVM 并未在 new Integer(1)时退出，说明未使用自定义的 Integer，于是就保证了安全性。 
</code></pre>
</li>
<li><p>4.mybatis（mapper）调用过程</p>
<pre><code>  Mapper方法的执行过程：先获取Mapper对象，该对象是JdbcProxy代理对象。
  代理对象回调接口里，会根据Method，执行org.apache.ibatis.session.SqlSession对应的方法，
  同时需要完成参数的转化.
</code></pre>
<blockquote>
<p><a href="https://blog.csdn.net/bingospunky/article/details/79220894">https://blog.csdn.net/bingospunky/article/details/79220894</a><br><a href="https://www.jianshu.com/p/3c56bf3313ce">https://www.jianshu.com/p/3c56bf3313ce</a></p>
</blockquote>
</li>
<li><p>5.hashMap</p>
</li>
</ul>
<blockquote>
<p><a href="https://blog.csdn.net/woshimaxiao1/article/details/83661464">https://blog.csdn.net/woshimaxiao1/article/details/83661464</a></p>
</blockquote>
<ul>
<li><p>6.redis存储方式</p>
<pre><code>  Redis是一个由ANSI C语言编写，性能优秀、支持网络、可持久化的K-K内存数据库，
  并提供多种语言的API。它常用的类型主要是 String、List、Hash、Set、ZSet 这5种。
</code></pre>
<p>  <img src="/2018/04/10/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%9320180410/redis%E5%AD%98%E5%82%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B1.png"></p>
<pre><code>  Redis在互联网公司一般有以下应用:
  String：缓存、限流、计数器、分布式锁、分布式Session
  Hash：存储用户信息、用户主页访问量、组合查询
  List：微博关注人时间轴列表、简单队列
  Set：赞、踩、标签、好友关系
  Zset：排行榜
</code></pre>
<blockquote>
<p><a href="https://www.cnblogs.com/weknow619/p/10464139.html">https://www.cnblogs.com/weknow619/p/10464139.html</a></p>
</blockquote>
</li>
<li><p>7.MySQL数据库索引的4大类型及相关的索引创建</p>
<pre><code>  1.普通索引
      这是最基本的MySQL数据库索引，它没有任何限制。它有以下几种创建方式：
      
      a:创建索引:
          CREATE INDEX indexName ON mytable(username(length));
          
      b:修改表结构:
          ALTER mytable ADD INDEX [indexName] ON (username(length)) 创建表的时候直接指定
          CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, INDEX [indexName] (username(length)) );  
      
      c:删除索引的语法:
          DROP INDEX [indexName] ON mytable;   
      
  2.唯一索引
      它与前面的普通索引类似，不同的就是：MySQL数据库索引列的值必须唯一，但允许有空值。
      如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：
  
      a:创建索引:
      CREATE UNIQUE INDEX indexName ON mytable(username(length))
      b:修改表结构
      ALTER mytable ADD UNIQUE [indexName] ON (username(length))
      c:创建表的时候直接指定
      CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, UNIQUE [indexName] (username(length)) );   
  
  3.主键索引
      它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引：
      CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, PRIMARY KEY(ID) );  
      当然也可以用 ALTER 命令。记住：一个表只能有一个主键。

  4.组合索引
</code></pre>
<blockquote>
<p><a href="https://www.cnblogs.com/xingzc/p/5757697.html">https://www.cnblogs.com/xingzc/p/5757697.html</a></p>
</blockquote>
</li>
<li><p>7.ArrayList和LinkedList</p>
<pre><code>  ArrayList和LinkedList都是实现了List接口的容器类，用于存储一系列的对象引用。
  他们都可以对元素的增删改查进行操作。

  ArrayList和LinkedList的大致区别如下:

  1.ArrayList是实现了基于 动态数组 的数据结构，LinkedList是基于 链表结构 。
  2.对于随机访问的get和set方法，ArrayList要优于LinkedList，因为LinkedList要移动指针。
  3.对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。
</code></pre>
</li>
<li><p>8.查询前10条数据和后10条数据：</p>
<pre><code>  select top 10 * from tablename
  
  或者按时间正序or倒序，limit10
  select * from aaa where create_time&lt;=&quot;2017-03-29 19:30:36&quot;
  order by create_time desc/asc
  limit 10
  
  如果按照某个字段排序后，再limit10查询，速度有区别？貌似没区别
</code></pre>
</li>
<li><p>9.SQL调优，查询调优</p>
</li>
<li><p>10.shiro、springsecurity框架</p>
</li>
<li><p>11.springcloud组件    </p>
</li>
<li><p>12.SpringMVC调用流程(8大步骤)</p>
</li>
</ul>
<p><img src="/2018/04/10/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%9320180410/springmvc%E8%B0%83%E7%94%A8%E6%AD%A5%E9%AA%A4.png"></p>
<p>先记住几个概念:</p>
<pre><code>前端控制器 DispatcherServlet
处理器映射器 HandlerMapping
处理器执行链 HandlerExecutionChain
处理器适配器 HandlerAdapter
视图解析器ViewResolver

调用步骤：

1、客户端请求到前端控制器（dispatcherServlet）
2、前端控制器（dispatcherServlet）请求处理器映射器（HandlerMapping），
3、处理器映射器（HandlerMapping）根据url查找相应的处理器（Handler），返回处理器执行链（HandlerExecutionChain）给前端控制器（DispatcherServlet）
4、前端控制器（DispatcherServlet）请求处理器适配器（HandlerAdapter），
5、处理器适配器（HandlerAdapter）执行处理器（Handler），生成ModelAndView，返回ModelAndView给前端控制器（DispatcherServlet）
6、前端控制器（DispatcherServlet）请求视图解析器（ViewResolver）
7、视图解析器（ViewResovler）返回视图对象给前端控制器（DispatcherServlet）
8、最后渲染视图
</code></pre>
<p>13.优化Mysql数据库的方法</p>
<p><strong>回答一：</strong></p>
<pre><code>表优化，库优化，sql 优化，引擎优化。分库分表，设置合理字段、合理的字段索引数量，
读写分离，少用多层嵌套子查询，少用分组查询，少用多条件查询，少用模糊查询，查询中少用计算或统计等等。
优化的方式很多
</code></pre>
<p><strong>回答二：</strong></p>
<pre><code>mysql 数据库优化从两方面入手。
1.通过优化配置参数
如合适的 innodb 池大小，取消反向解析，合理的连接数，合理的超时时长，合理的相关 cache 等
2.通过操作的优化
如，合理的表结构，合理的索引，合理的查询语录(可通过分析慢查询日志找出可优化的，再通过 explain 去测试语句，找出可优化的点进行优化)。
如果都有优化了还有瓶颈、最后就是分表、分库、扩硬件、主从读写分离
</code></pre>
<p><strong>回答三（SQL级别）：</strong></p>
<pre><code>创建索引
索引不会包含有 NULL 值的列    
一般情况下不鼓励使用 like 操作，如果非使用不可，如何使用也是一个问题。
like “%aaa%” 不会使用索引而 like “aaa%”可以使用索引。
不要在列上进行运算
不使用 NOT IN 和&lt;&gt;操作
</code></pre>
<p>​<br>14.redis和mysql数据不一致怎么解决</p>
<pre><code>1 如果是 redis cluter 集群 
  因为 redis cluter 集群采用异步复制，在故障切换的过程中删除操作有可能丢失，所以只是删除缓存操作是有可能 redis mysql 不一致的，需要根据业务做特殊处理。
2 如果是单机 redis
    在更新数据的时候先加写锁，然后删除缓存，在加载缓存的时候加读锁,可有避免数据在修改过程中其他线程加载旧数据到 redis
</code></pre>
<p>15.Mybatis原理</p>
<p>mybatis 是数据持久层框架，基本原理是：</p>
<pre><code>1.创建 SqlSessionFactoryBuilder 对象，调用 build(inputstream)方法读取并解析配置文件，
返回 SqlSessionFactory 对象

2.由 SqlSessionFactory 创建 SqlSession 对象，没有手动设置的话事务默认开启

3.调用 SqlSession 中的 api，传入 Statement Id 和参数(mybatis dao xml 映射)，
内部进行复杂的处理，最后调用 jdbc 执行 SQL 语句，封装结果返回    
</code></pre>
<p>16.Spring的底层实现原理</p>
<pre><code>SpringIOC 的底层实现原理是：

传统开发方式：Person person = new Person
这种开发方式耦合度太高，不符合 java 编程思想（高内聚，低耦合）。

Spring ioc 就是把对象交给 spring 进行管理，需要的时候就去工厂拿就可以了，实现了低耦合，高内聚。
原理是：
首先加载 xml 配置文件，通过 dom4j 去解析 xml 文件，然后通过工厂模式和反射去创建对象。
Springaop 的实现原理：
aop，面向切面编程，是 Spring 两大核心之一，Springaop 是通过代理的方式实现切面编程的。
    主要是以下两种代理方式：
    一种是基于 JDK 的动态代理（目标对象实现了接口）
    一种是基于 cglib 的动态代理（目标对象没有实现接口）
</code></pre>
<p>17.Collection 和 Collections 的区别。</p>
<pre><code>Collection 是集合类的上级接口，继承与他的接口主要有 Set 和 List。
Collections 是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。
</code></pre>
<p>18.HashMap 工作原理是什么？</p>
<pre><code>回答一：
1.8 之前，hashmap 的数据结构是：数组+链表
1.8 以后，hashmap 的数据结构是：数组+链表+红黑树
1.8 以后，做了很大的改变，使用红黑树，可以大大提高查询效率。
可以深挖一下红黑树的应用。
就其他方面来说，
1.8 插入元素时，使用的是头插法，在插入元素出现 hash 碰撞，会引起红黑树数据结构进行对 node 链表数据的插入。    
回答二：
原理是hash表
能快速定位到指定的 key 对应的 value，实现使用的是数组加一个链式结构，
1.8 之前用的是链表，1.8 之后用的是链表加红黑树。
插入数据的基本流程就是计算 k 的 hashcode 然后用这个 hashcode 去和整个数组空间去进行按位于，
得到具体需要放置的数组索引。
然后就是一个比对和放置的过程，对比当前的数据链是否有相同的，没有就放，有就不放。
取出数据规则差不多也是根据 key 的 hashcode 去得到数组索引位，然后比对
</code></pre>
<p>19.请解释什么是值传递和引用传递？</p>
<pre><code>值传递是对基本型变量而言的，传递的是该变量的一个副本，改变副本不影响原变量。
引用传递一般是对于对象型变量而言的，传递的是该对象地址的一个副本，并不是原对象本身。
所以对引用对象进行操作会同时改变原对象。
一般认为 Java 内的传递都是值传递。    
</code></pre>
<p>20.内存溢出和内存泄露区别</p>
<pre><code>内存溢出:
内存溢出就是常见的 OOM，说白了就是申请的内存小了，可能原因 JVM 内存太小，
对象所需内存太大，还有可能就是程序设计问题。解决方式要么修改 jvm 参数，要么修改程序。

内存泄露:
内存泄露就是对象本应该被回收，但是其他地方还在使用它的引用，导致无法释放内存，
引起这种的原因一般是非静态内部类中创建了静态实例，或者是单例对象，因为单例的静态特性，
会使它生命周期和应用的生命周期一样长，如果一个对象已经不需要了，但单例对象还依旧持有该对象的引用，
就会导致不能被正常回收，致使内存泄露。集合容器也可能导致内存泄露，因为集合很大的时候，没有来得及清理，
也会导致内存泄露。避免的最好的方式就是养成良好编码习惯，该销毁的对象要销毁，涉及到上下文的优先考虑全局。
</code></pre>
<p>21.请介绍一下 Syncronized 锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？</p>
<pre><code>Synchronized 修饰静态方法以及同步代码块的 Synchronized (类.class)用法锁的是类，
线程想要执行对应同步代码，需要获得类锁。
Synchronized 修饰成员方法，线程获取的是当前调用该方法的对象实例的对象锁。
</code></pre>
<p>22.MySQL的四种事务隔离级别</p>
<pre><code>一.事务的基本要素（ACID)

1、原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。
2、一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。
3、隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。
4、持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。

二.MySQL事务隔离级别
</code></pre>
<p><img src="/2018/04/10/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%9320180410/mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.jpg"></p>
<pre><code>三、事务的并发问题
    1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据
    2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，
    导致事务A多次读取同一数据时，结果 不一致。
    3、幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，
    但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，
    就好像发生了幻觉一样，这就叫幻读。

    小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。
    解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表
</code></pre>
<p>23.spring是如何解决循环依赖问题的</p>
<pre><code>如何理解“依赖”呢，在Spring中有：
构造器循环依赖
field属性注入循环依赖
</code></pre>
<blockquote>
<p><a href="https://www.cnblogs.com/sun-sun/p/10521334.html">https://www.cnblogs.com/sun-sun/p/10521334.html</a><br><a href="https://www.jianshu.com/p/8bb67ca11831">https://www.jianshu.com/p/8bb67ca11831</a></p>
</blockquote>
<h2 id="redis做同步锁"><a href="#redis做同步锁" class="headerlink" title="redis做同步锁"></a>redis做同步锁</h2><ul>
<li><p>redis分布式加锁解锁</p>
<pre><code>  ***synchronized处理并发.wmv***
  com.imux.wxsell.service包下的RedisLock类：
  
  package com.imux.wxsell.service;
  
  import lombok.extern.slf4j.Slf4j;
  import org.springframework.beans.factory.annotation.Autowired;
  import org.springframework.data.redis.core.StringRedisTemplate;
  import org.springframework.stereotype.Component;
  import org.springframework.util.StringUtils;
  
  /**
   * redis lock
   */
  @Component
  @Slf4j
  public class RedisLock &#123;
      @Autowired
      private StringRedisTemplate stringRedisTemplate;
  
      /**
       * 加锁
       *
       * @param key   productId - 商品的唯一标志
       * @param value 当前时间+超时时间&gt;&gt;&gt;即过期的时刻
       * @return
       */
      public boolean lock(String key, String value) &#123;
          //setIfAbsent &gt;&gt;&gt;&gt;&gt;&gt;&gt;redis的SETNX方法
          if (stringRedisTemplate.opsForValue().setIfAbsent(key, value)) &#123;//对应setnx命令
              //可以成功设置,也就是key不存在
              return true;
          &#125;
  
          //判断锁超时 - 防止原来的操作异常，没有运行解锁操作  防止死锁
          String currentValue = stringRedisTemplate.opsForValue().get(key);
          
          //如果锁过期
          if (!StringUtils.isEmpty(currentValue) &amp;&amp;
                  Long.parseLong(currentValue) &lt; System.currentTimeMillis()) &#123;//currentValue不为空且小于当前时间
              //获取上一个锁的时间value
              String oldValue = stringRedisTemplate.opsForValue().getAndSet(key, value);//对应getset，如果key存在
  
              //假设两个线程同时进来，key被占用了。获取的值currentValue=A(get取的旧的值肯定是一样的),两个线程的value都是B,key都是K.锁时间已经过期了。
              //而这里面的getAndSet一次只会一个执行，也就是一个执行之后，上一个的value已经变成了B。只有一个线程获取的上一个值会是A，另一个线程拿到的值是B。
              if (!StringUtils.isEmpty(oldValue) &amp;&amp; oldValue.equals(currentValue)) &#123;
                  //oldValue不为空且oldValue等于currentValue，也就是校验是不是上个对应的商品时间戳，也是防止并发
                  return true;
              &#125;
          &#125;
          return false;
      &#125;
</code></pre>
<p>  ​    </p>
<pre><code>      /**
       * 解锁
       *
       * @param key
       * @param value
       */
      public void unlock(String key, String value) &#123;
          try &#123;
              String currentValue = stringRedisTemplate.opsForValue().get(key);
              if (!StringUtils.isEmpty(currentValue) &amp;&amp; currentValue.equals(value)) &#123;
                  stringRedisTemplate.opsForValue().getOperations().delete(key);//删除key
              &#125;
          &#125; catch (Exception e) &#123;
              log.error(&quot;[Redis分布式锁] 解锁出现异常了，&#123;&#125;&quot;, e);
          &#125;
      &#125;
  &#125;
  
      //使用锁的类方法：
      @Autowired
      private RedisLock redisLock;//redis锁
      //超时时间
      private static final int TIMEOUT = 10 * 1000;//超时时间 10s
  
      ------------------------------------------------------------
      @Override
      public void orderProductMockDiffUser(String productId) &#123;
  
          ************//加锁************
          long time = System.currentTimeMillis() + TIMEOUT;
          if (!redisLock.lock(productId, String.valueOf(time))) &#123;
              throw new OrderException(&quot;&quot;, &quot;很抱歉，人太多了，换个姿势再试试~~&quot;);
          &#125;
  
          //1.查询该商品库存，为0则活动结束
          int stockNum = stock.get(productId);
          if (stockNum == 0) &#123;
              throw new OrderException(&quot;&quot;, &quot;活动结束&quot;);
          &#125; else &#123;
              //2.下单
              orders.put(TableIdUtil.tableId(), productId);
              //3.减库存
              stockNum = stockNum - 1;//不做处理的话，高并发下会出现超卖的情况，下单数，大于减库存的情况。
              虽然这里减了，但由于并发，减的库存还没存到map中去。新的并发拿到的是原来的库存
              try &#123;
                  Thread.sleep(100);//模拟减库存的处理时间
              &#125; catch (InterruptedException e) &#123;
                  e.printStackTrace();
              &#125;
              stock.put(productId, stockNum);
          &#125;
  
          ************//解锁************
          redisLock.unlock(productId, String.valueOf(time));
  
      &#125;
</code></pre>
</li>
</ul>
<h2 id="springboot的核心功能，start的原理"><a href="#springboot的核心功能，start的原理" class="headerlink" title="springboot的核心功能，start的原理"></a>springboot的核心功能，start的原理</h2><h2 id="springcloud的网关，其他主要组件"><a href="#springcloud的网关，其他主要组件" class="headerlink" title="springcloud的网关，其他主要组件"></a>springcloud的网关，其他主要组件</h2><h2 id="feign等远程调用流程原理"><a href="#feign等远程调用流程原理" class="headerlink" title="feign等远程调用流程原理"></a>feign等远程调用流程原理</h2><p>​        </p>
]]></content>
      <tags>
        <tag>面试总结20180410</tag>
      </tags>
  </entry>
</search>
